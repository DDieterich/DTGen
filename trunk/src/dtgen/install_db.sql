
--
--  Install Database Scripts for DTGEN
--
--  The 6 scripts included are:
--    -) create_glob
--    -) create_ods
--    -) create_integ
--    -) create_oltp
--    -) create_aa
--    -) create_mods
--


select ' -) create_glob  ' as FILE_NAME from dual;


-- Script File "create_glob"
--    Create Globals using generated code
--
--    Generated by DTGen (http://code.google.com/p/dtgen)
--    July      27, 2012  09:33:43 PM


CREATE package glob
is

   -- Package Glob
   --    Globally available settings and functions
   --    (Centrally located, but globally visible)
   --
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:33:43 PM

   -- TRUE - Table Triggers run TABLE_TAB calls
   -- FALSE - View_TABs run TABLE_TAB calls
   procedure set_db_constraints
      (bool_in  in  boolean);
   function get_db_constraints
      return boolean;

   -- TRUE - Change string data to required case
   -- FALSE - Check string data for require case
   procedure set_fold_strings
      (bool_in  in  boolean);
   function get_fold_strings
      return boolean;

   procedure set_asof_dtm
         (asof_dtm_in  in  timestamp with time zone);
   function get_asof_dtm
      return timestamp with time zone;

   function get_dtm
      return timestamp with local time zone;

   procedure upd_early_eff
      (table_name  in  varchar2
      ,eff_dtm_in  in  timestamp);

   function request_lock
         (lockname_in  in  varchar2
         ,timeout_in   in  INTEGER  default null)
      return varchar2;
   function release_lock
      return varchar2;

end glob;
/
select 'GLOB' as "Package:"
 from  user_errors
 where name = 'GLOB'
  and  type = 'PACKAGE'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'GLOB'
  and  type = 'PACKAGE'
 order by sequence;

CREATE package body glob
is

-- Package Body Glob
--    Globally available settings and functions
--    (Centrally located, but globally visible)
--
--    Generated by DTGen (http://code.google.com/p/dtgen)
--    July      27, 2012  09:33:43 PM

db_constraints        boolean := false;
fold_strings          boolean := true;
asof_dtm              timestamp with time zone :=
   to_timestamp_tz('2010-01-01 00:00:00 UTC','YYYY-MM-DD HH24:MI:SS TZR');
st_lockhandle         varchar2(128);  -- Single Threaded DBMS_LOCK
st_lockname           varchar2(128);  -- Single Threaded DBMS_LOCK

----------------------------------------
procedure set_db_constraints
      (bool_in  in  boolean)
is
begin
   db_constraints := bool_in;
end set_db_constraints;
----------------------------------------
function get_db_constraints
      return boolean
is
begin
   return db_constraints;
end get_db_constraints;
----------------------------------------
procedure set_fold_strings
      (bool_in  in  boolean)
is
begin
   fold_strings := bool_in;
end set_fold_strings;
----------------------------------------
function get_fold_strings
      return boolean
is
begin
   return fold_strings;
end get_fold_strings;
----------------------------------------
procedure set_asof_dtm
      (asof_dtm_in  in  timestamp with time zone)
is
begin
   asof_dtm := asof_dtm_in;
end set_asof_dtm;
----------------------------------------
function get_asof_dtm
   return timestamp with time zone
is
begin
   return asof_dtm;
end get_asof_dtm;
----------------------------------------
function get_dtm
      return timestamp with local time zone
is
begin
   return systimestamp;
end get_dtm;
----------------------------------------
procedure upd_early_eff
   (table_name  in  varchar2
   ,eff_dtm_in  in  timestamp)
   -- Centralized procedure to set next ETL start date/time
is
begin
   null;
end upd_early_eff;
----------------------------------------
procedure allocate_lock
is
   PRAGMA AUTONOMOUS_TRANSACTION;
begin
   dbms_lock.allocate_unique(lockname        => st_lockname
                            ,lockhandle      => st_lockhandle
                            ,expiration_secs => 43200);
end allocate_lock;
----------------------------------------
function request_lock
      (lockname_in  in  varchar2
      ,timeout_in   in  INTEGER  default null)
   return varchar2
is
   retcd number;
begin
   if st_lockname is not null
   then
      if st_lockname = lockname_in
      then
         return 'SUCCESS';
      else
         return 'RELEASE ONLY';
      end if;
   end if;
   st_lockname := lockname_in;
   allocate_lock;
   retcd := dbms_lock.request(lockhandle        => st_lockhandle
                             ,lockmode          => DBMS_LOCK.X_MODE
                             ,timeout           => nvl(timeout_in,DBMS_LOCK.MAXWAIT)
                             ,release_on_commit => TRUE);
   case retcd
      when 0 then
         return 'SUCCESS';
      when 4 then
         -- This session already owns the lock
         return 'SUCCESS';
      when 1 then
         st_lockname   := null;
         return 'TIMEOUT';
      when 2 then
         st_lockname   := null;
         return 'DEADLOCK';
      when 3 then
         st_lockname   := null;
         return 'PARAMETER ERROR';
      when 5 then
         st_lockname   := null;
         return 'ILLEGAL LOCKNAME';
   end case;
   return 'END ERROR';
end request_lock;
----------------------------------------
function release_lock
   return varchar2
is
   retcd INTEGER;
begin
   if st_lockname is null
   then
      return 'SUCCESS';
   end if;
   retcd := dbms_lock.release(lockhandle => st_lockhandle);
   case retcd
      when 0 then
         st_lockname := null;
         return 'SUCCESS';
      when 4 then
         -- This session doesn't own the lock
         st_lockname := null;
         return 'SUCCESS';
      when 3 then
         return 'PARAMETER ERROR';
      when 5 then
         return 'ILLEGAL LOCKNAME';
   end case;
   return 'END ERROR';
end release_lock;
----------------------------------------
begin
   st_lockname := null;
end glob;
/
select 'GLOB' as "Package Body:"
 from  user_errors
 where name = 'GLOB'
  and  type = 'PACKAGE BODY'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'GLOB'
  and  type = 'PACKAGE BODY'
 order by sequence;

-- Setup Varray Structures for Name/Value Pair Storage
create type pair_type as object
   (name  varchar2(30)
   ,data  varchar2(32767)
   );
/
select 'PAIR_TYPE' as "Type:"
 from  user_errors
 where name = 'PAIR_TYPE'
  and  type = 'TYPE'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'PAIR_TYPE'
  and  type = 'TYPE'
 order by sequence;

create type col_type as varray(100) of pair_type;
/
select 'COL_TYPE' as "Type:"
 from  user_errors
 where name = 'COL_TYPE'
  and  type = 'TYPE'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'COL_TYPE'
  and  type = 'TYPE'
 order by sequence;


/* Error Log and Debug Log Test Script:
declare
   procedure test1
   is
      junk number;
   begin
      util.log('Testing Debug');
      junk := 1 / 0;
   end;
begin
   dbms_output.enable;
   util.set_usr('Testor1');
   insert into util_log (dtm, usr, txt)
      values (systimestamp, 'Testor1', 'Testing Commit');
   commit;
   insert into util_log (dtm, usr, txt)
      values (systimestamp, 'Testor1', 'Testing Rollback');
   test1;
exception
   when others then
     util.log(SQLERRM);
     rollback;
end;
*/

-- Table of debug and error messages.
create table util_log
   (dtm              timestamp with local time zone
   ,usr              varchar2(30)
   ,txt              varchar2(4000)
   ,loc              varchar2(2000)
   );

create index util_log_ix1 on util_log (dtm, usr);

comment on table util_log is 'Error and Debug Messages';

comment on column util_log.dtm is 'System time when message was logged';
comment on column util_log.usr is 'Username from util.get_usr function';
comment on column util_log.txt is 'Error or Debug message text';
comment on column util_log.loc is 'Location in the source code where the message as logged';

CREATE package util
is

   -- Package Util
   --    Utility settings and functions
   --    (A copy is located locally on a each node)
   --
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:33:44 PM

   -- Separates values within a set of Natural Keys
   nk_sep  constant varchar2(1) := ',';
   -- Separates values in a path hierarchy
   path_sep  constant varchar2(1) := ':';

   -- TRUE - gen_no_change error is ignored during UPDATE
   -- FALSE - gen_no_change error is enforced during UPDATE
   ignore_no_change  boolean := true;

   first_dtm  constant timestamp with time zone :=
        to_timestamp_tz('1970-01-01 00:00:00 UTC','YYYY-MM-DD HH24:MI:SS TZR');
   last_dtm   constant timestamp with time zone :=
        to_timestamp_tz('4713-12-31 23:59:59 UTC','YYYY-MM-DD HH24:MI:SS TZR');

   current_usr varchar2(30);

   function get_version
      return varchar2;

   function get_first_dtm
      return timestamp with time zone;
   function get_last_dtm
      return timestamp with time zone;

   function is_equal
         (t1_in  in  varchar2
         ,t2_in  in  varchar2
         )
      return boolean;
   function is_equal
         (n1_in  in  number
         ,n2_in  in  number
         )
      return boolean;

   procedure set_usr
         (usr_in  in  varchar2
         );
   function get_usr
      return varchar;

   procedure init_longops
         (opname_in       in  varchar2
         ,totalwork_in    in  number
         ,target_desc_in  in  varchar2
         ,units_in        in  varchar2);
   procedure add_longops
         (add_sofar_in  in  number);
   procedure end_longops;

   procedure log
         (txt_in  in  varchar2
         ,loc_in  in  varchar2 default null
         );
   procedure err
         (txt_in  in  varchar2
         );

   function db_object_exists
         (name_in  in  varchar2
         ,type_in  in  varchar2
         )
     return boolean;

   function col_to_clob
         (col_in  in  col_type
         )
     return clob;
   function col_data
         (col_in   in  col_type
         ,name_in  in  varchar2
         )
     return varchar2;

end util;
/
select 'UTIL' as "Package:"
 from  user_errors
 where name = 'UTIL'
  and  type = 'PACKAGE'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'UTIL'
  and  type = 'PACKAGE'
 order by sequence;

CREATE package body util
is

-- Package Body Util
--    Utility settings and functions
--    (A copy is located locally on a each node)
--
--    Generated by DTGen (http://code.google.com/p/dtgen)
--    July      27, 2012  09:33:44 PM

lo_context      BINARY_INTEGER;  -- DBMS_APPLICATION.set_session_longops
lo_op_name      varchar2(64);    -- DBMS_APPLICATION.set_session_longops
lo_rindex       BINARY_INTEGER;  -- DBMS_APPLICATION.set_session_longops
lo_slno         BINARY_INTEGER;  -- DBMS_APPLICATION.set_session_longops
lo_sofar        number;          -- DBMS_APPLICATION.set_session_longops
lo_totalwork    number;          -- DBMS_APPLICATION.set_session_longops
lo_target       BINARY_INTEGER;  -- DBMS_APPLICATION.set_session_longops
lo_target_desc  varchar2(32);    -- DBMS_APPLICATION.set_session_longops
lo_units        varchar2(32);    -- DBMS_APPLICATION.set_session_longops

----------------------------------------
function get_version
   return varchar2
is
begin
   return 'DTGen_0.11';
end get_version;
----------------------------------------
function get_first_dtm
   return timestamp with time zone
is
begin
   return first_dtm;
end get_first_dtm;
----------------------------------------
function get_last_dtm
      return timestamp with time zone
is
begin
   return last_dtm;
end get_last_dtm;
----------------------------------------
function is_equal
      (t1_in  in  varchar2
      ,t2_in  in  varchar2
      )
   return boolean
is
begin
   if t1_in = t2_in or (t1_in is null and t2_in is null)
   then
      return TRUE;
   else
      return FALSE;
   end if;
end is_equal;
----------------------------------------
function is_equal
      (n1_in  in  number
      ,n2_in  in  number
      )
   return boolean
is
begin
   if n1_in = n2_in or (n1_in is null and n2_in is null)
   then
      return TRUE;
   else
      return FALSE;
   end if;
end is_equal;
----------------------------------------
procedure set_usr
      (usr_in  in  varchar2)
is
begin
   current_usr := substr(usr_in,1,30);
end set_usr;
----------------------------------------
function get_usr
   return varchar
is
begin
   if current_usr is null
   then
      raise_application_error(-20002, 'Current User has not been set in the Util Package.');
   end if;
   return current_usr;
end get_usr;
----------------------------------------
procedure init_longops
      (opname_in       in  varchar2
      ,totalwork_in    in  number
      ,target_desc_in  in  varchar2
      ,units_in        in  varchar2)
is
begin
   if lo_rindex = dbms_application_info.set_session_longops_nohint
   then
      lo_slno        := null;
      lo_op_name     := opname_in;
      lo_target      := 0;
      lo_context     := 0;
      lo_sofar       := 0;
      lo_totalwork   := totalwork_in;
      lo_target_desc := target_desc_in;
      lo_units       := units_in;
      dbms_application_info.set_session_longops
         (lo_rindex, lo_slno, lo_op_name, lo_target, lo_context,
          lo_sofar, lo_totalwork, lo_target_desc, lo_units);
   end if;
end init_longops;
----------------------------------------
procedure add_longops
      (add_sofar_in  in  number)
is
begin
   if lo_rindex <> dbms_application_info.set_session_longops_nohint
   then
      lo_sofar := lo_sofar + add_sofar_in;
      dbms_application_info.set_session_longops
         (lo_rindex, lo_slno, lo_op_name, lo_target, lo_context,
          lo_sofar, lo_totalwork, lo_target_desc, lo_units);
   end if;
end add_longops;
----------------------------------------
procedure end_longops
is
begin
   if lo_rindex <> dbms_application_info.set_session_longops_nohint
   then
      lo_sofar := lo_totalwork;
      dbms_application_info.set_session_longops
         (lo_rindex, lo_slno, lo_op_name, lo_target, lo_context,
          lo_sofar, lo_totalwork, lo_target_desc, lo_units);
      lo_rindex := dbms_application_info.set_session_longops_nohint;
   end if;
end end_longops;
----------------------------------------
procedure log
      (txt_in  in  varchar2
      ,loc_in  in  varchar2 default null
      )
is
/*  Sample output from DBMS_UTILITY.FORMAT_CALL_STACK:
----- PL/SQL Call Stack -----
  object      line  object
  handle    number  name
A4A6A840        76  package body GEN2.UTIL
AA345744         6  anonymous block
AA345744        16  anonymous block
*/
   PRAGMA AUTONOMOUS_TRANSACTION;
   usr_txt  varchar2(30);
   fcs_txt  varchar2(2000);
begin
   -- pragma restrict_references(format_call_stack,WNDS);
   -- WNDS Asserts that the subprogram writes no database state
   --      (does not modify database tables).
   -- DBMS_UTILITY.FORMAT_CALL_STACK returns up to 2000 characters
   fcs_txt := DBMS_UTILITY.FORMAT_CALL_STACK;
   begin
      usr_txt := get_usr;
   exception
      when others then
         usr_txt := 'UTIL.LOG (No User)';
   end;
   insert into util_log
         (dtm
         ,usr
         ,txt
         ,loc
         )
      values
         (systimestamp
         ,usr_txt
         ,substr(txt_in,1,4000)
         ,fcs_txt
         );
   dbms_output.put_line(txt_in || fcs_txt);
   commit;
end log;
----------------------------------------
procedure err
      (txt_in  in  varchar2
      )
is
   fcs_txt  varchar2(2000) := DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
   retstr   varchar2(100);
begin
   log (txt_in, fcs_txt);
   end_longops;
   retstr := glob.release_lock;
end err;
----------------------------------------
function db_object_exists
      (name_in  in  varchar2
      ,type_in  in  varchar2
      )
   return boolean
is
   cursor c1 is
      select * from all_objects
       where object_type = type_in
        and  object_name = name_in;
   buf1 c1%ROWTYPE;
   retb boolean;
begin
   open c1;
   fetch c1 into buf1;
   retb := c1%FOUND;
   close c1;
   return retb;
end db_object_exists;
----------------------------------------
function col_to_clob
      (col_in  in  col_type
      )
   return clob
is
   rclob  clob;
   rlen   number;
begin
   rclob := '';
   for i in 1 .. col_in.COUNT
   loop
      rclob := rclob ||
               col_in(i).name || ':' ||
               col_in(i).data || CHR(10);
   end loop;
   rlen := length(rclob);
   if rlen > 32768
   then
      rlen := 32768;
   end if;
   return substr(rclob,1,rlen-1);
exception
  when SUBSCRIPT_BEYOND_COUNT
  then
     return null;
  when COLLECTION_IS_NULL
  then
     return null;
  when others
  then
     raise;
end col_to_clob;
----------------------------------------
function col_data
         (col_in   in  col_type
         ,name_in  in  varchar2
         )
     return varchar2
is
   --
   -- col_data was used for the POP_AUDIT log table
   --
begin
   for i in 1 .. col_in.COUNT
   loop
      if lower(name_in) = lower(col_in(i).name)
      then
         return col_in(i).data;
      end if;
   end loop;
   return null;
exception
  when SUBSCRIPT_BEYOND_COUNT
  then
     return null;
  when COLLECTION_IS_NULL
  then
     return null;
  when others
  then
     raise;
end col_data;
----------------------------------------
begin
   dbms_output.enable(1048576);
   lo_rindex := dbms_application_info.set_session_longops_nohint;
end util;
/
select 'UTIL' as "Package Body:"
 from  user_errors
 where name = 'UTIL'
  and  type = 'PACKAGE BODY'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'UTIL'
  and  type = 'PACKAGE BODY'
 order by sequence;



select ' -) create_ods  ' as FILE_NAME from dual;


-- Script File "create_ods"
--    Create Online Data Store using generated code
--
--    Generated by DTGen (http://code.google.com/p/dtgen)
--    July      27, 2012  09:33:49 PM


----------------------------------------
select '***  applications  ***' as TABLE_NAME from dual;
----------------------------------------

create package applications_tab
is

   -- Package Applications_Tab
   --    Table functions
   --    (DML and integrity checks)
   --
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:33:49 PM

   procedure ins
      (n_id  in out  NUMBER
      ,n_abbr  in out  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,n_db_schema  in out  VARCHAR2
      ,n_db_schema_exp  in out  VARCHAR2
      ,n_apex_schema  in out  VARCHAR2
      ,n_apex_ws_name  in out  VARCHAR2
      ,n_apex_app_name  in out  VARCHAR2
      ,n_dbid  in out  VARCHAR2
      ,n_db_auth  in out  VARCHAR2
      ,n_description  in out  VARCHAR2
      ,n_ts_null_override  in out  VARCHAR2
      ,n_ts_onln_data  in out  VARCHAR2
      ,n_ts_onln_indx  in out  VARCHAR2
      ,n_ts_hist_data  in out  VARCHAR2
      ,n_ts_hist_indx  in out  VARCHAR2
      ,n_usr_datatype  in out  VARCHAR2
      ,n_usr_frgn_key  in out  VARCHAR2
      ,n_copyright  in out  VARCHAR2
      );
   procedure upd
      (o_id  in  NUMBER
      ,o_abbr  in  VARCHAR2
      ,n_abbr  in out  VARCHAR2
      ,o_name  in  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,o_db_schema  in  VARCHAR2
      ,n_db_schema  in out  VARCHAR2
      ,o_db_schema_exp  in  VARCHAR2
      ,n_db_schema_exp  in out  VARCHAR2
      ,o_apex_schema  in  VARCHAR2
      ,n_apex_schema  in out  VARCHAR2
      ,o_apex_ws_name  in  VARCHAR2
      ,n_apex_ws_name  in out  VARCHAR2
      ,o_apex_app_name  in  VARCHAR2
      ,n_apex_app_name  in out  VARCHAR2
      ,o_dbid  in  VARCHAR2
      ,n_dbid  in out  VARCHAR2
      ,o_db_auth  in  VARCHAR2
      ,n_db_auth  in out  VARCHAR2
      ,o_description  in  VARCHAR2
      ,n_description  in out  VARCHAR2
      ,o_ts_null_override  in  VARCHAR2
      ,n_ts_null_override  in out  VARCHAR2
      ,o_ts_onln_data  in  VARCHAR2
      ,n_ts_onln_data  in out  VARCHAR2
      ,o_ts_onln_indx  in  VARCHAR2
      ,n_ts_onln_indx  in out  VARCHAR2
      ,o_ts_hist_data  in  VARCHAR2
      ,n_ts_hist_data  in out  VARCHAR2
      ,o_ts_hist_indx  in  VARCHAR2
      ,n_ts_hist_indx  in out  VARCHAR2
      ,o_usr_datatype  in  VARCHAR2
      ,n_usr_datatype  in out  VARCHAR2
      ,o_usr_frgn_key  in  VARCHAR2
      ,n_usr_frgn_key  in out  VARCHAR2
      ,o_copyright  in  VARCHAR2
      ,n_copyright  in out  VARCHAR2
      );
   procedure del
      (o_id  in  NUMBER
      ,o_abbr  in  VARCHAR2
      ,o_name  in  VARCHAR2
      ,o_db_schema  in  VARCHAR2
      ,o_db_schema_exp  in  VARCHAR2
      ,o_apex_schema  in  VARCHAR2
      ,o_apex_ws_name  in  VARCHAR2
      ,o_apex_app_name  in  VARCHAR2
      ,o_dbid  in  VARCHAR2
      ,o_db_auth  in  VARCHAR2
      ,o_description  in  VARCHAR2
      ,o_ts_null_override  in  VARCHAR2
      ,o_ts_onln_data  in  VARCHAR2
      ,o_ts_onln_indx  in  VARCHAR2
      ,o_ts_hist_data  in  VARCHAR2
      ,o_ts_hist_indx  in  VARCHAR2
      ,o_usr_datatype  in  VARCHAR2
      ,o_usr_frgn_key  in  VARCHAR2
      ,o_copyright  in  VARCHAR2
      );
end applications_tab;
/
select 'APPLICATIONS_TAB' as "Package:"
 from  user_errors
 where name = 'APPLICATIONS_TAB'
  and  type = 'PACKAGE'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'APPLICATIONS_TAB'
  and  type = 'PACKAGE'
 order by sequence;

create sequence applications_seq;

create table applications
   (id   NUMBER(38)
   ,abbr   VARCHAR2(5)
   ,name   VARCHAR2(30)
   ,db_schema   VARCHAR2(30)
   ,db_schema_exp   VARCHAR2(1)
   ,apex_schema   VARCHAR2(30)
   ,apex_ws_name   VARCHAR2(30)
   ,apex_app_name   VARCHAR2(30)
   ,dbid   VARCHAR2(2000)
   ,db_auth   VARCHAR2(200)
   ,description   VARCHAR2(1000)
   ,ts_null_override   VARCHAR2(1)
   ,ts_onln_data   VARCHAR2(30)
   ,ts_onln_indx   VARCHAR2(30)
   ,ts_hist_data   VARCHAR2(30)
   ,ts_hist_indx   VARCHAR2(30)
   ,usr_datatype   VARCHAR2(20)
   ,usr_frgn_key   VARCHAR2(100)
   ,copyright   CLOB
   );

comment on table applications is 'Applications to be generated';

comment on column applications.id is 'Surrogate Primary Key for these applications';
comment on column applications.abbr is 'Abbreviation for this application';
comment on column applications.name is 'Name of this application';
comment on column applications.db_schema is 'Name of the database schema objects owner. Used for user synonym and DB Link creation. Also used for explicit owner of all database objects if db_schema_exp flag is set.';
comment on column applications.db_schema_exp is 'Explicitly define the schema owner for all database object';
comment on column applications.apex_schema is 'Name of the APEX parsing schema owner for the generated APEX pages';
comment on column applications.apex_ws_name is 'Workspace name (Upper Case) for the generated APEX pages';
comment on column applications.apex_app_name is 'Application name (Mixed Case) for the generated APEX pages';
comment on column applications.dbid is 'Database link connect string for mid-tier connections to the centralized database server.';
comment on column applications.db_auth is 'Database link authorization for mid-tier connections to the centralized database server';
comment on column applications.description is 'Description of this application';
comment on column applications.ts_null_override is 'Flag to override all tablespace names to null';
comment on column applications.ts_onln_data is 'Default tableapace name for on-line data tables';
comment on column applications.ts_onln_indx is 'Default tablespace name for on-line indexes';
comment on column applications.ts_hist_data is 'Default tablespace name for history data tables';
comment on column applications.ts_hist_indx is 'Default tablespace name for history indexes';
comment on column applications.usr_datatype is 'Datatype for the "_USR" data columns in history tables tables. The default value is VARCHAR2(30).';
comment on column applications.usr_frgn_key is 'Foreign Key for the "_USR" data columns in history tables. Must be of the form "table", "schema.table", "table(column)",  or "schema.table(column)".';
comment on column applications.copyright is 'Copyright notice that is placed in the comment header in all generated scripts';

alter table applications add constraint applications_pk
   primary key (id);

/***  ACTIVE Foreign Keys  ***/
/***  ACTIVE Audit Foreign Key ***/
-- alter table applications add constraint applications_fa1
--    foreign key (beg_aud_usr) references sys.usr$ (name);

/***  ACTIVE Indexes  ***/
alter table applications add constraint applications_nk
    unique (abbr
           );
alter table applications add constraint applications_ux1
    unique (name
           );


/***  ACTIVE Audit Foreign Key Indexes  ***/
-- create index applications_ia1 on applications(aud_beg_usr);
-- create index applications_ia2 on applications(aud_beg_dtm);

create package body applications_tab
is

-- Package Body Applications_Tab
--    Table functions
--    (DML and integrity checks)
--
--    Generated by DTGen (http://code.google.com/p/dtgen)
--    July      27, 2012  09:33:49 PM

----------------------------------------
procedure check_rec
      (id  in  NUMBER
      ,abbr  in out  VARCHAR2
      ,name  in out  VARCHAR2
      ,db_schema  in out  VARCHAR2
      ,db_schema_exp  in out  VARCHAR2
      ,apex_schema  in out  VARCHAR2
      ,apex_ws_name  in out  VARCHAR2
      ,apex_app_name  in out  VARCHAR2
      ,dbid  in out  VARCHAR2
      ,db_auth  in out  VARCHAR2
      ,description  in out  VARCHAR2
      ,ts_null_override  in out  VARCHAR2
      ,ts_onln_data  in out  VARCHAR2
      ,ts_onln_indx  in out  VARCHAR2
      ,ts_hist_data  in out  VARCHAR2
      ,ts_hist_indx  in out  VARCHAR2
      ,usr_datatype  in out  VARCHAR2
      ,usr_frgn_key  in out  VARCHAR2
      ,copyright  in out  VARCHAR2
      )
is
begin
   -- Fold the case, as needed
   if glob.get_fold_strings
   then
      abbr := upper(abbr);
      name := initcap(name);
      db_schema := upper(db_schema);
      db_schema_exp := upper(db_schema_exp);
      apex_schema := upper(apex_schema);
      apex_ws_name := upper(apex_ws_name);
      ts_null_override := upper(ts_null_override);
      ts_onln_data := lower(ts_onln_data);
      ts_onln_indx := lower(ts_onln_indx);
      ts_hist_data := lower(ts_hist_data);
      ts_hist_indx := lower(ts_hist_indx);
      usr_datatype := upper(usr_datatype);
      usr_frgn_key := lower(usr_frgn_key);
   else
      if abbr != upper(abbr)
      then
         raise_application_error(-20003, 'applications_tab.check_rec(): abbr must be upper case.');
      end if;
      if name != initcap(name)
      then
         raise_application_error(-20003, 'applications_tab.check_rec(): name must be initial case.');
      end if;
      if db_schema != upper(db_schema)
      then
         raise_application_error(-20003, 'applications_tab.check_rec(): db_schema must be upper case.');
      end if;
      if db_schema_exp != upper(db_schema_exp)
      then
         raise_application_error(-20003, 'applications_tab.check_rec(): db_schema_exp must be upper case.');
      end if;
      if apex_schema != upper(apex_schema)
      then
         raise_application_error(-20003, 'applications_tab.check_rec(): apex_schema must be upper case.');
      end if;
      if apex_ws_name != upper(apex_ws_name)
      then
         raise_application_error(-20003, 'applications_tab.check_rec(): apex_ws_name must be upper case.');
      end if;
      if ts_null_override != upper(ts_null_override)
      then
         raise_application_error(-20003, 'applications_tab.check_rec(): ts_null_override must be upper case.');
      end if;
      if ts_onln_data != lower(ts_onln_data)
      then
         raise_application_error(-20003, 'applications_tab.check_rec(): ts_onln_data must be lower case.');
      end if;
      if ts_onln_indx != lower(ts_onln_indx)
      then
         raise_application_error(-20003, 'applications_tab.check_rec(): ts_onln_indx must be lower case.');
      end if;
      if ts_hist_data != lower(ts_hist_data)
      then
         raise_application_error(-20003, 'applications_tab.check_rec(): ts_hist_data must be lower case.');
      end if;
      if ts_hist_indx != lower(ts_hist_indx)
      then
         raise_application_error(-20003, 'applications_tab.check_rec(): ts_hist_indx must be lower case.');
      end if;
      if usr_datatype != upper(usr_datatype)
      then
         raise_application_error(-20003, 'applications_tab.check_rec(): usr_datatype must be upper case.');
      end if;
      if usr_frgn_key != lower(usr_frgn_key)
      then
         raise_application_error(-20003, 'applications_tab.check_rec(): usr_frgn_key must be lower case.');
      end if;
   end if;
   --  Check for NOT NULL
   if abbr is null
   then
      raise_application_error(-20004, 'applications_tab.check_rec(): abbr cannot be null.');
   end if;
   if name is null
   then
      raise_application_error(-20004, 'applications_tab.check_rec(): name cannot be null.');
   end if;
   -- Check for Domain Values
   if db_schema_exp not in ('X')
   then
      raise_application_error(-20005, 'applications_tab.check_rec(): db_schema_exp must be one of ("X").');
   end if;
   if ts_null_override not in ('X')
   then
      raise_application_error(-20005, 'applications_tab.check_rec(): ts_null_override must be one of ("X").');
   end if;
   -- Custom Constraint Checks
   if not (instr(db_schema,' ') = 0)
   then
      raise_application_error(-20006, 'applications_tab.check_rec(): DB schema name cannot have spaces');
   end if;
   if not (instr(apex_schema,' ') = 0)
   then
      raise_application_error(-20006, 'applications_tab.check_rec(): APEX schema name cannot have spaces');
   end if;
   if not (instr(dbid,' ') = 0)
   then
      raise_application_error(-20006, 'applications_tab.check_rec(): Database ID cannot have spaces');
   end if;
   if not (db_auth is null or dbid is not null)
   then
      raise_application_error(-20006, 'applications_tab.check_rec(): Database ID must not be NULL if Database Authentication is not NULL');
   end if;
   if not (db_schema_exp is null or db_schema is not null)
   then
      raise_application_error(-20006, 'applications_tab.check_rec(): Database Schema Name must not be NULL if Database Schema Explicit Flag is not NULL');
   end if;
   --  Set eff_beg_dtm, if needed
end check_rec;
----------------------------------------
procedure ins
      (n_id  in out  NUMBER
      ,n_abbr  in out  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,n_db_schema  in out  VARCHAR2
      ,n_db_schema_exp  in out  VARCHAR2
      ,n_apex_schema  in out  VARCHAR2
      ,n_apex_ws_name  in out  VARCHAR2
      ,n_apex_app_name  in out  VARCHAR2
      ,n_dbid  in out  VARCHAR2
      ,n_db_auth  in out  VARCHAR2
      ,n_description  in out  VARCHAR2
      ,n_ts_null_override  in out  VARCHAR2
      ,n_ts_onln_data  in out  VARCHAR2
      ,n_ts_onln_indx  in out  VARCHAR2
      ,n_ts_hist_data  in out  VARCHAR2
      ,n_ts_hist_indx  in out  VARCHAR2
      ,n_usr_datatype  in out  VARCHAR2
      ,n_usr_frgn_key  in out  VARCHAR2
      ,n_copyright  in out  VARCHAR2
      )
is
begin
   -- Set n_id, if needed
   if n_id is null
   then
      select applications_seq.nextval
       into  n_id
       from  dual;
   end if;
   check_rec (n_id
             ,n_abbr
             ,n_name
             ,n_db_schema
             ,n_db_schema_exp
             ,n_apex_schema
             ,n_apex_ws_name
             ,n_apex_app_name
             ,n_dbid
             ,n_db_auth
             ,n_description
             ,n_ts_null_override
             ,n_ts_onln_data
             ,n_ts_onln_indx
             ,n_ts_hist_data
             ,n_ts_hist_indx
             ,n_usr_datatype
             ,n_usr_frgn_key
             ,n_copyright
             );
end ins;
----------------------------------------
procedure upd
      (o_id  in  NUMBER
      ,o_abbr  in      VARCHAR2
      ,n_abbr  in out  VARCHAR2
      ,o_name  in      VARCHAR2
      ,n_name  in out  VARCHAR2
      ,o_db_schema  in      VARCHAR2
      ,n_db_schema  in out  VARCHAR2
      ,o_db_schema_exp  in      VARCHAR2
      ,n_db_schema_exp  in out  VARCHAR2
      ,o_apex_schema  in      VARCHAR2
      ,n_apex_schema  in out  VARCHAR2
      ,o_apex_ws_name  in      VARCHAR2
      ,n_apex_ws_name  in out  VARCHAR2
      ,o_apex_app_name  in      VARCHAR2
      ,n_apex_app_name  in out  VARCHAR2
      ,o_dbid  in      VARCHAR2
      ,n_dbid  in out  VARCHAR2
      ,o_db_auth  in      VARCHAR2
      ,n_db_auth  in out  VARCHAR2
      ,o_description  in      VARCHAR2
      ,n_description  in out  VARCHAR2
      ,o_ts_null_override  in      VARCHAR2
      ,n_ts_null_override  in out  VARCHAR2
      ,o_ts_onln_data  in      VARCHAR2
      ,n_ts_onln_data  in out  VARCHAR2
      ,o_ts_onln_indx  in      VARCHAR2
      ,n_ts_onln_indx  in out  VARCHAR2
      ,o_ts_hist_data  in      VARCHAR2
      ,n_ts_hist_data  in out  VARCHAR2
      ,o_ts_hist_indx  in      VARCHAR2
      ,n_ts_hist_indx  in out  VARCHAR2
      ,o_usr_datatype  in      VARCHAR2
      ,n_usr_datatype  in out  VARCHAR2
      ,o_usr_frgn_key  in      VARCHAR2
      ,n_usr_frgn_key  in out  VARCHAR2
      ,o_copyright  in      VARCHAR2
      ,n_copyright  in out  VARCHAR2
      )
is
begin
   if     o_abbr = n_abbr
      and o_name = n_name
      and util.is_equal(o_db_schema, n_db_schema)
      and util.is_equal(o_db_schema_exp, n_db_schema_exp)
      and util.is_equal(o_apex_schema, n_apex_schema)
      and util.is_equal(o_apex_ws_name, n_apex_ws_name)
      and util.is_equal(o_apex_app_name, n_apex_app_name)
      and util.is_equal(o_dbid, n_dbid)
      and util.is_equal(o_db_auth, n_db_auth)
      and util.is_equal(o_description, n_description)
      and util.is_equal(o_ts_null_override, n_ts_null_override)
      and util.is_equal(o_ts_onln_data, n_ts_onln_data)
      and util.is_equal(o_ts_onln_indx, n_ts_onln_indx)
      and util.is_equal(o_ts_hist_data, n_ts_hist_data)
      and util.is_equal(o_ts_hist_indx, n_ts_hist_indx)
      and util.is_equal(o_usr_datatype, n_usr_datatype)
      and util.is_equal(o_usr_frgn_key, n_usr_frgn_key)
      and util.is_equal(o_copyright, n_copyright)
   then
      if util.ignore_no_change
      then
         return;
      end if;
      raise_application_error(-20008, 'applications_tab.upd(): Must update one of'
            || ' abbr'
            || ', name'
            || ', db_schema'
            || ', db_schema_exp'
            || ', apex_schema'
            || ', apex_ws_name'
            || ', apex_app_name'
            || ', dbid'
            || ', db_auth'
            || ', description'
            || ', ts_null_override'
            || ', ts_onln_data'
            || ', ts_onln_indx'
            || ', ts_hist_data'
            || ', ts_hist_indx'
            || ', usr_datatype'
            || ', usr_frgn_key'
            || ', copyright'
            || '.');
   end if;
   check_rec (o_id
             ,n_abbr
             ,n_name
             ,n_db_schema
             ,n_db_schema_exp
             ,n_apex_schema
             ,n_apex_ws_name
             ,n_apex_app_name
             ,n_dbid
             ,n_db_auth
             ,n_description
             ,n_ts_null_override
             ,n_ts_onln_data
             ,n_ts_onln_indx
             ,n_ts_hist_data
             ,n_ts_hist_indx
             ,n_usr_datatype
             ,n_usr_frgn_key
             ,n_copyright
             );
end upd;
----------------------------------------
procedure del
      (o_id  in  NUMBER
      ,o_abbr  in  VARCHAR2
      ,o_name  in  VARCHAR2
      ,o_db_schema  in  VARCHAR2
      ,o_db_schema_exp  in  VARCHAR2
      ,o_apex_schema  in  VARCHAR2
      ,o_apex_ws_name  in  VARCHAR2
      ,o_apex_app_name  in  VARCHAR2
      ,o_dbid  in  VARCHAR2
      ,o_db_auth  in  VARCHAR2
      ,o_description  in  VARCHAR2
      ,o_ts_null_override  in  VARCHAR2
      ,o_ts_onln_data  in  VARCHAR2
      ,o_ts_onln_indx  in  VARCHAR2
      ,o_ts_hist_data  in  VARCHAR2
      ,o_ts_hist_indx  in  VARCHAR2
      ,o_usr_datatype  in  VARCHAR2
      ,o_usr_frgn_key  in  VARCHAR2
      ,o_copyright  in  VARCHAR2
      )
is
begin
   return;
end del;
----------------------------------------
end applications_tab;
/
select 'APPLICATIONS_TAB' as "Package Body:"
 from  user_errors
 where name = 'APPLICATIONS_TAB'
  and  type = 'PACKAGE BODY'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'APPLICATIONS_TAB'
  and  type = 'PACKAGE BODY'
 order by sequence;

----------------------------------------
select '***  files  ***' as TABLE_NAME from dual;
----------------------------------------

create package files_tab
is

   -- Package Files_Tab
   --    Table functions
   --    (DML and integrity checks)
   --
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:33:50 PM

   procedure ins
      (n_id  in out  NUMBER
      ,n_application_id  in out  NUMBER
      ,n_name  in out  VARCHAR2
      ,n_type  in out  VARCHAR2
      ,n_created_dt  in out  DATE
      ,n_description  in out  VARCHAR2
      );
   procedure upd
      (o_id  in  NUMBER
      ,o_application_id  in  NUMBER
      ,n_application_id  in out  NUMBER
      ,o_name  in  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,o_type  in  VARCHAR2
      ,n_type  in out  VARCHAR2
      ,o_created_dt  in  DATE
      ,n_created_dt  in out  DATE
      ,o_description  in  VARCHAR2
      ,n_description  in out  VARCHAR2
      );
   procedure del
      (o_id  in  NUMBER
      ,o_application_id  in  NUMBER
      ,o_name  in  VARCHAR2
      ,o_type  in  VARCHAR2
      ,o_created_dt  in  DATE
      ,o_description  in  VARCHAR2
      );
end files_tab;
/
select 'FILES_TAB' as "Package:"
 from  user_errors
 where name = 'FILES_TAB'
  and  type = 'PACKAGE'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'FILES_TAB'
  and  type = 'PACKAGE'
 order by sequence;

create sequence files_seq;

create table files
   (id   NUMBER(38)
   ,application_id   NUMBER(38)
   ,name   VARCHAR2(30)
   ,type   VARCHAR2(3)
   ,created_dt   DATE
   ,description   VARCHAR2(1000)
   );

comment on table files is 'Files for capturing scripts and logs';

comment on column files.id is 'Surrogate Primary Key for these files';
comment on column files.application_id is 'Surrogate Key for the application of this file';
comment on column files.name is 'Name of this file';
comment on column files.type is 'Type for this file';
comment on column files.created_dt is 'Time/Date this file was created';
comment on column files.description is 'Description for this file';

alter table files add constraint files_pk
   primary key (id);

/***  ACTIVE Foreign Keys  ***/
alter table files add constraint files_fk1
   foreign key (application_id) references applications (id);
/***  ACTIVE Audit Foreign Key ***/
-- alter table files add constraint files_fa1
--    foreign key (beg_aud_usr) references sys.usr$ (name);

/***  ACTIVE Indexes  ***/
alter table files add constraint files_nk
    unique (application_id
           ,name
           );
create index files_fx1 on files(application_id);


/***  ACTIVE Audit Foreign Key Indexes  ***/
-- create index files_ia1 on files(aud_beg_usr);
-- create index files_ia2 on files(aud_beg_dtm);

create package body files_tab
is

-- Package Body Files_Tab
--    Table functions
--    (DML and integrity checks)
--
--    Generated by DTGen (http://code.google.com/p/dtgen)
--    July      27, 2012  09:33:50 PM

----------------------------------------
procedure check_rec
      (id  in  NUMBER
      ,application_id  in out  NUMBER
      ,name  in out  VARCHAR2
      ,type  in out  VARCHAR2
      ,created_dt  in out  DATE
      ,description  in out  VARCHAR2
      )
is
begin
   -- Fold the case, as needed
   if glob.get_fold_strings
   then
      type := upper(type);
   else
      if type != upper(type)
      then
         raise_application_error(-20003, 'files_tab.check_rec(): type must be upper case.');
      end if;
   end if;
   --  Check for NOT NULL
   if application_id is null
   then
      raise_application_error(-20004, 'files_tab.check_rec(): application_id cannot be null.');
   end if;
   if name is null
   then
      raise_application_error(-20004, 'files_tab.check_rec(): name cannot be null.');
   end if;
   if type is null
   then
      raise_application_error(-20004, 'files_tab.check_rec(): type cannot be null.');
   end if;
   -- Check for Domain Values
   if type not in ('SQL', 'LOG')
   then
      raise_application_error(-20005, 'files_tab.check_rec(): type must be one of ("SQL", "LOG").');
   end if;
   -- Custom Constraint Checks
   --  Set eff_beg_dtm, if needed
end check_rec;
----------------------------------------
procedure ins
      (n_id  in out  NUMBER
      ,n_application_id  in out  NUMBER
      ,n_name  in out  VARCHAR2
      ,n_type  in out  VARCHAR2
      ,n_created_dt  in out  DATE
      ,n_description  in out  VARCHAR2
      )
is
begin
   -- Set n_id, if needed
   if n_id is null
   then
      select files_seq.nextval
       into  n_id
       from  dual;
   end if;
   check_rec (n_id
             ,n_application_id
             ,n_name
             ,n_type
             ,n_created_dt
             ,n_description
             );
end ins;
----------------------------------------
procedure upd
      (o_id  in  NUMBER
      ,o_application_id  in      NUMBER
      ,n_application_id  in out  NUMBER
      ,o_name  in      VARCHAR2
      ,n_name  in out  VARCHAR2
      ,o_type  in      VARCHAR2
      ,n_type  in out  VARCHAR2
      ,o_created_dt  in      DATE
      ,n_created_dt  in out  DATE
      ,o_description  in      VARCHAR2
      ,n_description  in out  VARCHAR2
      )
is
begin
   if     o_application_id = n_application_id
      and o_name = n_name
      and o_type = n_type
      and util.is_equal(o_created_dt, n_created_dt)
      and util.is_equal(o_description, n_description)
   then
      if util.ignore_no_change
      then
         return;
      end if;
      raise_application_error(-20008, 'files_tab.upd(): Must update one of'
            || ' application_id'
            || ', name'
            || ', type'
            || ', created_dt'
            || ', description'
            || '.');
   end if;
   check_rec (o_id
             ,n_application_id
             ,n_name
             ,n_type
             ,n_created_dt
             ,n_description
             );
end upd;
----------------------------------------
procedure del
      (o_id  in  NUMBER
      ,o_application_id  in  NUMBER
      ,o_name  in  VARCHAR2
      ,o_type  in  VARCHAR2
      ,o_created_dt  in  DATE
      ,o_description  in  VARCHAR2
      )
is
begin
   return;
end del;
----------------------------------------
end files_tab;
/
select 'FILES_TAB' as "Package Body:"
 from  user_errors
 where name = 'FILES_TAB'
  and  type = 'PACKAGE BODY'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'FILES_TAB'
  and  type = 'PACKAGE BODY'
 order by sequence;

----------------------------------------
select '***  file_lines  ***' as TABLE_NAME from dual;
----------------------------------------

create package file_lines_tab
is

   -- Package File_Lines_Tab
   --    Table functions
   --    (DML and integrity checks)
   --
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:33:50 PM

   procedure ins
      (n_id  in out  NUMBER
      ,n_file_id  in out  NUMBER
      ,n_seq  in out  NUMBER
      ,n_value  in out  VARCHAR2
      );
   procedure upd
      (o_id  in  NUMBER
      ,o_file_id  in  NUMBER
      ,n_file_id  in out  NUMBER
      ,o_seq  in  NUMBER
      ,n_seq  in out  NUMBER
      ,o_value  in  VARCHAR2
      ,n_value  in out  VARCHAR2
      );
   procedure del
      (o_id  in  NUMBER
      ,o_file_id  in  NUMBER
      ,o_seq  in  NUMBER
      ,o_value  in  VARCHAR2
      );
end file_lines_tab;
/
select 'FILE_LINES_TAB' as "Package:"
 from  user_errors
 where name = 'FILE_LINES_TAB'
  and  type = 'PACKAGE'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'FILE_LINES_TAB'
  and  type = 'PACKAGE'
 order by sequence;

create sequence file_lines_seq;

create table file_lines
   (id   NUMBER(38)
   ,file_id   NUMBER(38)
   ,seq   NUMBER(9)
   ,value   VARCHAR2(1000)
   );

comment on table file_lines is 'Lines for files';

comment on column file_lines.id is 'Surrogate Primary Key for these file_lines';
comment on column file_lines.file_id is 'Surrogate Key for the file of this line';
comment on column file_lines.seq is 'Sequence number for this line in the file';
comment on column file_lines.value is 'Value or contents of this line in the file';

alter table file_lines add constraint file_lines_pk
   primary key (id);

/***  ACTIVE Foreign Keys  ***/
alter table file_lines add constraint file_lines_fk1
   foreign key (file_id) references files (id);
/***  ACTIVE Audit Foreign Key ***/
-- alter table file_lines add constraint file_lines_fa1
--    foreign key (beg_aud_usr) references sys.usr$ (name);

/***  ACTIVE Indexes  ***/
alter table file_lines add constraint file_lines_nk
    unique (file_id
           ,seq
           );
create index file_lines_fx1 on file_lines(file_id);


/***  ACTIVE Audit Foreign Key Indexes  ***/
-- create index file_lines_ia1 on file_lines(aud_beg_usr);
-- create index file_lines_ia2 on file_lines(aud_beg_dtm);

create package body file_lines_tab
is

-- Package Body File_Lines_Tab
--    Table functions
--    (DML and integrity checks)
--
--    Generated by DTGen (http://code.google.com/p/dtgen)
--    July      27, 2012  09:33:51 PM

----------------------------------------
procedure check_rec
      (id  in  NUMBER
      ,file_id  in out  NUMBER
      ,seq  in out  NUMBER
      ,value  in out  VARCHAR2
      )
is
begin
   -- Fold the case, as needed
   --  Check for NOT NULL
   if file_id is null
   then
      raise_application_error(-20004, 'file_lines_tab.check_rec(): file_id cannot be null.');
   end if;
   if seq is null
   then
      raise_application_error(-20004, 'file_lines_tab.check_rec(): seq cannot be null.');
   end if;
   -- Check for Domain Values
   -- Custom Constraint Checks
   --  Set eff_beg_dtm, if needed
end check_rec;
----------------------------------------
procedure ins
      (n_id  in out  NUMBER
      ,n_file_id  in out  NUMBER
      ,n_seq  in out  NUMBER
      ,n_value  in out  VARCHAR2
      )
is
begin
   -- Set n_id, if needed
   if n_id is null
   then
      select file_lines_seq.nextval
       into  n_id
       from  dual;
   end if;
   check_rec (n_id
             ,n_file_id
             ,n_seq
             ,n_value
             );
end ins;
----------------------------------------
procedure upd
      (o_id  in  NUMBER
      ,o_file_id  in      NUMBER
      ,n_file_id  in out  NUMBER
      ,o_seq  in      NUMBER
      ,n_seq  in out  NUMBER
      ,o_value  in      VARCHAR2
      ,n_value  in out  VARCHAR2
      )
is
begin
   if     o_file_id = n_file_id
      and o_seq = n_seq
      and util.is_equal(o_value, n_value)
   then
      if util.ignore_no_change
      then
         return;
      end if;
      raise_application_error(-20008, 'file_lines_tab.upd(): Must update one of'
            || ' file_id'
            || ', seq'
            || ', value'
            || '.');
   end if;
   check_rec (o_id
             ,n_file_id
             ,n_seq
             ,n_value
             );
end upd;
----------------------------------------
procedure del
      (o_id  in  NUMBER
      ,o_file_id  in  NUMBER
      ,o_seq  in  NUMBER
      ,o_value  in  VARCHAR2
      )
is
begin
   return;
end del;
----------------------------------------
end file_lines_tab;
/
select 'FILE_LINES_TAB' as "Package Body:"
 from  user_errors
 where name = 'FILE_LINES_TAB'
  and  type = 'PACKAGE BODY'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'FILE_LINES_TAB'
  and  type = 'PACKAGE BODY'
 order by sequence;

----------------------------------------
select '***  domains  ***' as TABLE_NAME from dual;
----------------------------------------

create package domains_tab
is

   -- Package Domains_Tab
   --    Table functions
   --    (DML and integrity checks)
   --
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:33:51 PM

   procedure ins
      (n_id  in out  NUMBER
      ,n_application_id  in out  NUMBER
      ,n_abbr  in out  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,n_fold  in out  VARCHAR2
      ,n_len  in out  NUMBER
      ,n_description  in out  VARCHAR2
      );
   procedure upd
      (o_id  in  NUMBER
      ,o_application_id  in  NUMBER
      ,n_application_id  in out  NUMBER
      ,o_abbr  in  VARCHAR2
      ,n_abbr  in out  VARCHAR2
      ,o_name  in  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,o_fold  in  VARCHAR2
      ,n_fold  in out  VARCHAR2
      ,o_len  in  NUMBER
      ,n_len  in out  NUMBER
      ,o_description  in  VARCHAR2
      ,n_description  in out  VARCHAR2
      );
   procedure del
      (o_id  in  NUMBER
      ,o_application_id  in  NUMBER
      ,o_abbr  in  VARCHAR2
      ,o_name  in  VARCHAR2
      ,o_fold  in  VARCHAR2
      ,o_len  in  NUMBER
      ,o_description  in  VARCHAR2
      );
end domains_tab;
/
select 'DOMAINS_TAB' as "Package:"
 from  user_errors
 where name = 'DOMAINS_TAB'
  and  type = 'PACKAGE'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'DOMAINS_TAB'
  and  type = 'PACKAGE'
 order by sequence;

create sequence domains_seq;

create table domains
   (id   NUMBER(38)
   ,application_id   NUMBER(38)
   ,abbr   VARCHAR2(5)
   ,name   VARCHAR2(20)
   ,fold   VARCHAR2(1)
   ,len   NUMBER(2)
   ,description   VARCHAR2(1000)
   );

comment on table domains is 'Data domains to be generated as check constraints and/or lists of values for selected columns';

comment on column domains.id is 'Surrogate Primary Key for these domains';
comment on column domains.application_id is 'Surrogate Key for the application of this data domain';
comment on column domains.abbr is 'Name of this data domain';
comment on column domains.name is 'Name of this data domain';
comment on column domains.fold is 'Value of this sequence in this data domain';
comment on column domains.len is 'Value of this sequence in this data domain';
comment on column domains.description is 'Description of this data domain value';

alter table domains add constraint domains_pk
   primary key (id);

/***  ACTIVE Foreign Keys  ***/
alter table domains add constraint domains_fk1
   foreign key (application_id) references applications (id);
/***  ACTIVE Audit Foreign Key ***/
-- alter table domains add constraint domains_fa1
--    foreign key (beg_aud_usr) references sys.usr$ (name);

/***  ACTIVE Indexes  ***/
alter table domains add constraint domains_nk
    unique (application_id
           ,abbr
           );
alter table domains add constraint domains_ux1
    unique (application_id
           ,name
           );
--  Skipping duplicate FK index on application_id


/***  ACTIVE Audit Foreign Key Indexes  ***/
-- create index domains_ia1 on domains(aud_beg_usr);
-- create index domains_ia2 on domains(aud_beg_dtm);

create package body domains_tab
is

-- Package Body Domains_Tab
--    Table functions
--    (DML and integrity checks)
--
--    Generated by DTGen (http://code.google.com/p/dtgen)
--    July      27, 2012  09:33:51 PM

----------------------------------------
procedure check_rec
      (id  in  NUMBER
      ,application_id  in out  NUMBER
      ,abbr  in out  VARCHAR2
      ,name  in out  VARCHAR2
      ,fold  in out  VARCHAR2
      ,len  in out  NUMBER
      ,description  in out  VARCHAR2
      )
is
begin
   -- Fold the case, as needed
   if glob.get_fold_strings
   then
      abbr := upper(abbr);
      name := initcap(name);
      fold := upper(fold);
   else
      if abbr != upper(abbr)
      then
         raise_application_error(-20003, 'domains_tab.check_rec(): abbr must be upper case.');
      end if;
      if name != initcap(name)
      then
         raise_application_error(-20003, 'domains_tab.check_rec(): name must be initial case.');
      end if;
      if fold != upper(fold)
      then
         raise_application_error(-20003, 'domains_tab.check_rec(): fold must be upper case.');
      end if;
   end if;
   --  Check for NOT NULL
   if application_id is null
   then
      raise_application_error(-20004, 'domains_tab.check_rec(): application_id cannot be null.');
   end if;
   if abbr is null
   then
      raise_application_error(-20004, 'domains_tab.check_rec(): abbr cannot be null.');
   end if;
   if name is null
   then
      raise_application_error(-20004, 'domains_tab.check_rec(): name cannot be null.');
   end if;
   if fold is null
   then
      raise_application_error(-20004, 'domains_tab.check_rec(): fold cannot be null.');
   end if;
   if len is null
   then
      raise_application_error(-20004, 'domains_tab.check_rec(): len cannot be null.');
   end if;
   -- Check for Domain Values
   if fold not in ('U', 'L', 'I')
   then
      raise_application_error(-20005, 'domains_tab.check_rec(): fold must be one of ("U", "L", "I").');
   end if;
   -- Custom Constraint Checks
   if not (len > 0)
   then
      raise_application_error(-20006, 'domains_tab.check_rec(): Domain data value length must be greater than 0');
   end if;
   --  Set eff_beg_dtm, if needed
end check_rec;
----------------------------------------
procedure ins
      (n_id  in out  NUMBER
      ,n_application_id  in out  NUMBER
      ,n_abbr  in out  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,n_fold  in out  VARCHAR2
      ,n_len  in out  NUMBER
      ,n_description  in out  VARCHAR2
      )
is
begin
   -- Set n_id, if needed
   if n_id is null
   then
      select domains_seq.nextval
       into  n_id
       from  dual;
   end if;
   check_rec (n_id
             ,n_application_id
             ,n_abbr
             ,n_name
             ,n_fold
             ,n_len
             ,n_description
             );
end ins;
----------------------------------------
procedure upd
      (o_id  in  NUMBER
      ,o_application_id  in      NUMBER
      ,n_application_id  in out  NUMBER
      ,o_abbr  in      VARCHAR2
      ,n_abbr  in out  VARCHAR2
      ,o_name  in      VARCHAR2
      ,n_name  in out  VARCHAR2
      ,o_fold  in      VARCHAR2
      ,n_fold  in out  VARCHAR2
      ,o_len  in      NUMBER
      ,n_len  in out  NUMBER
      ,o_description  in      VARCHAR2
      ,n_description  in out  VARCHAR2
      )
is
begin
   if     o_application_id = n_application_id
      and o_abbr = n_abbr
      and o_name = n_name
      and o_fold = n_fold
      and o_len = n_len
      and util.is_equal(o_description, n_description)
   then
      if util.ignore_no_change
      then
         return;
      end if;
      raise_application_error(-20008, 'domains_tab.upd(): Must update one of'
            || ' application_id'
            || ', abbr'
            || ', name'
            || ', fold'
            || ', len'
            || ', description'
            || '.');
   end if;
   check_rec (o_id
             ,n_application_id
             ,n_abbr
             ,n_name
             ,n_fold
             ,n_len
             ,n_description
             );
end upd;
----------------------------------------
procedure del
      (o_id  in  NUMBER
      ,o_application_id  in  NUMBER
      ,o_abbr  in  VARCHAR2
      ,o_name  in  VARCHAR2
      ,o_fold  in  VARCHAR2
      ,o_len  in  NUMBER
      ,o_description  in  VARCHAR2
      )
is
begin
   return;
end del;
----------------------------------------
end domains_tab;
/
select 'DOMAINS_TAB' as "Package Body:"
 from  user_errors
 where name = 'DOMAINS_TAB'
  and  type = 'PACKAGE BODY'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'DOMAINS_TAB'
  and  type = 'PACKAGE BODY'
 order by sequence;

----------------------------------------
select '***  domain_values  ***' as TABLE_NAME from dual;
----------------------------------------

create package domain_values_tab
is

   -- Package Domain_Values_Tab
   --    Table functions
   --    (DML and integrity checks)
   --
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:33:51 PM

   procedure ins
      (n_id  in out  NUMBER
      ,n_domain_id  in out  NUMBER
      ,n_seq  in out  NUMBER
      ,n_value  in out  VARCHAR2
      ,n_description  in out  VARCHAR2
      );
   procedure upd
      (o_id  in  NUMBER
      ,o_domain_id  in  NUMBER
      ,n_domain_id  in out  NUMBER
      ,o_seq  in  NUMBER
      ,n_seq  in out  NUMBER
      ,o_value  in  VARCHAR2
      ,n_value  in out  VARCHAR2
      ,o_description  in  VARCHAR2
      ,n_description  in out  VARCHAR2
      );
   procedure del
      (o_id  in  NUMBER
      ,o_domain_id  in  NUMBER
      ,o_seq  in  NUMBER
      ,o_value  in  VARCHAR2
      ,o_description  in  VARCHAR2
      );
end domain_values_tab;
/
select 'DOMAIN_VALUES_TAB' as "Package:"
 from  user_errors
 where name = 'DOMAIN_VALUES_TAB'
  and  type = 'PACKAGE'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'DOMAIN_VALUES_TAB'
  and  type = 'PACKAGE'
 order by sequence;

create sequence domain_values_seq;

create table domain_values
   (id   NUMBER(38)
   ,domain_id   NUMBER(38)
   ,seq   NUMBER(2)
   ,value   VARCHAR2(100)
   ,description   VARCHAR2(1000)
   );

comment on table domain_values is 'Data domains values for the data domains';

comment on column domain_values.id is 'Surrogate Primary Key for these domain_values';
comment on column domain_values.domain_id is 'Surrogate Key for the application of this data domain';
comment on column domain_values.seq is 'Sequence number for this value in this data domain';
comment on column domain_values.value is 'Value of this sequence in this data domain';
comment on column domain_values.description is 'Description of this data domain value';

alter table domain_values add constraint domain_values_pk
   primary key (id);

/***  ACTIVE Foreign Keys  ***/
alter table domain_values add constraint domain_values_fk1
   foreign key (domain_id) references domains (id);
/***  ACTIVE Audit Foreign Key ***/
-- alter table domain_values add constraint domain_values_fa1
--    foreign key (beg_aud_usr) references sys.usr$ (name);

/***  ACTIVE Indexes  ***/
alter table domain_values add constraint domain_values_nk
    unique (domain_id
           ,value
           );
alter table domain_values add constraint domain_values_ux1
    unique (domain_id
           ,seq
           );
--  Skipping duplicate FK index on domain_id


/***  ACTIVE Audit Foreign Key Indexes  ***/
-- create index domain_values_ia1 on domain_values(aud_beg_usr);
-- create index domain_values_ia2 on domain_values(aud_beg_dtm);

create package body domain_values_tab
is

-- Package Body Domain_Values_Tab
--    Table functions
--    (DML and integrity checks)
--
--    Generated by DTGen (http://code.google.com/p/dtgen)
--    July      27, 2012  09:33:51 PM

----------------------------------------
procedure check_rec
      (id  in  NUMBER
      ,domain_id  in out  NUMBER
      ,seq  in out  NUMBER
      ,value  in out  VARCHAR2
      ,description  in out  VARCHAR2
      )
is
begin
   -- Fold the case, as needed
   --  Check for NOT NULL
   if domain_id is null
   then
      raise_application_error(-20004, 'domain_values_tab.check_rec(): domain_id cannot be null.');
   end if;
   if seq is null
   then
      raise_application_error(-20004, 'domain_values_tab.check_rec(): seq cannot be null.');
   end if;
   if value is null
   then
      raise_application_error(-20004, 'domain_values_tab.check_rec(): value cannot be null.');
   end if;
   -- Check for Domain Values
   -- Custom Constraint Checks
   if not (seq > 0)
   then
      raise_application_error(-20006, 'domain_values_tab.check_rec(): Domain data value sequence number must be greater than 0');
   end if;
   --  Set eff_beg_dtm, if needed
end check_rec;
----------------------------------------
procedure ins
      (n_id  in out  NUMBER
      ,n_domain_id  in out  NUMBER
      ,n_seq  in out  NUMBER
      ,n_value  in out  VARCHAR2
      ,n_description  in out  VARCHAR2
      )
is
begin
   -- Set n_id, if needed
   if n_id is null
   then
      select domain_values_seq.nextval
       into  n_id
       from  dual;
   end if;
   check_rec (n_id
             ,n_domain_id
             ,n_seq
             ,n_value
             ,n_description
             );
end ins;
----------------------------------------
procedure upd
      (o_id  in  NUMBER
      ,o_domain_id  in      NUMBER
      ,n_domain_id  in out  NUMBER
      ,o_seq  in      NUMBER
      ,n_seq  in out  NUMBER
      ,o_value  in      VARCHAR2
      ,n_value  in out  VARCHAR2
      ,o_description  in      VARCHAR2
      ,n_description  in out  VARCHAR2
      )
is
begin
   if     o_domain_id = n_domain_id
      and o_seq = n_seq
      and o_value = n_value
      and util.is_equal(o_description, n_description)
   then
      if util.ignore_no_change
      then
         return;
      end if;
      raise_application_error(-20008, 'domain_values_tab.upd(): Must update one of'
            || ' domain_id'
            || ', seq'
            || ', value'
            || ', description'
            || '.');
   end if;
   check_rec (o_id
             ,n_domain_id
             ,n_seq
             ,n_value
             ,n_description
             );
end upd;
----------------------------------------
procedure del
      (o_id  in  NUMBER
      ,o_domain_id  in  NUMBER
      ,o_seq  in  NUMBER
      ,o_value  in  VARCHAR2
      ,o_description  in  VARCHAR2
      )
is
begin
   return;
end del;
----------------------------------------
end domain_values_tab;
/
select 'DOMAIN_VALUES_TAB' as "Package Body:"
 from  user_errors
 where name = 'DOMAIN_VALUES_TAB'
  and  type = 'PACKAGE BODY'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'DOMAIN_VALUES_TAB'
  and  type = 'PACKAGE BODY'
 order by sequence;

----------------------------------------
select '***  tables  ***' as TABLE_NAME from dual;
----------------------------------------

create package tables_tab
is

   -- Package Tables_Tab
   --    Table functions
   --    (DML and integrity checks)
   --
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:33:52 PM

   procedure ins
      (n_id  in out  NUMBER
      ,n_application_id  in out  NUMBER
      ,n_abbr  in out  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,n_seq  in out  NUMBER
      ,n_type  in out  VARCHAR2
      ,n_group_name  in out  VARCHAR2
      ,n_mv_refresh_hr  in out  NUMBER
      ,n_ts_onln_data  in out  VARCHAR2
      ,n_ts_onln_indx  in out  VARCHAR2
      ,n_ts_hist_data  in out  VARCHAR2
      ,n_ts_hist_indx  in out  VARCHAR2
      ,n_description  in out  VARCHAR2
      );
   procedure upd
      (o_id  in  NUMBER
      ,o_application_id  in  NUMBER
      ,n_application_id  in out  NUMBER
      ,o_abbr  in  VARCHAR2
      ,n_abbr  in out  VARCHAR2
      ,o_name  in  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,o_seq  in  NUMBER
      ,n_seq  in out  NUMBER
      ,o_type  in  VARCHAR2
      ,n_type  in out  VARCHAR2
      ,o_group_name  in  VARCHAR2
      ,n_group_name  in out  VARCHAR2
      ,o_mv_refresh_hr  in  NUMBER
      ,n_mv_refresh_hr  in out  NUMBER
      ,o_ts_onln_data  in  VARCHAR2
      ,n_ts_onln_data  in out  VARCHAR2
      ,o_ts_onln_indx  in  VARCHAR2
      ,n_ts_onln_indx  in out  VARCHAR2
      ,o_ts_hist_data  in  VARCHAR2
      ,n_ts_hist_data  in out  VARCHAR2
      ,o_ts_hist_indx  in  VARCHAR2
      ,n_ts_hist_indx  in out  VARCHAR2
      ,o_description  in  VARCHAR2
      ,n_description  in out  VARCHAR2
      );
   procedure del
      (o_id  in  NUMBER
      ,o_application_id  in  NUMBER
      ,o_abbr  in  VARCHAR2
      ,o_name  in  VARCHAR2
      ,o_seq  in  NUMBER
      ,o_type  in  VARCHAR2
      ,o_group_name  in  VARCHAR2
      ,o_mv_refresh_hr  in  NUMBER
      ,o_ts_onln_data  in  VARCHAR2
      ,o_ts_onln_indx  in  VARCHAR2
      ,o_ts_hist_data  in  VARCHAR2
      ,o_ts_hist_indx  in  VARCHAR2
      ,o_description  in  VARCHAR2
      );
end tables_tab;
/
select 'TABLES_TAB' as "Package:"
 from  user_errors
 where name = 'TABLES_TAB'
  and  type = 'PACKAGE'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'TABLES_TAB'
  and  type = 'PACKAGE'
 order by sequence;

create sequence tables_seq;

create table tables
   (id   NUMBER(38)
   ,application_id   NUMBER(38)
   ,abbr   VARCHAR2(5)
   ,name   VARCHAR2(15)
   ,seq   NUMBER(2)
   ,type   VARCHAR2(3)
   ,group_name   VARCHAR2(30)
   ,mv_refresh_hr   NUMBER(3,1)
   ,ts_onln_data   VARCHAR2(30)
   ,ts_onln_indx   VARCHAR2(30)
   ,ts_hist_data   VARCHAR2(30)
   ,ts_hist_indx   VARCHAR2(30)
   ,description   VARCHAR2(1000)
   );

comment on table tables is 'Tables to be generated for each application';

comment on column tables.id is 'Surrogate Primary Key for these tables';
comment on column tables.application_id is 'Surrogate Key for the application of this table';
comment on column tables.abbr is 'Abbreviation for this table';
comment on column tables.name is 'Name of this table';
comment on column tables.seq is 'Report order for this table';
comment on column tables.type is 'Type of this table';
comment on column tables.group_name is 'Group Name for this table.';
comment on column tables.mv_refresh_hr is 'Number of Hours between Materialized View Refresh';
comment on column tables.ts_onln_data is 'Tablespace name for the on-line data for this table';
comment on column tables.ts_onln_indx is 'Tablespace name for the on-line indexes for this table';
comment on column tables.ts_hist_data is 'Tablespace name for the history data for this table';
comment on column tables.ts_hist_indx is 'Tablespace name for the history indexes for this table';
comment on column tables.description is 'Description of this table';

alter table tables add constraint tables_pk
   primary key (id);

/***  ACTIVE Foreign Keys  ***/
alter table tables add constraint tables_fk1
   foreign key (application_id) references applications (id);
/***  ACTIVE Audit Foreign Key ***/
-- alter table tables add constraint tables_fa1
--    foreign key (beg_aud_usr) references sys.usr$ (name);

/***  ACTIVE Indexes  ***/
alter table tables add constraint tables_nk
    unique (application_id
           ,abbr
           );
alter table tables add constraint tables_ux1
    unique (application_id
           ,name
           );
alter table tables add constraint tables_ux2
    unique (application_id
           ,seq
           );
--  Skipping duplicate FK index on application_id


/***  ACTIVE Audit Foreign Key Indexes  ***/
-- create index tables_ia1 on tables(aud_beg_usr);
-- create index tables_ia2 on tables(aud_beg_dtm);

create package body tables_tab
is

-- Package Body Tables_Tab
--    Table functions
--    (DML and integrity checks)
--
--    Generated by DTGen (http://code.google.com/p/dtgen)
--    July      27, 2012  09:33:52 PM

----------------------------------------
procedure check_rec
      (id  in  NUMBER
      ,application_id  in out  NUMBER
      ,abbr  in out  VARCHAR2
      ,name  in out  VARCHAR2
      ,seq  in out  NUMBER
      ,type  in out  VARCHAR2
      ,group_name  in out  VARCHAR2
      ,mv_refresh_hr  in out  NUMBER
      ,ts_onln_data  in out  VARCHAR2
      ,ts_onln_indx  in out  VARCHAR2
      ,ts_hist_data  in out  VARCHAR2
      ,ts_hist_indx  in out  VARCHAR2
      ,description  in out  VARCHAR2
      )
is
begin
   -- Fold the case, as needed
   if glob.get_fold_strings
   then
      abbr := upper(abbr);
      name := lower(name);
      type := upper(type);
      group_name := upper(group_name);
      ts_onln_data := lower(ts_onln_data);
      ts_onln_indx := lower(ts_onln_indx);
      ts_hist_data := lower(ts_hist_data);
      ts_hist_indx := lower(ts_hist_indx);
   else
      if abbr != upper(abbr)
      then
         raise_application_error(-20003, 'tables_tab.check_rec(): abbr must be upper case.');
      end if;
      if name != lower(name)
      then
         raise_application_error(-20003, 'tables_tab.check_rec(): name must be lower case.');
      end if;
      if type != upper(type)
      then
         raise_application_error(-20003, 'tables_tab.check_rec(): type must be upper case.');
      end if;
      if group_name != upper(group_name)
      then
         raise_application_error(-20003, 'tables_tab.check_rec(): group_name must be upper case.');
      end if;
      if ts_onln_data != lower(ts_onln_data)
      then
         raise_application_error(-20003, 'tables_tab.check_rec(): ts_onln_data must be lower case.');
      end if;
      if ts_onln_indx != lower(ts_onln_indx)
      then
         raise_application_error(-20003, 'tables_tab.check_rec(): ts_onln_indx must be lower case.');
      end if;
      if ts_hist_data != lower(ts_hist_data)
      then
         raise_application_error(-20003, 'tables_tab.check_rec(): ts_hist_data must be lower case.');
      end if;
      if ts_hist_indx != lower(ts_hist_indx)
      then
         raise_application_error(-20003, 'tables_tab.check_rec(): ts_hist_indx must be lower case.');
      end if;
   end if;
   --  Check for NOT NULL
   if application_id is null
   then
      raise_application_error(-20004, 'tables_tab.check_rec(): application_id cannot be null.');
   end if;
   if abbr is null
   then
      raise_application_error(-20004, 'tables_tab.check_rec(): abbr cannot be null.');
   end if;
   if name is null
   then
      raise_application_error(-20004, 'tables_tab.check_rec(): name cannot be null.');
   end if;
   if seq is null
   then
      raise_application_error(-20004, 'tables_tab.check_rec(): seq cannot be null.');
   end if;
   if type is null
   then
      raise_application_error(-20004, 'tables_tab.check_rec(): type cannot be null.');
   end if;
   -- Check for Domain Values
   if type not in ('EFF', 'LOG', 'NON')
   then
      raise_application_error(-20005, 'tables_tab.check_rec(): type must be one of ("EFF", "LOG", "NON").');
   end if;
   -- Custom Constraint Checks
   if not (instr(abbr,' ') = 0)
   then
      raise_application_error(-20006, 'tables_tab.check_rec(): Table abbreviation cannot have spaces');
   end if;
   if not (instr(name,' ') = 0)
   then
      raise_application_error(-20006, 'tables_tab.check_rec(): Table name cannot have spaces');
   end if;
   if not (seq > 0)
   then
      raise_application_error(-20006, 'tables_tab.check_rec(): Table sequence number must be greater than 0');
   end if;
   if not (seq < 200)
   then
      raise_application_error(-20006, 'tables_tab.check_rec(): Table sequence number must be less than 200 because of the pnum offsets in the generator package');
   end if;
   if not (mv_refresh_hr > 0)
   then
      raise_application_error(-20006, 'tables_tab.check_rec(): Materialized View Refresh Hours must be greater than 0');
   end if;
   if not (instr(ts_onln_data,' ') = 0)
   then
      raise_application_error(-20006, 'tables_tab.check_rec(): On-line data table space name cannot have spaces for a table');
   end if;
   if not (instr(ts_onln_indx,' ') = 0)
   then
      raise_application_error(-20006, 'tables_tab.check_rec(): On-line index table space name cannot have spaces for a table');
   end if;
   if not (instr(ts_hist_data,' ') = 0)
   then
      raise_application_error(-20006, 'tables_tab.check_rec(): History data table space name cannot have spaces for a table');
   end if;
   if not (instr(ts_hist_indx,' ') = 0)
   then
      raise_application_error(-20006, 'tables_tab.check_rec(): History index table space name cannot have spaces for a table');
   end if;
   --  Set eff_beg_dtm, if needed
end check_rec;
----------------------------------------
procedure ins
      (n_id  in out  NUMBER
      ,n_application_id  in out  NUMBER
      ,n_abbr  in out  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,n_seq  in out  NUMBER
      ,n_type  in out  VARCHAR2
      ,n_group_name  in out  VARCHAR2
      ,n_mv_refresh_hr  in out  NUMBER
      ,n_ts_onln_data  in out  VARCHAR2
      ,n_ts_onln_indx  in out  VARCHAR2
      ,n_ts_hist_data  in out  VARCHAR2
      ,n_ts_hist_indx  in out  VARCHAR2
      ,n_description  in out  VARCHAR2
      )
is
begin
   -- Set n_id, if needed
   if n_id is null
   then
      select tables_seq.nextval
       into  n_id
       from  dual;
   end if;
   check_rec (n_id
             ,n_application_id
             ,n_abbr
             ,n_name
             ,n_seq
             ,n_type
             ,n_group_name
             ,n_mv_refresh_hr
             ,n_ts_onln_data
             ,n_ts_onln_indx
             ,n_ts_hist_data
             ,n_ts_hist_indx
             ,n_description
             );
end ins;
----------------------------------------
procedure upd
      (o_id  in  NUMBER
      ,o_application_id  in      NUMBER
      ,n_application_id  in out  NUMBER
      ,o_abbr  in      VARCHAR2
      ,n_abbr  in out  VARCHAR2
      ,o_name  in      VARCHAR2
      ,n_name  in out  VARCHAR2
      ,o_seq  in      NUMBER
      ,n_seq  in out  NUMBER
      ,o_type  in      VARCHAR2
      ,n_type  in out  VARCHAR2
      ,o_group_name  in      VARCHAR2
      ,n_group_name  in out  VARCHAR2
      ,o_mv_refresh_hr  in      NUMBER
      ,n_mv_refresh_hr  in out  NUMBER
      ,o_ts_onln_data  in      VARCHAR2
      ,n_ts_onln_data  in out  VARCHAR2
      ,o_ts_onln_indx  in      VARCHAR2
      ,n_ts_onln_indx  in out  VARCHAR2
      ,o_ts_hist_data  in      VARCHAR2
      ,n_ts_hist_data  in out  VARCHAR2
      ,o_ts_hist_indx  in      VARCHAR2
      ,n_ts_hist_indx  in out  VARCHAR2
      ,o_description  in      VARCHAR2
      ,n_description  in out  VARCHAR2
      )
is
begin
   if     o_application_id = n_application_id
      and o_abbr = n_abbr
      and o_name = n_name
      and o_seq = n_seq
      and o_type = n_type
      and util.is_equal(o_group_name, n_group_name)
      and util.is_equal(o_mv_refresh_hr, n_mv_refresh_hr)
      and util.is_equal(o_ts_onln_data, n_ts_onln_data)
      and util.is_equal(o_ts_onln_indx, n_ts_onln_indx)
      and util.is_equal(o_ts_hist_data, n_ts_hist_data)
      and util.is_equal(o_ts_hist_indx, n_ts_hist_indx)
      and util.is_equal(o_description, n_description)
   then
      if util.ignore_no_change
      then
         return;
      end if;
      raise_application_error(-20008, 'tables_tab.upd(): Must update one of'
            || ' application_id'
            || ', abbr'
            || ', name'
            || ', seq'
            || ', type'
            || ', group_name'
            || ', mv_refresh_hr'
            || ', ts_onln_data'
            || ', ts_onln_indx'
            || ', ts_hist_data'
            || ', ts_hist_indx'
            || ', description'
            || '.');
   end if;
   check_rec (o_id
             ,n_application_id
             ,n_abbr
             ,n_name
             ,n_seq
             ,n_type
             ,n_group_name
             ,n_mv_refresh_hr
             ,n_ts_onln_data
             ,n_ts_onln_indx
             ,n_ts_hist_data
             ,n_ts_hist_indx
             ,n_description
             );
end upd;
----------------------------------------
procedure del
      (o_id  in  NUMBER
      ,o_application_id  in  NUMBER
      ,o_abbr  in  VARCHAR2
      ,o_name  in  VARCHAR2
      ,o_seq  in  NUMBER
      ,o_type  in  VARCHAR2
      ,o_group_name  in  VARCHAR2
      ,o_mv_refresh_hr  in  NUMBER
      ,o_ts_onln_data  in  VARCHAR2
      ,o_ts_onln_indx  in  VARCHAR2
      ,o_ts_hist_data  in  VARCHAR2
      ,o_ts_hist_indx  in  VARCHAR2
      ,o_description  in  VARCHAR2
      )
is
begin
   return;
end del;
----------------------------------------
end tables_tab;
/
select 'TABLES_TAB' as "Package Body:"
 from  user_errors
 where name = 'TABLES_TAB'
  and  type = 'PACKAGE BODY'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'TABLES_TAB'
  and  type = 'PACKAGE BODY'
 order by sequence;

----------------------------------------
select '***  tab_cols  ***' as TABLE_NAME from dual;
----------------------------------------

create package tab_cols_tab
is

   -- Package Tab_Cols_Tab
   --    Table functions
   --    (DML and integrity checks)
   --
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:33:52 PM

   procedure ins
      (n_id  in out  NUMBER
      ,n_table_id  in out  NUMBER
      ,n_name  in out  VARCHAR2
      ,n_seq  in out  NUMBER
      ,n_nk  in out  NUMBER
      ,n_req  in out  VARCHAR2
      ,n_fk_prefix  in out  VARCHAR2
      ,n_fk_table_id  in out  NUMBER
      ,n_d_domain_id  in out  NUMBER
      ,n_type  in out  VARCHAR2
      ,n_len  in out  NUMBER
      ,n_scale  in out  NUMBER
      ,n_fold  in out  VARCHAR2
      ,n_default_value  in out  VARCHAR2
      ,n_upd_res_pct  in out  NUMBER
      ,n_description  in out  VARCHAR2
      );
   procedure upd
      (o_id  in  NUMBER
      ,o_table_id  in  NUMBER
      ,n_table_id  in out  NUMBER
      ,o_name  in  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,o_seq  in  NUMBER
      ,n_seq  in out  NUMBER
      ,o_nk  in  NUMBER
      ,n_nk  in out  NUMBER
      ,o_req  in  VARCHAR2
      ,n_req  in out  VARCHAR2
      ,o_fk_prefix  in  VARCHAR2
      ,n_fk_prefix  in out  VARCHAR2
      ,o_fk_table_id  in  NUMBER
      ,n_fk_table_id  in out  NUMBER
      ,o_d_domain_id  in  NUMBER
      ,n_d_domain_id  in out  NUMBER
      ,o_type  in  VARCHAR2
      ,n_type  in out  VARCHAR2
      ,o_len  in  NUMBER
      ,n_len  in out  NUMBER
      ,o_scale  in  NUMBER
      ,n_scale  in out  NUMBER
      ,o_fold  in  VARCHAR2
      ,n_fold  in out  VARCHAR2
      ,o_default_value  in  VARCHAR2
      ,n_default_value  in out  VARCHAR2
      ,o_upd_res_pct  in  NUMBER
      ,n_upd_res_pct  in out  NUMBER
      ,o_description  in  VARCHAR2
      ,n_description  in out  VARCHAR2
      );
   procedure del
      (o_id  in  NUMBER
      ,o_table_id  in  NUMBER
      ,o_name  in  VARCHAR2
      ,o_seq  in  NUMBER
      ,o_nk  in  NUMBER
      ,o_req  in  VARCHAR2
      ,o_fk_prefix  in  VARCHAR2
      ,o_fk_table_id  in  NUMBER
      ,o_d_domain_id  in  NUMBER
      ,o_type  in  VARCHAR2
      ,o_len  in  NUMBER
      ,o_scale  in  NUMBER
      ,o_fold  in  VARCHAR2
      ,o_default_value  in  VARCHAR2
      ,o_upd_res_pct  in  NUMBER
      ,o_description  in  VARCHAR2
      );
end tab_cols_tab;
/
select 'TAB_COLS_TAB' as "Package:"
 from  user_errors
 where name = 'TAB_COLS_TAB'
  and  type = 'PACKAGE'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'TAB_COLS_TAB'
  and  type = 'PACKAGE'
 order by sequence;

create sequence tab_cols_seq;

create table tab_cols
   (id   NUMBER(38)
   ,table_id   NUMBER(38)
   ,name   VARCHAR2(25)
   ,seq   NUMBER(2)
   ,nk   NUMBER(1)
   ,req   VARCHAR2(1)
   ,fk_prefix   VARCHAR2(4)
   ,fk_table_id   NUMBER(38)
   ,d_domain_id   NUMBER(38)
   ,type   VARCHAR2(30)
   ,len   NUMBER(5)
   ,scale   NUMBER(3)
   ,fold   VARCHAR2(1)
   ,default_value   VARCHAR2(1000)
   ,upd_res_pct   NUMBER(2,0)
   ,description   VARCHAR2(1000)
   );

comment on table tab_cols is 'Columns to be generated for each table';

comment on column tab_cols.id is 'Surrogate Primary Key for these tab_cols';
comment on column tab_cols.table_id is 'Surrogate Key for the table of this column';
comment on column tab_cols.name is 'Name of this column';
comment on column tab_cols.seq is 'Sequence number for this column';
comment on column tab_cols.nk is 'Natural key sequence number for this column.  Implies this column requires data (not null).';
comment on column tab_cols.req is 'Flag to indicate if this column is required';
comment on column tab_cols.fk_prefix is 'Foreign key prefix for multiple foreign keys to the same table';
comment on column tab_cols.fk_table_id is 'Surrogate Key for the foreign key table of this column';
comment on column tab_cols.d_domain_id is 'Surrogate Key for the domain of this column';
comment on column tab_cols.type is 'Type for this column';
comment on column tab_cols.len is 'The total number of significant decimal digits in a number, or the length of a string, or the number of digits for fractional seconds in a timestamp';
comment on column tab_cols.scale is 'The number of digits from the decimal point to the least significant digit';
comment on column tab_cols.fold is 'Flag to indicate if this column should be character case folded';
comment on column tab_cols.default_value is 'Default Value if no value is provided for this column';
comment on column tab_cols.upd_res_pct is 'Percentage of column space reserved for data updates';
comment on column tab_cols.description is 'Description for this column';

alter table tab_cols add constraint tab_cols_pk
   primary key (id);

/***  ACTIVE Foreign Keys  ***/
alter table tab_cols add constraint tab_cols_fk1
   foreign key (table_id) references tables (id);
alter table tab_cols add constraint tab_cols_fk2
   foreign key (fk_table_id) references tables (id);
alter table tab_cols add constraint tab_cols_fk3
   foreign key (d_domain_id) references domains (id);
/***  ACTIVE Audit Foreign Key ***/
-- alter table tab_cols add constraint tab_cols_fa1
--    foreign key (beg_aud_usr) references sys.usr$ (name);

/***  ACTIVE Indexes  ***/
alter table tab_cols add constraint tab_cols_nk
    unique (table_id
           ,name
           );
alter table tab_cols add constraint tab_cols_ux1
    unique (table_id
           ,seq
           );
--  Skipping duplicate FK index on table_id
create index tab_cols_fx2 on tab_cols(fk_table_id);
create index tab_cols_fx3 on tab_cols(d_domain_id);


/***  ACTIVE Audit Foreign Key Indexes  ***/
-- create index tab_cols_ia1 on tab_cols(aud_beg_usr);
-- create index tab_cols_ia2 on tab_cols(aud_beg_dtm);

create package body tab_cols_tab
is

-- Package Body Tab_Cols_Tab
--    Table functions
--    (DML and integrity checks)
--
--    Generated by DTGen (http://code.google.com/p/dtgen)
--    July      27, 2012  09:33:53 PM

----------------------------------------
procedure check_rec
      (id  in  NUMBER
      ,table_id  in out  NUMBER
      ,name  in out  VARCHAR2
      ,seq  in out  NUMBER
      ,nk  in out  NUMBER
      ,req  in out  VARCHAR2
      ,fk_prefix  in out  VARCHAR2
      ,fk_table_id  in out  NUMBER
      ,d_domain_id  in out  NUMBER
      ,type  in out  VARCHAR2
      ,len  in out  NUMBER
      ,scale  in out  NUMBER
      ,fold  in out  VARCHAR2
      ,default_value  in out  VARCHAR2
      ,upd_res_pct  in out  NUMBER
      ,description  in out  VARCHAR2
      )
is
begin
   -- Fold the case, as needed
   if glob.get_fold_strings
   then
      name := lower(name);
      req := upper(req);
      fk_prefix := lower(fk_prefix);
      type := upper(type);
      fold := upper(fold);
   else
      if name != lower(name)
      then
         raise_application_error(-20003, 'tab_cols_tab.check_rec(): name must be lower case.');
      end if;
      if req != upper(req)
      then
         raise_application_error(-20003, 'tab_cols_tab.check_rec(): req must be upper case.');
      end if;
      if fk_prefix != lower(fk_prefix)
      then
         raise_application_error(-20003, 'tab_cols_tab.check_rec(): fk_prefix must be lower case.');
      end if;
      if type != upper(type)
      then
         raise_application_error(-20003, 'tab_cols_tab.check_rec(): type must be upper case.');
      end if;
      if fold != upper(fold)
      then
         raise_application_error(-20003, 'tab_cols_tab.check_rec(): fold must be upper case.');
      end if;
   end if;
   --  Check for NOT NULL
   if table_id is null
   then
      raise_application_error(-20004, 'tab_cols_tab.check_rec(): table_id cannot be null.');
   end if;
   if name is null
   then
      raise_application_error(-20004, 'tab_cols_tab.check_rec(): name cannot be null.');
   end if;
   if seq is null
   then
      raise_application_error(-20004, 'tab_cols_tab.check_rec(): seq cannot be null.');
   end if;
   -- Check for Domain Values
   if req not in ('X')
   then
      raise_application_error(-20005, 'tab_cols_tab.check_rec(): req must be one of ("X").');
   end if;
   if type not in ('NUMBER', 'VARCHAR2', 'DATE', 'TIMESTAMP WITH TIME ZONE', 'TIMESTAMP WITH LOCAL TIME ZONE')
   then
      raise_application_error(-20005, 'tab_cols_tab.check_rec(): type must be one of ("NUMBER", "VARCHAR2", "DATE", "TIMESTAMP WITH TIME ZONE", "TIMESTAMP WITH LOCAL TIME ZONE").');
   end if;
   if fold not in ('U', 'L', 'I')
   then
      raise_application_error(-20005, 'tab_cols_tab.check_rec(): fold must be one of ("U", "L", "I").');
   end if;
   -- Custom Constraint Checks
   if not (instr(name,' ') = 0)
   then
      raise_application_error(-20006, 'tab_cols_tab.check_rec(): Column name cannot have spaces');
   end if;
   if not (name not in ('id', 'eff_beg_dtm', 'eff_end_dtm', 'aud_beg_usr', 'aud_end_usr', 'aud_beg_dtm', 'aud_end_dtm', 'last_active'))
   then
      raise_application_error(-20006, 'tab_cols_tab.check_rec(): Column name cannot be one of "id", "eff_beg_dtm", "eff_end_dtm", "aud_beg_usr", "aud_end_usr", "aud_beg_dtm", "aud_end_dtm", or "last_active"');
   end if;
   if not (seq > 0)
   then
      raise_application_error(-20006, 'tab_cols_tab.check_rec(): Column sequence must be greater than 0');
   end if;
   if not (nk > 0)
   then
      raise_application_error(-20006, 'tab_cols_tab.check_rec(): Column natural key must be greater than 0');
   end if;
   if not (fk_table_id is not null or d_domain_id is not null or type is not null)
   then
      raise_application_error(-20006, 'tab_cols_tab.check_rec(): One of FK_TABLE_ID, D_DOMAIN_ID, or TYPE must have a value in columns');
   end if;
   if not (fk_table_id is null or d_domain_id is null)
   then
      raise_application_error(-20006, 'tab_cols_tab.check_rec(): FK_TABLE_ID and D_DOMAIN_ID cannot both have a value in columns');
   end if;
   if not (d_domain_id is null or type is null)
   then
      raise_application_error(-20006, 'tab_cols_tab.check_rec(): D_DOMAIN_ID and TYPE cannot both have a value in columns');
   end if;
   if not (fk_table_id is null or type is null)
   then
      raise_application_error(-20006, 'tab_cols_tab.check_rec(): FK_TABLE_ID and TYPE cannot both have a value in columns');
   end if;
   if not (fk_prefix is null or (fk_prefix is not null and fk_table_id is not null))
   then
      raise_application_error(-20006, 'tab_cols_tab.check_rec(): Column fk_prefix must be null unless column fk_table_id has a value');
   end if;
   if not (len is not null or type != 'VARCHAR2')
   then
      raise_application_error(-20006, 'tab_cols_tab.check_rec(): Len cannot be NULL if type is VARCHAR2');
   end if;
   if not (len is null or (len between 1 and 39 and type = 'NUMBER') or type != 'NUMBER')
   then
      raise_application_error(-20006, 'tab_cols_tab.check_rec(): Len (NUMBER precision) must be between 1 and 39');
   end if;
   if not (len is null or (len between 1 and 32767 and type = 'VARCHAR2') or type != 'VARCHAR2')
   then
      raise_application_error(-20006, 'tab_cols_tab.check_rec(): Len (VARCHAR2 length) must be between 1 and 32767');
   end if;
   if not (len is null or (len between 0 and 9 and type in ('TIMESTAMP WITH TIME ZONE', 'TIMESTAMP WITH LOCAL TIME ZONE')) or type not in ('TIMESTAMP WITH TIME ZONE', 'TIMESTAMP WITH LOCAL TIME ZONE'))
   then
      raise_application_error(-20006, 'tab_cols_tab.check_rec(): Len (TIMESTAMP fractional seconds digits) must be between 0 and 9');
   end if;
   if not (scale is null or (type = 'NUMBER' and len is not null))
   then
      raise_application_error(-20006, 'tab_cols_tab.check_rec(): Scale must be null unless column type is NUMBER and len is not NULL');
   end if;
   if not (scale is null or scale between -84 and 127)
   then
      raise_application_error(-20006, 'tab_cols_tab.check_rec(): Scale must be between -84 and 127, or NULL');
   end if;
   if not (fold is null or (type = 'VARCHAR2' and type is not null))
   then
      raise_application_error(-20006, 'tab_cols_tab.check_rec(): Column fold must be null unless type is VARCHAR2');
   end if;
   if not (nk is null or fk_table_id != table_id)
   then
      raise_application_error(-20006, 'tab_cols_tab.check_rec(): Self-referencing foreign keys (hierarchies) cannot be part of the natural key');
   end if;
   --  Set eff_beg_dtm, if needed
end check_rec;
----------------------------------------
procedure ins
      (n_id  in out  NUMBER
      ,n_table_id  in out  NUMBER
      ,n_name  in out  VARCHAR2
      ,n_seq  in out  NUMBER
      ,n_nk  in out  NUMBER
      ,n_req  in out  VARCHAR2
      ,n_fk_prefix  in out  VARCHAR2
      ,n_fk_table_id  in out  NUMBER
      ,n_d_domain_id  in out  NUMBER
      ,n_type  in out  VARCHAR2
      ,n_len  in out  NUMBER
      ,n_scale  in out  NUMBER
      ,n_fold  in out  VARCHAR2
      ,n_default_value  in out  VARCHAR2
      ,n_upd_res_pct  in out  NUMBER
      ,n_description  in out  VARCHAR2
      )
is
begin
   -- Set n_id, if needed
   if n_id is null
   then
      select tab_cols_seq.nextval
       into  n_id
       from  dual;
   end if;
   check_rec (n_id
             ,n_table_id
             ,n_name
             ,n_seq
             ,n_nk
             ,n_req
             ,n_fk_prefix
             ,n_fk_table_id
             ,n_d_domain_id
             ,n_type
             ,n_len
             ,n_scale
             ,n_fold
             ,n_default_value
             ,n_upd_res_pct
             ,n_description
             );
end ins;
----------------------------------------
procedure upd
      (o_id  in  NUMBER
      ,o_table_id  in      NUMBER
      ,n_table_id  in out  NUMBER
      ,o_name  in      VARCHAR2
      ,n_name  in out  VARCHAR2
      ,o_seq  in      NUMBER
      ,n_seq  in out  NUMBER
      ,o_nk  in      NUMBER
      ,n_nk  in out  NUMBER
      ,o_req  in      VARCHAR2
      ,n_req  in out  VARCHAR2
      ,o_fk_prefix  in      VARCHAR2
      ,n_fk_prefix  in out  VARCHAR2
      ,o_fk_table_id  in      NUMBER
      ,n_fk_table_id  in out  NUMBER
      ,o_d_domain_id  in      NUMBER
      ,n_d_domain_id  in out  NUMBER
      ,o_type  in      VARCHAR2
      ,n_type  in out  VARCHAR2
      ,o_len  in      NUMBER
      ,n_len  in out  NUMBER
      ,o_scale  in      NUMBER
      ,n_scale  in out  NUMBER
      ,o_fold  in      VARCHAR2
      ,n_fold  in out  VARCHAR2
      ,o_default_value  in      VARCHAR2
      ,n_default_value  in out  VARCHAR2
      ,o_upd_res_pct  in      NUMBER
      ,n_upd_res_pct  in out  NUMBER
      ,o_description  in      VARCHAR2
      ,n_description  in out  VARCHAR2
      )
is
begin
   if     o_table_id = n_table_id
      and o_name = n_name
      and o_seq = n_seq
      and util.is_equal(o_nk, n_nk)
      and util.is_equal(o_req, n_req)
      and util.is_equal(o_fk_prefix, n_fk_prefix)
      and util.is_equal(o_fk_table_id, n_fk_table_id)
      and util.is_equal(o_d_domain_id, n_d_domain_id)
      and util.is_equal(o_type, n_type)
      and util.is_equal(o_len, n_len)
      and util.is_equal(o_scale, n_scale)
      and util.is_equal(o_fold, n_fold)
      and util.is_equal(o_default_value, n_default_value)
      and util.is_equal(o_upd_res_pct, n_upd_res_pct)
      and util.is_equal(o_description, n_description)
   then
      if util.ignore_no_change
      then
         return;
      end if;
      raise_application_error(-20008, 'tab_cols_tab.upd(): Must update one of'
            || ' table_id'
            || ', name'
            || ', seq'
            || ', nk'
            || ', req'
            || ', fk_prefix'
            || ', fk_table_id'
            || ', d_domain_id'
            || ', type'
            || ', len'
            || ', scale'
            || ', fold'
            || ', default_value'
            || ', upd_res_pct'
            || ', description'
            || '.');
   end if;
   check_rec (o_id
             ,n_table_id
             ,n_name
             ,n_seq
             ,n_nk
             ,n_req
             ,n_fk_prefix
             ,n_fk_table_id
             ,n_d_domain_id
             ,n_type
             ,n_len
             ,n_scale
             ,n_fold
             ,n_default_value
             ,n_upd_res_pct
             ,n_description
             );
end upd;
----------------------------------------
procedure del
      (o_id  in  NUMBER
      ,o_table_id  in  NUMBER
      ,o_name  in  VARCHAR2
      ,o_seq  in  NUMBER
      ,o_nk  in  NUMBER
      ,o_req  in  VARCHAR2
      ,o_fk_prefix  in  VARCHAR2
      ,o_fk_table_id  in  NUMBER
      ,o_d_domain_id  in  NUMBER
      ,o_type  in  VARCHAR2
      ,o_len  in  NUMBER
      ,o_scale  in  NUMBER
      ,o_fold  in  VARCHAR2
      ,o_default_value  in  VARCHAR2
      ,o_upd_res_pct  in  NUMBER
      ,o_description  in  VARCHAR2
      )
is
begin
   return;
end del;
----------------------------------------
end tab_cols_tab;
/
select 'TAB_COLS_TAB' as "Package Body:"
 from  user_errors
 where name = 'TAB_COLS_TAB'
  and  type = 'PACKAGE BODY'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'TAB_COLS_TAB'
  and  type = 'PACKAGE BODY'
 order by sequence;

----------------------------------------
select '***  indexes  ***' as TABLE_NAME from dual;
----------------------------------------

create package indexes_tab
is

   -- Package Indexes_Tab
   --    Table functions
   --    (DML and integrity checks)
   --
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:33:53 PM

   procedure ins
      (n_id  in out  NUMBER
      ,n_tab_col_id  in out  NUMBER
      ,n_tag  in out  VARCHAR2
      ,n_seq  in out  NUMBER
      );
   procedure upd
      (o_id  in  NUMBER
      ,o_tab_col_id  in  NUMBER
      ,n_tab_col_id  in out  NUMBER
      ,o_tag  in  VARCHAR2
      ,n_tag  in out  VARCHAR2
      ,o_seq  in  NUMBER
      ,n_seq  in out  NUMBER
      );
   procedure del
      (o_id  in  NUMBER
      ,o_tab_col_id  in  NUMBER
      ,o_tag  in  VARCHAR2
      ,o_seq  in  NUMBER
      );
end indexes_tab;
/
select 'INDEXES_TAB' as "Package:"
 from  user_errors
 where name = 'INDEXES_TAB'
  and  type = 'PACKAGE'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'INDEXES_TAB'
  and  type = 'PACKAGE'
 order by sequence;

create sequence indexes_seq;

create table indexes
   (id   NUMBER(38)
   ,tab_col_id   NUMBER(38)
   ,tag   VARCHAR2(4)
   ,seq   NUMBER(1)
   );

comment on table indexes is 'Unique and non-unique indexes for this table';

comment on column indexes.id is 'Surrogate Primary Key for these indexes';
comment on column indexes.tab_col_id is 'Surrogate Key for the column for this index';
comment on column indexes.tag is 'Tag attached to the table name for this column that uniquely identifies this index';
comment on column indexes.seq is 'Sequence number for this column for this index';

alter table indexes add constraint indexes_pk
   primary key (id);

/***  ACTIVE Foreign Keys  ***/
alter table indexes add constraint indexes_fk1
   foreign key (tab_col_id) references tab_cols (id);
/***  ACTIVE Audit Foreign Key ***/
-- alter table indexes add constraint indexes_fa1
--    foreign key (beg_aud_usr) references sys.usr$ (name);

/***  ACTIVE Indexes  ***/
alter table indexes add constraint indexes_nk
    unique (tab_col_id
           ,tag
           ,seq
           );
create index indexes_fx1 on indexes(tab_col_id);


/***  ACTIVE Audit Foreign Key Indexes  ***/
-- create index indexes_ia1 on indexes(aud_beg_usr);
-- create index indexes_ia2 on indexes(aud_beg_dtm);

create package body indexes_tab
is

-- Package Body Indexes_Tab
--    Table functions
--    (DML and integrity checks)
--
--    Generated by DTGen (http://code.google.com/p/dtgen)
--    July      27, 2012  09:33:53 PM

----------------------------------------
procedure check_rec
      (id  in  NUMBER
      ,tab_col_id  in out  NUMBER
      ,tag  in out  VARCHAR2
      ,seq  in out  NUMBER
      )
is
begin
   -- Fold the case, as needed
   if glob.get_fold_strings
   then
      tag := lower(tag);
   else
      if tag != lower(tag)
      then
         raise_application_error(-20003, 'indexes_tab.check_rec(): tag must be lower case.');
      end if;
   end if;
   --  Check for NOT NULL
   if tab_col_id is null
   then
      raise_application_error(-20004, 'indexes_tab.check_rec(): tab_col_id cannot be null.');
   end if;
   if tag is null
   then
      raise_application_error(-20004, 'indexes_tab.check_rec(): tag cannot be null.');
   end if;
   if seq is null
   then
      raise_application_error(-20004, 'indexes_tab.check_rec(): seq cannot be null.');
   end if;
   -- Check for Domain Values
   -- Custom Constraint Checks
   if not (seq > 0)
   then
      raise_application_error(-20006, 'indexes_tab.check_rec(): Index column sequence must be greater than 0');
   end if;
   --  Set eff_beg_dtm, if needed
end check_rec;
----------------------------------------
procedure ins
      (n_id  in out  NUMBER
      ,n_tab_col_id  in out  NUMBER
      ,n_tag  in out  VARCHAR2
      ,n_seq  in out  NUMBER
      )
is
begin
   -- Set n_id, if needed
   if n_id is null
   then
      select indexes_seq.nextval
       into  n_id
       from  dual;
   end if;
   check_rec (n_id
             ,n_tab_col_id
             ,n_tag
             ,n_seq
             );
end ins;
----------------------------------------
procedure upd
      (o_id  in  NUMBER
      ,o_tab_col_id  in      NUMBER
      ,n_tab_col_id  in out  NUMBER
      ,o_tag  in      VARCHAR2
      ,n_tag  in out  VARCHAR2
      ,o_seq  in      NUMBER
      ,n_seq  in out  NUMBER
      )
is
begin
   if     o_tab_col_id = n_tab_col_id
      and o_tag = n_tag
      and o_seq = n_seq
   then
      if util.ignore_no_change
      then
         return;
      end if;
      raise_application_error(-20008, 'indexes_tab.upd(): Must update one of'
            || ' tab_col_id'
            || ', tag'
            || ', seq'
            || '.');
   end if;
   check_rec (o_id
             ,n_tab_col_id
             ,n_tag
             ,n_seq
             );
end upd;
----------------------------------------
procedure del
      (o_id  in  NUMBER
      ,o_tab_col_id  in  NUMBER
      ,o_tag  in  VARCHAR2
      ,o_seq  in  NUMBER
      )
is
begin
   return;
end del;
----------------------------------------
end indexes_tab;
/
select 'INDEXES_TAB' as "Package Body:"
 from  user_errors
 where name = 'INDEXES_TAB'
  and  type = 'PACKAGE BODY'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'INDEXES_TAB'
  and  type = 'PACKAGE BODY'
 order by sequence;

----------------------------------------
select '***  check_cons  ***' as TABLE_NAME from dual;
----------------------------------------

create package check_cons_tab
is

   -- Package Check_Cons_Tab
   --    Table functions
   --    (DML and integrity checks)
   --
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:33:53 PM

   procedure ins
      (n_id  in out  NUMBER
      ,n_table_id  in out  NUMBER
      ,n_seq  in out  NUMBER
      ,n_text  in out  VARCHAR2
      ,n_description  in out  VARCHAR2
      );
   procedure upd
      (o_id  in  NUMBER
      ,o_table_id  in  NUMBER
      ,n_table_id  in out  NUMBER
      ,o_seq  in  NUMBER
      ,n_seq  in out  NUMBER
      ,o_text  in  VARCHAR2
      ,n_text  in out  VARCHAR2
      ,o_description  in  VARCHAR2
      ,n_description  in out  VARCHAR2
      );
   procedure del
      (o_id  in  NUMBER
      ,o_table_id  in  NUMBER
      ,o_seq  in  NUMBER
      ,o_text  in  VARCHAR2
      ,o_description  in  VARCHAR2
      );
end check_cons_tab;
/
select 'CHECK_CONS_TAB' as "Package:"
 from  user_errors
 where name = 'CHECK_CONS_TAB'
  and  type = 'PACKAGE'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'CHECK_CONS_TAB'
  and  type = 'PACKAGE'
 order by sequence;

create sequence check_cons_seq;

create table check_cons
   (id   NUMBER(38)
   ,table_id   NUMBER(38)
   ,seq   NUMBER(2)
   ,text   VARCHAR2(1000)
   ,description   VARCHAR2(1000)
   );

comment on table check_cons is 'Check constraints to be generated for each table';

comment on column check_cons.id is 'Surrogate Primary Key for these check_cons';
comment on column check_cons.table_id is 'Surrogate Key for the table of this check constraint';
comment on column check_cons.seq is 'Sequence number of this check constraint';
comment on column check_cons.text is 'Execution (PL/SQL) text for this check constraint';
comment on column check_cons.description is 'Description of this check constraint';

alter table check_cons add constraint check_cons_pk
   primary key (id);

/***  ACTIVE Foreign Keys  ***/
alter table check_cons add constraint check_cons_fk1
   foreign key (table_id) references tables (id);
/***  ACTIVE Audit Foreign Key ***/
-- alter table check_cons add constraint check_cons_fa1
--    foreign key (beg_aud_usr) references sys.usr$ (name);

/***  ACTIVE Indexes  ***/
alter table check_cons add constraint check_cons_nk
    unique (table_id
           ,seq
           );
create index check_cons_fx1 on check_cons(table_id);


/***  ACTIVE Audit Foreign Key Indexes  ***/
-- create index check_cons_ia1 on check_cons(aud_beg_usr);
-- create index check_cons_ia2 on check_cons(aud_beg_dtm);

create package body check_cons_tab
is

-- Package Body Check_Cons_Tab
--    Table functions
--    (DML and integrity checks)
--
--    Generated by DTGen (http://code.google.com/p/dtgen)
--    July      27, 2012  09:33:54 PM

----------------------------------------
procedure check_rec
      (id  in  NUMBER
      ,table_id  in out  NUMBER
      ,seq  in out  NUMBER
      ,text  in out  VARCHAR2
      ,description  in out  VARCHAR2
      )
is
begin
   -- Fold the case, as needed
   --  Check for NOT NULL
   if table_id is null
   then
      raise_application_error(-20004, 'check_cons_tab.check_rec(): table_id cannot be null.');
   end if;
   if seq is null
   then
      raise_application_error(-20004, 'check_cons_tab.check_rec(): seq cannot be null.');
   end if;
   if text is null
   then
      raise_application_error(-20004, 'check_cons_tab.check_rec(): text cannot be null.');
   end if;
   -- Check for Domain Values
   -- Custom Constraint Checks
   if not (seq > 0)
   then
      raise_application_error(-20006, 'check_cons_tab.check_rec(): Check constraint sequence must be greater than 0');
   end if;
   --  Set eff_beg_dtm, if needed
end check_rec;
----------------------------------------
procedure ins
      (n_id  in out  NUMBER
      ,n_table_id  in out  NUMBER
      ,n_seq  in out  NUMBER
      ,n_text  in out  VARCHAR2
      ,n_description  in out  VARCHAR2
      )
is
begin
   -- Set n_id, if needed
   if n_id is null
   then
      select check_cons_seq.nextval
       into  n_id
       from  dual;
   end if;
   check_rec (n_id
             ,n_table_id
             ,n_seq
             ,n_text
             ,n_description
             );
end ins;
----------------------------------------
procedure upd
      (o_id  in  NUMBER
      ,o_table_id  in      NUMBER
      ,n_table_id  in out  NUMBER
      ,o_seq  in      NUMBER
      ,n_seq  in out  NUMBER
      ,o_text  in      VARCHAR2
      ,n_text  in out  VARCHAR2
      ,o_description  in      VARCHAR2
      ,n_description  in out  VARCHAR2
      )
is
begin
   if     o_table_id = n_table_id
      and o_seq = n_seq
      and o_text = n_text
      and util.is_equal(o_description, n_description)
   then
      if util.ignore_no_change
      then
         return;
      end if;
      raise_application_error(-20008, 'check_cons_tab.upd(): Must update one of'
            || ' table_id'
            || ', seq'
            || ', text'
            || ', description'
            || '.');
   end if;
   check_rec (o_id
             ,n_table_id
             ,n_seq
             ,n_text
             ,n_description
             );
end upd;
----------------------------------------
procedure del
      (o_id  in  NUMBER
      ,o_table_id  in  NUMBER
      ,o_seq  in  NUMBER
      ,o_text  in  VARCHAR2
      ,o_description  in  VARCHAR2
      )
is
begin
   return;
end del;
----------------------------------------
end check_cons_tab;
/
select 'CHECK_CONS_TAB' as "Package Body:"
 from  user_errors
 where name = 'CHECK_CONS_TAB'
  and  type = 'PACKAGE BODY'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'CHECK_CONS_TAB'
  and  type = 'PACKAGE BODY'
 order by sequence;

----------------------------------------
select '***  programs  ***' as TABLE_NAME from dual;
----------------------------------------

create package programs_tab
is

   -- Package Programs_Tab
   --    Table functions
   --    (DML and integrity checks)
   --
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:33:54 PM

   procedure ins
      (n_id  in out  NUMBER
      ,n_application_id  in out  NUMBER
      ,n_name  in out  VARCHAR2
      ,n_type  in out  VARCHAR2
      ,n_description  in out  VARCHAR2
      );
   procedure upd
      (o_id  in  NUMBER
      ,o_application_id  in  NUMBER
      ,n_application_id  in out  NUMBER
      ,o_name  in  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,o_type  in  VARCHAR2
      ,n_type  in out  VARCHAR2
      ,o_description  in  VARCHAR2
      ,n_description  in out  VARCHAR2
      );
   procedure del
      (o_id  in  NUMBER
      ,o_application_id  in  NUMBER
      ,o_name  in  VARCHAR2
      ,o_type  in  VARCHAR2
      ,o_description  in  VARCHAR2
      );
end programs_tab;
/
select 'PROGRAMS_TAB' as "Package:"
 from  user_errors
 where name = 'PROGRAMS_TAB'
  and  type = 'PACKAGE'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'PROGRAMS_TAB'
  and  type = 'PACKAGE'
 order by sequence;

create sequence programs_seq;

create table programs
   (id   NUMBER(38)
   ,application_id   NUMBER(38)
   ,name   VARCHAR2(30)
   ,type   VARCHAR2(30)
   ,description   VARCHAR2(1000)
   );

comment on table programs is 'Programs Registered to Run with the Application';

comment on column programs.id is 'Surrogate Primary Key for these programs';
comment on column programs.application_id is 'Surrogate Key for the application of this Shared Program Unit';
comment on column programs.name is 'Name of this Stored Program Unit';
comment on column programs.type is 'Type of this Stored Program Unit';
comment on column programs.description is 'Description of this Stored Program Unit';

alter table programs add constraint programs_pk
   primary key (id);

/***  ACTIVE Foreign Keys  ***/
alter table programs add constraint programs_fk1
   foreign key (application_id) references applications (id);
/***  ACTIVE Audit Foreign Key ***/
-- alter table programs add constraint programs_fa1
--    foreign key (beg_aud_usr) references sys.usr$ (name);

/***  ACTIVE Indexes  ***/
alter table programs add constraint programs_nk
    unique (application_id
           ,name
           );
create index programs_fx1 on programs(application_id);


/***  ACTIVE Audit Foreign Key Indexes  ***/
-- create index programs_ia1 on programs(aud_beg_usr);
-- create index programs_ia2 on programs(aud_beg_dtm);

create package body programs_tab
is

-- Package Body Programs_Tab
--    Table functions
--    (DML and integrity checks)
--
--    Generated by DTGen (http://code.google.com/p/dtgen)
--    July      27, 2012  09:33:54 PM

----------------------------------------
procedure check_rec
      (id  in  NUMBER
      ,application_id  in out  NUMBER
      ,name  in out  VARCHAR2
      ,type  in out  VARCHAR2
      ,description  in out  VARCHAR2
      )
is
begin
   -- Fold the case, as needed
   if glob.get_fold_strings
   then
      name := lower(name);
      type := upper(type);
   else
      if name != lower(name)
      then
         raise_application_error(-20003, 'programs_tab.check_rec(): name must be lower case.');
      end if;
      if type != upper(type)
      then
         raise_application_error(-20003, 'programs_tab.check_rec(): type must be upper case.');
      end if;
   end if;
   --  Check for NOT NULL
   if application_id is null
   then
      raise_application_error(-20004, 'programs_tab.check_rec(): application_id cannot be null.');
   end if;
   if name is null
   then
      raise_application_error(-20004, 'programs_tab.check_rec(): name cannot be null.');
   end if;
   if type is null
   then
      raise_application_error(-20004, 'programs_tab.check_rec(): type cannot be null.');
   end if;
   -- Check for Domain Values
   if type not in ('PACKAGE', 'FUNCTION', 'PROCEDURE')
   then
      raise_application_error(-20005, 'programs_tab.check_rec(): type must be one of ("PACKAGE", "FUNCTION", "PROCEDURE").');
   end if;
   -- Custom Constraint Checks
   if not (instr(name,' ') = 0)
   then
      raise_application_error(-20006, 'programs_tab.check_rec(): Stored Program Unit Name cannot have spaces');
   end if;
   --  Set eff_beg_dtm, if needed
end check_rec;
----------------------------------------
procedure ins
      (n_id  in out  NUMBER
      ,n_application_id  in out  NUMBER
      ,n_name  in out  VARCHAR2
      ,n_type  in out  VARCHAR2
      ,n_description  in out  VARCHAR2
      )
is
begin
   -- Set n_id, if needed
   if n_id is null
   then
      select programs_seq.nextval
       into  n_id
       from  dual;
   end if;
   check_rec (n_id
             ,n_application_id
             ,n_name
             ,n_type
             ,n_description
             );
end ins;
----------------------------------------
procedure upd
      (o_id  in  NUMBER
      ,o_application_id  in      NUMBER
      ,n_application_id  in out  NUMBER
      ,o_name  in      VARCHAR2
      ,n_name  in out  VARCHAR2
      ,o_type  in      VARCHAR2
      ,n_type  in out  VARCHAR2
      ,o_description  in      VARCHAR2
      ,n_description  in out  VARCHAR2
      )
is
begin
   if     o_application_id = n_application_id
      and o_name = n_name
      and o_type = n_type
      and util.is_equal(o_description, n_description)
   then
      if util.ignore_no_change
      then
         return;
      end if;
      raise_application_error(-20008, 'programs_tab.upd(): Must update one of'
            || ' application_id'
            || ', name'
            || ', type'
            || ', description'
            || '.');
   end if;
   check_rec (o_id
             ,n_application_id
             ,n_name
             ,n_type
             ,n_description
             );
end upd;
----------------------------------------
procedure del
      (o_id  in  NUMBER
      ,o_application_id  in  NUMBER
      ,o_name  in  VARCHAR2
      ,o_type  in  VARCHAR2
      ,o_description  in  VARCHAR2
      )
is
begin
   return;
end del;
----------------------------------------
end programs_tab;
/
select 'PROGRAMS_TAB' as "Package Body:"
 from  user_errors
 where name = 'PROGRAMS_TAB'
  and  type = 'PACKAGE BODY'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'PROGRAMS_TAB'
  and  type = 'PACKAGE BODY'
 order by sequence;

----------------------------------------
select '***  exceptions  ***' as TABLE_NAME from dual;
----------------------------------------

create package exceptions_tab
is

   -- Package Exceptions_Tab
   --    Table functions
   --    (DML and integrity checks)
   --
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:33:54 PM

   procedure ins
      (n_id  in out  NUMBER
      ,n_application_id  in out  NUMBER
      ,n_code  in out  NUMBER
      ,n_name  in out  VARCHAR2
      ,n_message  in out  VARCHAR2
      ,n_cause  in out  VARCHAR2
      ,n_action  in out  VARCHAR2
      );
   procedure upd
      (o_id  in  NUMBER
      ,o_application_id  in  NUMBER
      ,n_application_id  in out  NUMBER
      ,o_code  in  NUMBER
      ,n_code  in out  NUMBER
      ,o_name  in  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,o_message  in  VARCHAR2
      ,n_message  in out  VARCHAR2
      ,o_cause  in  VARCHAR2
      ,n_cause  in out  VARCHAR2
      ,o_action  in  VARCHAR2
      ,n_action  in out  VARCHAR2
      );
   procedure del
      (o_id  in  NUMBER
      ,o_application_id  in  NUMBER
      ,o_code  in  NUMBER
      ,o_name  in  VARCHAR2
      ,o_message  in  VARCHAR2
      ,o_cause  in  VARCHAR2
      ,o_action  in  VARCHAR2
      );
end exceptions_tab;
/
select 'EXCEPTIONS_TAB' as "Package:"
 from  user_errors
 where name = 'EXCEPTIONS_TAB'
  and  type = 'PACKAGE'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'EXCEPTIONS_TAB'
  and  type = 'PACKAGE'
 order by sequence;

create sequence exceptions_seq;

create table exceptions
   (id   NUMBER(38)
   ,application_id   NUMBER(38)
   ,code   NUMBER(5)
   ,name   VARCHAR2(30)
   ,message   VARCHAR2(2048)
   ,cause   VARCHAR2(2048)
   ,action   VARCHAR2(2048)
   );

comment on table exceptions is 'Application Exceptions for Error Trapping';

comment on column exceptions.id is 'Surrogate Primary Key for these exceptions';
comment on column exceptions.application_id is 'Surrogate Key for the application of this exception';
comment on column exceptions.code is 'RAISE_APPLICATION_ERROR Code for this exception';
comment on column exceptions.name is 'PRAGMA EXCEPTION_INIT Name for this exception';
comment on column exceptions.message is 'Error Message for this exception';
comment on column exceptions.cause is 'Error Cause for this exception';
comment on column exceptions.action is 'Possible Solution for this exception';

alter table exceptions add constraint exceptions_pk
   primary key (id);

/***  ACTIVE Foreign Keys  ***/
alter table exceptions add constraint exceptions_fk1
   foreign key (application_id) references applications (id);
/***  ACTIVE Audit Foreign Key ***/
-- alter table exceptions add constraint exceptions_fa1
--    foreign key (beg_aud_usr) references sys.usr$ (name);

/***  ACTIVE Indexes  ***/
alter table exceptions add constraint exceptions_nk
    unique (application_id
           ,code
           );
alter table exceptions add constraint exceptions_ux2
    unique (application_id
           ,name
           );
--  Skipping duplicate FK index on application_id


/***  ACTIVE Audit Foreign Key Indexes  ***/
-- create index exceptions_ia1 on exceptions(aud_beg_usr);
-- create index exceptions_ia2 on exceptions(aud_beg_dtm);

create package body exceptions_tab
is

-- Package Body Exceptions_Tab
--    Table functions
--    (DML and integrity checks)
--
--    Generated by DTGen (http://code.google.com/p/dtgen)
--    July      27, 2012  09:33:54 PM

----------------------------------------
procedure check_rec
      (id  in  NUMBER
      ,application_id  in out  NUMBER
      ,code  in out  NUMBER
      ,name  in out  VARCHAR2
      ,message  in out  VARCHAR2
      ,cause  in out  VARCHAR2
      ,action  in out  VARCHAR2
      )
is
begin
   -- Fold the case, as needed
   if glob.get_fold_strings
   then
      name := lower(name);
   else
      if name != lower(name)
      then
         raise_application_error(-20003, 'exceptions_tab.check_rec(): name must be lower case.');
      end if;
   end if;
   --  Check for NOT NULL
   if application_id is null
   then
      raise_application_error(-20004, 'exceptions_tab.check_rec(): application_id cannot be null.');
   end if;
   if code is null
   then
      raise_application_error(-20004, 'exceptions_tab.check_rec(): code cannot be null.');
   end if;
   if name is null
   then
      raise_application_error(-20004, 'exceptions_tab.check_rec(): name cannot be null.');
   end if;
   -- Check for Domain Values
   -- Custom Constraint Checks
   if not (code between -20999 and -20000)
   then
      raise_application_error(-20006, 'exceptions_tab.check_rec(): Exception code must be between -20999 and -20000');
   end if;
   if not (instr(name,' ') = 0)
   then
      raise_application_error(-20006, 'exceptions_tab.check_rec(): Exception name cannot have spaces');
   end if;
   --  Set eff_beg_dtm, if needed
end check_rec;
----------------------------------------
procedure ins
      (n_id  in out  NUMBER
      ,n_application_id  in out  NUMBER
      ,n_code  in out  NUMBER
      ,n_name  in out  VARCHAR2
      ,n_message  in out  VARCHAR2
      ,n_cause  in out  VARCHAR2
      ,n_action  in out  VARCHAR2
      )
is
begin
   -- Set n_id, if needed
   if n_id is null
   then
      select exceptions_seq.nextval
       into  n_id
       from  dual;
   end if;
   check_rec (n_id
             ,n_application_id
             ,n_code
             ,n_name
             ,n_message
             ,n_cause
             ,n_action
             );
end ins;
----------------------------------------
procedure upd
      (o_id  in  NUMBER
      ,o_application_id  in      NUMBER
      ,n_application_id  in out  NUMBER
      ,o_code  in      NUMBER
      ,n_code  in out  NUMBER
      ,o_name  in      VARCHAR2
      ,n_name  in out  VARCHAR2
      ,o_message  in      VARCHAR2
      ,n_message  in out  VARCHAR2
      ,o_cause  in      VARCHAR2
      ,n_cause  in out  VARCHAR2
      ,o_action  in      VARCHAR2
      ,n_action  in out  VARCHAR2
      )
is
begin
   if     o_application_id = n_application_id
      and o_code = n_code
      and o_name = n_name
      and util.is_equal(o_message, n_message)
      and util.is_equal(o_cause, n_cause)
      and util.is_equal(o_action, n_action)
   then
      if util.ignore_no_change
      then
         return;
      end if;
      raise_application_error(-20008, 'exceptions_tab.upd(): Must update one of'
            || ' application_id'
            || ', code'
            || ', name'
            || ', message'
            || ', cause'
            || ', action'
            || '.');
   end if;
   check_rec (o_id
             ,n_application_id
             ,n_code
             ,n_name
             ,n_message
             ,n_cause
             ,n_action
             );
end upd;
----------------------------------------
procedure del
      (o_id  in  NUMBER
      ,o_application_id  in  NUMBER
      ,o_code  in  NUMBER
      ,o_name  in  VARCHAR2
      ,o_message  in  VARCHAR2
      ,o_cause  in  VARCHAR2
      ,o_action  in  VARCHAR2
      )
is
begin
   return;
end del;
----------------------------------------
end exceptions_tab;
/
select 'EXCEPTIONS_TAB' as "Package Body:"
 from  user_errors
 where name = 'EXCEPTIONS_TAB'
  and  type = 'PACKAGE BODY'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'EXCEPTIONS_TAB'
  and  type = 'PACKAGE BODY'
 order by sequence;



select ' -) create_integ  ' as FILE_NAME from dual;


-- Script File "create_integ"
--    Create ODS integrity using generated code
--
--    Generated by DTGen (http://code.google.com/p/dtgen)
--    July      27, 2012  09:33:57 PM


----------------------------------------
select '***  applications  ***' as TABLE_NAME from dual;
----------------------------------------

alter table applications modify abbr
   constraint applications_nn1 not null;
alter table applications modify name
   constraint applications_nn2 not null;
alter table applications add constraint applications_ck1
   check (instr(db_schema,' ') = 0);
alter table applications add constraint applications_ck2
   check (instr(apex_schema,' ') = 0);
alter table applications add constraint applications_ck3
   check (instr(dbid,' ') = 0);
alter table applications add constraint applications_ck4
   check (db_auth is null or dbid is not null);
alter table applications add constraint applications_ck5
   check (db_schema_exp is null or db_schema is not null);
alter table applications add constraint applications_fld1
   check (abbr = upper(abbr));
alter table applications add constraint applications_fld2
   check (name = initcap(name));
alter table applications add constraint applications_fld3
   check (db_schema = upper(db_schema));
alter table applications add constraint applications_fld4
   check (apex_schema = upper(apex_schema));
alter table applications add constraint applications_fld5
   check (apex_ws_name = upper(apex_ws_name));
alter table applications add constraint applications_fld6
   check (ts_onln_data = lower(ts_onln_data));
alter table applications add constraint applications_fld7
   check (ts_onln_indx = lower(ts_onln_indx));
alter table applications add constraint applications_fld8
   check (ts_hist_data = lower(ts_hist_data));
alter table applications add constraint applications_fld9
   check (ts_hist_indx = lower(ts_hist_indx));
alter table applications add constraint applications_fld10
   check (usr_datatype = upper(usr_datatype));
alter table applications add constraint applications_fld11
   check (usr_frgn_key = lower(usr_frgn_key));
alter table applications add constraint applications_dm1
   check (db_schema_exp in ('X'));
alter table applications add constraint applications_dm2
   check (ts_null_override in ('X'));

CREATE TRIGGER applications_bi
   BEFORE INSERT
   ON applications FOR EACH ROW
begin

   -- Trigger Applications_Bi
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:33:57 PM

   -- util.log('Trigger applications_bi');
   if glob.get_db_constraints
   then
      applications_tab.ins
         (:new.id
         ,:new.abbr
         ,:new.name
         ,:new.db_schema
         ,:new.db_schema_exp
         ,:new.apex_schema
         ,:new.apex_ws_name
         ,:new.apex_app_name
         ,:new.dbid
         ,:new.db_auth
         ,:new.description
         ,:new.ts_null_override
         ,:new.ts_onln_data
         ,:new.ts_onln_indx
         ,:new.ts_hist_data
         ,:new.ts_hist_indx
         ,:new.usr_datatype
         ,:new.usr_frgn_key
         ,:new.copyright
         );
   end if;
end applications_bi;
/
select 'APPLICATIONS_BI' as "Trigger:"
 from  user_errors
 where name = 'APPLICATIONS_BI'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'APPLICATIONS_BI'
  and  type = 'TRIGGER'
 order by sequence;

CREATE TRIGGER applications_bu
   BEFORE UPDATE
   ON applications FOR EACH ROW
begin

   -- Trigger Applications_Bu
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:33:57 PM

   -- util.log('Trigger applications_bu');
   if glob.get_db_constraints
   then
      applications_tab.upd
         (:old.id
         ,:old.abbr
         ,:new.abbr
         ,:old.name
         ,:new.name
         ,:old.db_schema
         ,:new.db_schema
         ,:old.db_schema_exp
         ,:new.db_schema_exp
         ,:old.apex_schema
         ,:new.apex_schema
         ,:old.apex_ws_name
         ,:new.apex_ws_name
         ,:old.apex_app_name
         ,:new.apex_app_name
         ,:old.dbid
         ,:new.dbid
         ,:old.db_auth
         ,:new.db_auth
         ,:old.description
         ,:new.description
         ,:old.ts_null_override
         ,:new.ts_null_override
         ,:old.ts_onln_data
         ,:new.ts_onln_data
         ,:old.ts_onln_indx
         ,:new.ts_onln_indx
         ,:old.ts_hist_data
         ,:new.ts_hist_data
         ,:old.ts_hist_indx
         ,:new.ts_hist_indx
         ,:old.usr_datatype
         ,:new.usr_datatype
         ,:old.usr_frgn_key
         ,:new.usr_frgn_key
         ,:old.copyright
         ,:new.copyright
         );
   end if;
end applications_bu;
/
select 'APPLICATIONS_BU' as "Trigger:"
 from  user_errors
 where name = 'APPLICATIONS_BU'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'APPLICATIONS_BU'
  and  type = 'TRIGGER'
 order by sequence;

CREATE TRIGGER applications_bd
   BEFORE DELETE
   ON applications FOR EACH ROW
begin

   -- Trigger Applications_Bd
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:33:57 PM

   -- util.log('Trigger applications_bd');
   if glob.get_db_constraints
   then
      applications_tab.del
         (:old.id
         ,:old.abbr
         ,:old.name
         ,:old.db_schema
         ,:old.db_schema_exp
         ,:old.apex_schema
         ,:old.apex_ws_name
         ,:old.apex_app_name
         ,:old.dbid
         ,:old.db_auth
         ,:old.description
         ,:old.ts_null_override
         ,:old.ts_onln_data
         ,:old.ts_onln_indx
         ,:old.ts_hist_data
         ,:old.ts_hist_indx
         ,:old.usr_datatype
         ,:old.usr_frgn_key
         ,:old.copyright
         );
   end if;
end applications_bd;
/
select 'APPLICATIONS_BD' as "Trigger:"
 from  user_errors
 where name = 'APPLICATIONS_BD'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'APPLICATIONS_BD'
  and  type = 'TRIGGER'
 order by sequence;

----------------------------------------
select '***  files  ***' as TABLE_NAME from dual;
----------------------------------------

alter table files modify application_id
   constraint files_nn1 not null;
alter table files modify name
   constraint files_nn2 not null;
alter table files modify type
   constraint files_nn3 not null;
alter table files add constraint files_dm1
   check (type in ('SQL', 'LOG'));

CREATE TRIGGER files_bi
   BEFORE INSERT
   ON files FOR EACH ROW
begin

   -- Trigger Files_Bi
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:33:57 PM

   -- util.log('Trigger files_bi');
   if glob.get_db_constraints
   then
      files_tab.ins
         (:new.id
         ,:new.application_id
         ,:new.name
         ,:new.type
         ,:new.created_dt
         ,:new.description
         );
   end if;
end files_bi;
/
select 'FILES_BI' as "Trigger:"
 from  user_errors
 where name = 'FILES_BI'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'FILES_BI'
  and  type = 'TRIGGER'
 order by sequence;

CREATE TRIGGER files_bu
   BEFORE UPDATE
   ON files FOR EACH ROW
begin

   -- Trigger Files_Bu
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:33:58 PM

   -- util.log('Trigger files_bu');
   if glob.get_db_constraints
   then
      files_tab.upd
         (:old.id
         ,:old.application_id
         ,:new.application_id
         ,:old.name
         ,:new.name
         ,:old.type
         ,:new.type
         ,:old.created_dt
         ,:new.created_dt
         ,:old.description
         ,:new.description
         );
   end if;
end files_bu;
/
select 'FILES_BU' as "Trigger:"
 from  user_errors
 where name = 'FILES_BU'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'FILES_BU'
  and  type = 'TRIGGER'
 order by sequence;

CREATE TRIGGER files_bd
   BEFORE DELETE
   ON files FOR EACH ROW
begin

   -- Trigger Files_Bd
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:33:58 PM

   -- util.log('Trigger files_bd');
   if glob.get_db_constraints
   then
      files_tab.del
         (:old.id
         ,:old.application_id
         ,:old.name
         ,:old.type
         ,:old.created_dt
         ,:old.description
         );
   end if;
end files_bd;
/
select 'FILES_BD' as "Trigger:"
 from  user_errors
 where name = 'FILES_BD'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'FILES_BD'
  and  type = 'TRIGGER'
 order by sequence;

----------------------------------------
select '***  file_lines  ***' as TABLE_NAME from dual;
----------------------------------------

alter table file_lines modify file_id
   constraint file_lines_nn1 not null;
alter table file_lines modify seq
   constraint file_lines_nn2 not null;

CREATE TRIGGER file_lines_bi
   BEFORE INSERT
   ON file_lines FOR EACH ROW
begin

   -- Trigger File_Lines_Bi
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:33:58 PM

   -- util.log('Trigger file_lines_bi');
   if glob.get_db_constraints
   then
      file_lines_tab.ins
         (:new.id
         ,:new.file_id
         ,:new.seq
         ,:new.value
         );
   end if;
end file_lines_bi;
/
select 'FILE_LINES_BI' as "Trigger:"
 from  user_errors
 where name = 'FILE_LINES_BI'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'FILE_LINES_BI'
  and  type = 'TRIGGER'
 order by sequence;

CREATE TRIGGER file_lines_bu
   BEFORE UPDATE
   ON file_lines FOR EACH ROW
begin

   -- Trigger File_Lines_Bu
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:33:58 PM

   -- util.log('Trigger file_lines_bu');
   if glob.get_db_constraints
   then
      file_lines_tab.upd
         (:old.id
         ,:old.file_id
         ,:new.file_id
         ,:old.seq
         ,:new.seq
         ,:old.value
         ,:new.value
         );
   end if;
end file_lines_bu;
/
select 'FILE_LINES_BU' as "Trigger:"
 from  user_errors
 where name = 'FILE_LINES_BU'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'FILE_LINES_BU'
  and  type = 'TRIGGER'
 order by sequence;

CREATE TRIGGER file_lines_bd
   BEFORE DELETE
   ON file_lines FOR EACH ROW
begin

   -- Trigger File_Lines_Bd
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:33:58 PM

   -- util.log('Trigger file_lines_bd');
   if glob.get_db_constraints
   then
      file_lines_tab.del
         (:old.id
         ,:old.file_id
         ,:old.seq
         ,:old.value
         );
   end if;
end file_lines_bd;
/
select 'FILE_LINES_BD' as "Trigger:"
 from  user_errors
 where name = 'FILE_LINES_BD'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'FILE_LINES_BD'
  and  type = 'TRIGGER'
 order by sequence;

----------------------------------------
select '***  domains  ***' as TABLE_NAME from dual;
----------------------------------------

alter table domains modify application_id
   constraint domains_nn1 not null;
alter table domains modify abbr
   constraint domains_nn2 not null;
alter table domains modify name
   constraint domains_nn3 not null;
alter table domains modify fold
   constraint domains_nn4 not null;
alter table domains modify len
   constraint domains_nn5 not null;
alter table domains add constraint domains_ck1
   check (len > 0);
alter table domains add constraint domains_fld1
   check (abbr = upper(abbr));
alter table domains add constraint domains_fld2
   check (name = initcap(name));
alter table domains add constraint domains_dm1
   check (fold in ('U', 'L', 'I'));

CREATE TRIGGER domains_bi
   BEFORE INSERT
   ON domains FOR EACH ROW
begin

   -- Trigger Domains_Bi
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:33:58 PM

   -- util.log('Trigger domains_bi');
   if glob.get_db_constraints
   then
      domains_tab.ins
         (:new.id
         ,:new.application_id
         ,:new.abbr
         ,:new.name
         ,:new.fold
         ,:new.len
         ,:new.description
         );
   end if;
end domains_bi;
/
select 'DOMAINS_BI' as "Trigger:"
 from  user_errors
 where name = 'DOMAINS_BI'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'DOMAINS_BI'
  and  type = 'TRIGGER'
 order by sequence;

CREATE TRIGGER domains_bu
   BEFORE UPDATE
   ON domains FOR EACH ROW
begin

   -- Trigger Domains_Bu
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:33:58 PM

   -- util.log('Trigger domains_bu');
   if glob.get_db_constraints
   then
      domains_tab.upd
         (:old.id
         ,:old.application_id
         ,:new.application_id
         ,:old.abbr
         ,:new.abbr
         ,:old.name
         ,:new.name
         ,:old.fold
         ,:new.fold
         ,:old.len
         ,:new.len
         ,:old.description
         ,:new.description
         );
   end if;
end domains_bu;
/
select 'DOMAINS_BU' as "Trigger:"
 from  user_errors
 where name = 'DOMAINS_BU'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'DOMAINS_BU'
  and  type = 'TRIGGER'
 order by sequence;

CREATE TRIGGER domains_bd
   BEFORE DELETE
   ON domains FOR EACH ROW
begin

   -- Trigger Domains_Bd
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:33:58 PM

   -- util.log('Trigger domains_bd');
   if glob.get_db_constraints
   then
      domains_tab.del
         (:old.id
         ,:old.application_id
         ,:old.abbr
         ,:old.name
         ,:old.fold
         ,:old.len
         ,:old.description
         );
   end if;
end domains_bd;
/
select 'DOMAINS_BD' as "Trigger:"
 from  user_errors
 where name = 'DOMAINS_BD'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'DOMAINS_BD'
  and  type = 'TRIGGER'
 order by sequence;

----------------------------------------
select '***  domain_values  ***' as TABLE_NAME from dual;
----------------------------------------

alter table domain_values modify domain_id
   constraint domain_values_nn1 not null;
alter table domain_values modify seq
   constraint domain_values_nn3 not null;
alter table domain_values modify value
   constraint domain_values_nn4 not null;
alter table domain_values add constraint domain_values_ck1
   check (seq > 0);

CREATE TRIGGER domain_values_bi
   BEFORE INSERT
   ON domain_values FOR EACH ROW
begin

   -- Trigger Domain_Values_Bi
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:33:58 PM

   -- util.log('Trigger domain_values_bi');
   if glob.get_db_constraints
   then
      domain_values_tab.ins
         (:new.id
         ,:new.domain_id
         ,:new.seq
         ,:new.value
         ,:new.description
         );
   end if;
end domain_values_bi;
/
select 'DOMAIN_VALUES_BI' as "Trigger:"
 from  user_errors
 where name = 'DOMAIN_VALUES_BI'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'DOMAIN_VALUES_BI'
  and  type = 'TRIGGER'
 order by sequence;

CREATE TRIGGER domain_values_bu
   BEFORE UPDATE
   ON domain_values FOR EACH ROW
begin

   -- Trigger Domain_Values_Bu
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:33:58 PM

   -- util.log('Trigger domain_values_bu');
   if glob.get_db_constraints
   then
      domain_values_tab.upd
         (:old.id
         ,:old.domain_id
         ,:new.domain_id
         ,:old.seq
         ,:new.seq
         ,:old.value
         ,:new.value
         ,:old.description
         ,:new.description
         );
   end if;
end domain_values_bu;
/
select 'DOMAIN_VALUES_BU' as "Trigger:"
 from  user_errors
 where name = 'DOMAIN_VALUES_BU'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'DOMAIN_VALUES_BU'
  and  type = 'TRIGGER'
 order by sequence;

CREATE TRIGGER domain_values_bd
   BEFORE DELETE
   ON domain_values FOR EACH ROW
begin

   -- Trigger Domain_Values_Bd
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:33:58 PM

   -- util.log('Trigger domain_values_bd');
   if glob.get_db_constraints
   then
      domain_values_tab.del
         (:old.id
         ,:old.domain_id
         ,:old.seq
         ,:old.value
         ,:old.description
         );
   end if;
end domain_values_bd;
/
select 'DOMAIN_VALUES_BD' as "Trigger:"
 from  user_errors
 where name = 'DOMAIN_VALUES_BD'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'DOMAIN_VALUES_BD'
  and  type = 'TRIGGER'
 order by sequence;

----------------------------------------
select '***  tables  ***' as TABLE_NAME from dual;
----------------------------------------

alter table tables modify application_id
   constraint tables_nn1 not null;
alter table tables modify abbr
   constraint tables_nn2 not null;
alter table tables modify name
   constraint tables_nn3 not null;
alter table tables modify seq
   constraint tables_nn4 not null;
alter table tables modify type
   constraint tables_nn5 not null;
alter table tables add constraint tables_ck1
   check (instr(abbr,' ') = 0);
alter table tables add constraint tables_ck2
   check (instr(name,' ') = 0);
alter table tables add constraint tables_ck3
   check (seq > 0);
alter table tables add constraint tables_ck4
   check (seq < 200);
alter table tables add constraint tables_ck5
   check (mv_refresh_hr > 0);
alter table tables add constraint tables_ck6
   check (instr(ts_onln_data,' ') = 0);
alter table tables add constraint tables_ck7
   check (instr(ts_onln_indx,' ') = 0);
alter table tables add constraint tables_ck8
   check (instr(ts_hist_data,' ') = 0);
alter table tables add constraint tables_ck9
   check (instr(ts_hist_indx,' ') = 0);
alter table tables add constraint tables_fld1
   check (abbr = upper(abbr));
alter table tables add constraint tables_fld2
   check (name = lower(name));
alter table tables add constraint tables_fld3
   check (group_name = upper(group_name));
alter table tables add constraint tables_fld4
   check (ts_onln_data = lower(ts_onln_data));
alter table tables add constraint tables_fld5
   check (ts_onln_indx = lower(ts_onln_indx));
alter table tables add constraint tables_fld6
   check (ts_hist_data = lower(ts_hist_data));
alter table tables add constraint tables_fld7
   check (ts_hist_indx = lower(ts_hist_indx));
alter table tables add constraint tables_dm1
   check (type in ('EFF', 'LOG', 'NON'));

CREATE TRIGGER tables_bi
   BEFORE INSERT
   ON tables FOR EACH ROW
begin

   -- Trigger Tables_Bi
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:33:58 PM

   -- util.log('Trigger tables_bi');
   if glob.get_db_constraints
   then
      tables_tab.ins
         (:new.id
         ,:new.application_id
         ,:new.abbr
         ,:new.name
         ,:new.seq
         ,:new.type
         ,:new.group_name
         ,:new.mv_refresh_hr
         ,:new.ts_onln_data
         ,:new.ts_onln_indx
         ,:new.ts_hist_data
         ,:new.ts_hist_indx
         ,:new.description
         );
   end if;
end tables_bi;
/
select 'TABLES_BI' as "Trigger:"
 from  user_errors
 where name = 'TABLES_BI'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'TABLES_BI'
  and  type = 'TRIGGER'
 order by sequence;

CREATE TRIGGER tables_bu
   BEFORE UPDATE
   ON tables FOR EACH ROW
begin

   -- Trigger Tables_Bu
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:33:58 PM

   -- util.log('Trigger tables_bu');
   if glob.get_db_constraints
   then
      tables_tab.upd
         (:old.id
         ,:old.application_id
         ,:new.application_id
         ,:old.abbr
         ,:new.abbr
         ,:old.name
         ,:new.name
         ,:old.seq
         ,:new.seq
         ,:old.type
         ,:new.type
         ,:old.group_name
         ,:new.group_name
         ,:old.mv_refresh_hr
         ,:new.mv_refresh_hr
         ,:old.ts_onln_data
         ,:new.ts_onln_data
         ,:old.ts_onln_indx
         ,:new.ts_onln_indx
         ,:old.ts_hist_data
         ,:new.ts_hist_data
         ,:old.ts_hist_indx
         ,:new.ts_hist_indx
         ,:old.description
         ,:new.description
         );
   end if;
end tables_bu;
/
select 'TABLES_BU' as "Trigger:"
 from  user_errors
 where name = 'TABLES_BU'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'TABLES_BU'
  and  type = 'TRIGGER'
 order by sequence;

CREATE TRIGGER tables_bd
   BEFORE DELETE
   ON tables FOR EACH ROW
begin

   -- Trigger Tables_Bd
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:33:58 PM

   -- util.log('Trigger tables_bd');
   if glob.get_db_constraints
   then
      tables_tab.del
         (:old.id
         ,:old.application_id
         ,:old.abbr
         ,:old.name
         ,:old.seq
         ,:old.type
         ,:old.group_name
         ,:old.mv_refresh_hr
         ,:old.ts_onln_data
         ,:old.ts_onln_indx
         ,:old.ts_hist_data
         ,:old.ts_hist_indx
         ,:old.description
         );
   end if;
end tables_bd;
/
select 'TABLES_BD' as "Trigger:"
 from  user_errors
 where name = 'TABLES_BD'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'TABLES_BD'
  and  type = 'TRIGGER'
 order by sequence;

----------------------------------------
select '***  tab_cols  ***' as TABLE_NAME from dual;
----------------------------------------

alter table tab_cols modify table_id
   constraint tab_cols_nn1 not null;
alter table tab_cols modify name
   constraint tab_cols_nn2 not null;
alter table tab_cols modify seq
   constraint tab_cols_nn3 not null;
alter table tab_cols add constraint tab_cols_ck1
   check (instr(name,' ') = 0);
alter table tab_cols add constraint tab_cols_ck2
   check (name not in ('id', 'eff_beg_dtm', 'eff_end_dtm', 'aud_beg_usr', 'aud_end_usr', 'aud_beg_dtm', 'aud_end_dtm', 'last_active'));
alter table tab_cols add constraint tab_cols_ck3
   check (seq > 0);
alter table tab_cols add constraint tab_cols_ck4
   check (nk > 0);
alter table tab_cols add constraint tab_cols_ck5
   check (fk_table_id is not null or d_domain_id is not null or type is not null);
alter table tab_cols add constraint tab_cols_ck6
   check (fk_table_id is null or d_domain_id is null);
alter table tab_cols add constraint tab_cols_ck7
   check (d_domain_id is null or type is null);
alter table tab_cols add constraint tab_cols_ck8
   check (fk_table_id is null or type is null);
alter table tab_cols add constraint tab_cols_ck9
   check (fk_prefix is null or (fk_prefix is not null and fk_table_id is not null));
alter table tab_cols add constraint tab_cols_ck10
   check (len is not null or type != 'VARCHAR2');
alter table tab_cols add constraint tab_cols_ck11
   check (len is null or (len between 1 and 39 and type = 'NUMBER') or type != 'NUMBER');
alter table tab_cols add constraint tab_cols_ck12
   check (len is null or (len between 1 and 32767 and type = 'VARCHAR2') or type != 'VARCHAR2');
alter table tab_cols add constraint tab_cols_ck13
   check (len is null or (len between 0 and 9 and type in ('TIMESTAMP WITH TIME ZONE', 'TIMESTAMP WITH LOCAL TIME ZONE')) or type not in ('TIMESTAMP WITH TIME ZONE', 'TIMESTAMP WITH LOCAL TIME ZONE'));
alter table tab_cols add constraint tab_cols_ck14
   check (scale is null or (type = 'NUMBER' and len is not null));
alter table tab_cols add constraint tab_cols_ck15
   check (scale is null or scale between -84 and 127);
alter table tab_cols add constraint tab_cols_ck16
   check (fold is null or (type = 'VARCHAR2' and type is not null));
alter table tab_cols add constraint tab_cols_ck17
   check (nk is null or fk_table_id != table_id);
alter table tab_cols add constraint tab_cols_fld1
   check (name = lower(name));
alter table tab_cols add constraint tab_cols_fld2
   check (fk_prefix = lower(fk_prefix));
alter table tab_cols add constraint tab_cols_dm1
   check (req in ('X'));
alter table tab_cols add constraint tab_cols_dm2
   check (type in ('NUMBER', 'VARCHAR2', 'DATE', 'TIMESTAMP WITH TIME ZONE', 'TIMESTAMP WITH LOCAL TIME ZONE'));
alter table tab_cols add constraint tab_cols_dm3
   check (fold in ('U', 'L', 'I'));

CREATE TRIGGER tab_cols_bi
   BEFORE INSERT
   ON tab_cols FOR EACH ROW
begin

   -- Trigger Tab_Cols_Bi
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:33:59 PM

   -- util.log('Trigger tab_cols_bi');
   if glob.get_db_constraints
   then
      tab_cols_tab.ins
         (:new.id
         ,:new.table_id
         ,:new.name
         ,:new.seq
         ,:new.nk
         ,:new.req
         ,:new.fk_prefix
         ,:new.fk_table_id
         ,:new.d_domain_id
         ,:new.type
         ,:new.len
         ,:new.scale
         ,:new.fold
         ,:new.default_value
         ,:new.upd_res_pct
         ,:new.description
         );
   end if;
end tab_cols_bi;
/
select 'TAB_COLS_BI' as "Trigger:"
 from  user_errors
 where name = 'TAB_COLS_BI'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'TAB_COLS_BI'
  and  type = 'TRIGGER'
 order by sequence;

CREATE TRIGGER tab_cols_bu
   BEFORE UPDATE
   ON tab_cols FOR EACH ROW
begin

   -- Trigger Tab_Cols_Bu
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:33:59 PM

   -- util.log('Trigger tab_cols_bu');
   if glob.get_db_constraints
   then
      tab_cols_tab.upd
         (:old.id
         ,:old.table_id
         ,:new.table_id
         ,:old.name
         ,:new.name
         ,:old.seq
         ,:new.seq
         ,:old.nk
         ,:new.nk
         ,:old.req
         ,:new.req
         ,:old.fk_prefix
         ,:new.fk_prefix
         ,:old.fk_table_id
         ,:new.fk_table_id
         ,:old.d_domain_id
         ,:new.d_domain_id
         ,:old.type
         ,:new.type
         ,:old.len
         ,:new.len
         ,:old.scale
         ,:new.scale
         ,:old.fold
         ,:new.fold
         ,:old.default_value
         ,:new.default_value
         ,:old.upd_res_pct
         ,:new.upd_res_pct
         ,:old.description
         ,:new.description
         );
   end if;
end tab_cols_bu;
/
select 'TAB_COLS_BU' as "Trigger:"
 from  user_errors
 where name = 'TAB_COLS_BU'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'TAB_COLS_BU'
  and  type = 'TRIGGER'
 order by sequence;

CREATE TRIGGER tab_cols_bd
   BEFORE DELETE
   ON tab_cols FOR EACH ROW
begin

   -- Trigger Tab_Cols_Bd
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:33:59 PM

   -- util.log('Trigger tab_cols_bd');
   if glob.get_db_constraints
   then
      tab_cols_tab.del
         (:old.id
         ,:old.table_id
         ,:old.name
         ,:old.seq
         ,:old.nk
         ,:old.req
         ,:old.fk_prefix
         ,:old.fk_table_id
         ,:old.d_domain_id
         ,:old.type
         ,:old.len
         ,:old.scale
         ,:old.fold
         ,:old.default_value
         ,:old.upd_res_pct
         ,:old.description
         );
   end if;
end tab_cols_bd;
/
select 'TAB_COLS_BD' as "Trigger:"
 from  user_errors
 where name = 'TAB_COLS_BD'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'TAB_COLS_BD'
  and  type = 'TRIGGER'
 order by sequence;

----------------------------------------
select '***  indexes  ***' as TABLE_NAME from dual;
----------------------------------------

alter table indexes modify tab_col_id
   constraint indexes_nn1 not null;
alter table indexes modify tag
   constraint indexes_nn2 not null;
alter table indexes modify seq
   constraint indexes_nn3 not null;
alter table indexes add constraint indexes_ck1
   check (seq > 0);
alter table indexes add constraint indexes_fld1
   check (tag = lower(tag));

CREATE TRIGGER indexes_bi
   BEFORE INSERT
   ON indexes FOR EACH ROW
begin

   -- Trigger Indexes_Bi
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:33:59 PM

   -- util.log('Trigger indexes_bi');
   if glob.get_db_constraints
   then
      indexes_tab.ins
         (:new.id
         ,:new.tab_col_id
         ,:new.tag
         ,:new.seq
         );
   end if;
end indexes_bi;
/
select 'INDEXES_BI' as "Trigger:"
 from  user_errors
 where name = 'INDEXES_BI'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'INDEXES_BI'
  and  type = 'TRIGGER'
 order by sequence;

CREATE TRIGGER indexes_bu
   BEFORE UPDATE
   ON indexes FOR EACH ROW
begin

   -- Trigger Indexes_Bu
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:33:59 PM

   -- util.log('Trigger indexes_bu');
   if glob.get_db_constraints
   then
      indexes_tab.upd
         (:old.id
         ,:old.tab_col_id
         ,:new.tab_col_id
         ,:old.tag
         ,:new.tag
         ,:old.seq
         ,:new.seq
         );
   end if;
end indexes_bu;
/
select 'INDEXES_BU' as "Trigger:"
 from  user_errors
 where name = 'INDEXES_BU'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'INDEXES_BU'
  and  type = 'TRIGGER'
 order by sequence;

CREATE TRIGGER indexes_bd
   BEFORE DELETE
   ON indexes FOR EACH ROW
begin

   -- Trigger Indexes_Bd
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:33:59 PM

   -- util.log('Trigger indexes_bd');
   if glob.get_db_constraints
   then
      indexes_tab.del
         (:old.id
         ,:old.tab_col_id
         ,:old.tag
         ,:old.seq
         );
   end if;
end indexes_bd;
/
select 'INDEXES_BD' as "Trigger:"
 from  user_errors
 where name = 'INDEXES_BD'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'INDEXES_BD'
  and  type = 'TRIGGER'
 order by sequence;

----------------------------------------
select '***  check_cons  ***' as TABLE_NAME from dual;
----------------------------------------

alter table check_cons modify table_id
   constraint check_cons_nn1 not null;
alter table check_cons modify seq
   constraint check_cons_nn2 not null;
alter table check_cons modify text
   constraint check_cons_nn3 not null;
alter table check_cons add constraint check_cons_ck1
   check (seq > 0);

CREATE TRIGGER check_cons_bi
   BEFORE INSERT
   ON check_cons FOR EACH ROW
begin

   -- Trigger Check_Cons_Bi
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:33:59 PM

   -- util.log('Trigger check_cons_bi');
   if glob.get_db_constraints
   then
      check_cons_tab.ins
         (:new.id
         ,:new.table_id
         ,:new.seq
         ,:new.text
         ,:new.description
         );
   end if;
end check_cons_bi;
/
select 'CHECK_CONS_BI' as "Trigger:"
 from  user_errors
 where name = 'CHECK_CONS_BI'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'CHECK_CONS_BI'
  and  type = 'TRIGGER'
 order by sequence;

CREATE TRIGGER check_cons_bu
   BEFORE UPDATE
   ON check_cons FOR EACH ROW
begin

   -- Trigger Check_Cons_Bu
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:33:59 PM

   -- util.log('Trigger check_cons_bu');
   if glob.get_db_constraints
   then
      check_cons_tab.upd
         (:old.id
         ,:old.table_id
         ,:new.table_id
         ,:old.seq
         ,:new.seq
         ,:old.text
         ,:new.text
         ,:old.description
         ,:new.description
         );
   end if;
end check_cons_bu;
/
select 'CHECK_CONS_BU' as "Trigger:"
 from  user_errors
 where name = 'CHECK_CONS_BU'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'CHECK_CONS_BU'
  and  type = 'TRIGGER'
 order by sequence;

CREATE TRIGGER check_cons_bd
   BEFORE DELETE
   ON check_cons FOR EACH ROW
begin

   -- Trigger Check_Cons_Bd
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:33:59 PM

   -- util.log('Trigger check_cons_bd');
   if glob.get_db_constraints
   then
      check_cons_tab.del
         (:old.id
         ,:old.table_id
         ,:old.seq
         ,:old.text
         ,:old.description
         );
   end if;
end check_cons_bd;
/
select 'CHECK_CONS_BD' as "Trigger:"
 from  user_errors
 where name = 'CHECK_CONS_BD'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'CHECK_CONS_BD'
  and  type = 'TRIGGER'
 order by sequence;

----------------------------------------
select '***  programs  ***' as TABLE_NAME from dual;
----------------------------------------

alter table programs modify application_id
   constraint programs_nn1 not null;
alter table programs modify name
   constraint programs_nn2 not null;
alter table programs modify type
   constraint programs_nn3 not null;
alter table programs add constraint programs_ck1
   check (instr(name,' ') = 0);
alter table programs add constraint programs_fld1
   check (name = lower(name));
alter table programs add constraint programs_dm1
   check (type in ('PACKAGE', 'FUNCTION', 'PROCEDURE'));

CREATE TRIGGER programs_bi
   BEFORE INSERT
   ON programs FOR EACH ROW
begin

   -- Trigger Programs_Bi
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:33:59 PM

   -- util.log('Trigger programs_bi');
   if glob.get_db_constraints
   then
      programs_tab.ins
         (:new.id
         ,:new.application_id
         ,:new.name
         ,:new.type
         ,:new.description
         );
   end if;
end programs_bi;
/
select 'PROGRAMS_BI' as "Trigger:"
 from  user_errors
 where name = 'PROGRAMS_BI'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'PROGRAMS_BI'
  and  type = 'TRIGGER'
 order by sequence;

CREATE TRIGGER programs_bu
   BEFORE UPDATE
   ON programs FOR EACH ROW
begin

   -- Trigger Programs_Bu
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:33:59 PM

   -- util.log('Trigger programs_bu');
   if glob.get_db_constraints
   then
      programs_tab.upd
         (:old.id
         ,:old.application_id
         ,:new.application_id
         ,:old.name
         ,:new.name
         ,:old.type
         ,:new.type
         ,:old.description
         ,:new.description
         );
   end if;
end programs_bu;
/
select 'PROGRAMS_BU' as "Trigger:"
 from  user_errors
 where name = 'PROGRAMS_BU'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'PROGRAMS_BU'
  and  type = 'TRIGGER'
 order by sequence;

CREATE TRIGGER programs_bd
   BEFORE DELETE
   ON programs FOR EACH ROW
begin

   -- Trigger Programs_Bd
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:33:59 PM

   -- util.log('Trigger programs_bd');
   if glob.get_db_constraints
   then
      programs_tab.del
         (:old.id
         ,:old.application_id
         ,:old.name
         ,:old.type
         ,:old.description
         );
   end if;
end programs_bd;
/
select 'PROGRAMS_BD' as "Trigger:"
 from  user_errors
 where name = 'PROGRAMS_BD'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'PROGRAMS_BD'
  and  type = 'TRIGGER'
 order by sequence;

----------------------------------------
select '***  exceptions  ***' as TABLE_NAME from dual;
----------------------------------------

alter table exceptions modify application_id
   constraint exceptions_nn1 not null;
alter table exceptions modify code
   constraint exceptions_nn2 not null;
alter table exceptions modify name
   constraint exceptions_nn3 not null;
alter table exceptions add constraint exceptions_ck1
   check (code between -20999 and -20000);
alter table exceptions add constraint exceptions_ck2
   check (instr(name,' ') = 0);
alter table exceptions add constraint exceptions_fld1
   check (name = lower(name));

CREATE TRIGGER exceptions_bi
   BEFORE INSERT
   ON exceptions FOR EACH ROW
begin

   -- Trigger Exceptions_Bi
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:33:59 PM

   -- util.log('Trigger exceptions_bi');
   if glob.get_db_constraints
   then
      exceptions_tab.ins
         (:new.id
         ,:new.application_id
         ,:new.code
         ,:new.name
         ,:new.message
         ,:new.cause
         ,:new.action
         );
   end if;
end exceptions_bi;
/
select 'EXCEPTIONS_BI' as "Trigger:"
 from  user_errors
 where name = 'EXCEPTIONS_BI'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'EXCEPTIONS_BI'
  and  type = 'TRIGGER'
 order by sequence;

CREATE TRIGGER exceptions_bu
   BEFORE UPDATE
   ON exceptions FOR EACH ROW
begin

   -- Trigger Exceptions_Bu
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:33:59 PM

   -- util.log('Trigger exceptions_bu');
   if glob.get_db_constraints
   then
      exceptions_tab.upd
         (:old.id
         ,:old.application_id
         ,:new.application_id
         ,:old.code
         ,:new.code
         ,:old.name
         ,:new.name
         ,:old.message
         ,:new.message
         ,:old.cause
         ,:new.cause
         ,:old.action
         ,:new.action
         );
   end if;
end exceptions_bu;
/
select 'EXCEPTIONS_BU' as "Trigger:"
 from  user_errors
 where name = 'EXCEPTIONS_BU'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'EXCEPTIONS_BU'
  and  type = 'TRIGGER'
 order by sequence;

CREATE TRIGGER exceptions_bd
   BEFORE DELETE
   ON exceptions FOR EACH ROW
begin

   -- Trigger Exceptions_Bd
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:00 PM

   -- util.log('Trigger exceptions_bd');
   if glob.get_db_constraints
   then
      exceptions_tab.del
         (:old.id
         ,:old.application_id
         ,:old.code
         ,:old.name
         ,:old.message
         ,:old.cause
         ,:old.action
         );
   end if;
end exceptions_bd;
/
select 'EXCEPTIONS_BD' as "Trigger:"
 from  user_errors
 where name = 'EXCEPTIONS_BD'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'EXCEPTIONS_BD'
  and  type = 'TRIGGER'
 order by sequence;



select ' -) create_oltp  ' as FILE_NAME from dual;


-- Script File "create_oltp"
--    Create Online Transaction Processing using generated code
--
--    Generated by DTGen (http://code.google.com/p/dtgen)
--    July      27, 2012  09:34:12 PM


----------------------------------------
select '***  applications  ***' as TABLE_NAME from dual;
----------------------------------------

create package applications_view
is

   -- Package Applications_View
   --    View functions
   --    (DML, Foreign Keys, Paths, and )
   --
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:12 PM

   procedure ins
      (n_id  in out  NUMBER
      ,n_abbr  in out  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,n_db_schema  in out  VARCHAR2
      ,n_db_schema_exp  in out  VARCHAR2
      ,n_apex_schema  in out  VARCHAR2
      ,n_apex_ws_name  in out  VARCHAR2
      ,n_apex_app_name  in out  VARCHAR2
      ,n_dbid  in out  VARCHAR2
      ,n_db_auth  in out  VARCHAR2
      ,n_description  in out  VARCHAR2
      ,n_ts_null_override  in out  VARCHAR2
      ,n_ts_onln_data  in out  VARCHAR2
      ,n_ts_onln_indx  in out  VARCHAR2
      ,n_ts_hist_data  in out  VARCHAR2
      ,n_ts_hist_indx  in out  VARCHAR2
      ,n_usr_datatype  in out  VARCHAR2
      ,n_usr_frgn_key  in out  VARCHAR2
      ,n_copyright  in out  VARCHAR2
      );
   procedure upd
      (o_id  in  NUMBER
      ,o_abbr  in  VARCHAR2
      ,n_abbr  in out  VARCHAR2
      ,o_name  in  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,o_db_schema  in  VARCHAR2
      ,n_db_schema  in out  VARCHAR2
      ,o_db_schema_exp  in  VARCHAR2
      ,n_db_schema_exp  in out  VARCHAR2
      ,o_apex_schema  in  VARCHAR2
      ,n_apex_schema  in out  VARCHAR2
      ,o_apex_ws_name  in  VARCHAR2
      ,n_apex_ws_name  in out  VARCHAR2
      ,o_apex_app_name  in  VARCHAR2
      ,n_apex_app_name  in out  VARCHAR2
      ,o_dbid  in  VARCHAR2
      ,n_dbid  in out  VARCHAR2
      ,o_db_auth  in  VARCHAR2
      ,n_db_auth  in out  VARCHAR2
      ,o_description  in  VARCHAR2
      ,n_description  in out  VARCHAR2
      ,o_ts_null_override  in  VARCHAR2
      ,n_ts_null_override  in out  VARCHAR2
      ,o_ts_onln_data  in  VARCHAR2
      ,n_ts_onln_data  in out  VARCHAR2
      ,o_ts_onln_indx  in  VARCHAR2
      ,n_ts_onln_indx  in out  VARCHAR2
      ,o_ts_hist_data  in  VARCHAR2
      ,n_ts_hist_data  in out  VARCHAR2
      ,o_ts_hist_indx  in  VARCHAR2
      ,n_ts_hist_indx  in out  VARCHAR2
      ,o_usr_datatype  in  VARCHAR2
      ,n_usr_datatype  in out  VARCHAR2
      ,o_usr_frgn_key  in  VARCHAR2
      ,n_usr_frgn_key  in out  VARCHAR2
      ,o_copyright  in  VARCHAR2
      ,n_copyright  in out  VARCHAR2
      );
   procedure del
      (o_id  in  NUMBER
      ,o_abbr  in  VARCHAR2
      ,o_name  in  VARCHAR2
      ,o_db_schema  in  VARCHAR2
      ,o_db_schema_exp  in  VARCHAR2
      ,o_apex_schema  in  VARCHAR2
      ,o_apex_ws_name  in  VARCHAR2
      ,o_apex_app_name  in  VARCHAR2
      ,o_dbid  in  VARCHAR2
      ,o_db_auth  in  VARCHAR2
      ,o_description  in  VARCHAR2
      ,o_ts_null_override  in  VARCHAR2
      ,o_ts_onln_data  in  VARCHAR2
      ,o_ts_onln_indx  in  VARCHAR2
      ,o_ts_hist_data  in  VARCHAR2
      ,o_ts_hist_indx  in  VARCHAR2
      ,o_usr_datatype  in  VARCHAR2
      ,o_usr_frgn_key  in  VARCHAR2
      ,o_copyright  in  VARCHAR2
      );
end applications_view;
/
select 'APPLICATIONS_VIEW' as "Package:"
 from  user_errors
 where name = 'APPLICATIONS_VIEW'
  and  type = 'PACKAGE'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'APPLICATIONS_VIEW'
  and  type = 'PACKAGE'
 order by sequence;

create package applications_dml
is

   -- Package Applications_Dml
   -- (Data Manipulation Language, Foreign Key and Path Lookup)

   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:12 PM

   function get_next_id
      return number;
   function get_curr_id
      return number;

   function get_id
      (applications_nk1  in  VARCHAR2
      ) return number;
   function get_nk
      (id_in  in  number
      ) return varchar2;

   function tab_to_col
         (id_in  in  number)
      return col_type;

   procedure ins
      (n_id  in out  NUMBER
      ,n_abbr  in out  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,n_db_schema  in out  VARCHAR2
      ,n_db_schema_exp  in out  VARCHAR2
      ,n_apex_schema  in out  VARCHAR2
      ,n_apex_ws_name  in out  VARCHAR2
      ,n_apex_app_name  in out  VARCHAR2
      ,n_dbid  in out  VARCHAR2
      ,n_db_auth  in out  VARCHAR2
      ,n_description  in out  VARCHAR2
      ,n_ts_null_override  in out  VARCHAR2
      ,n_ts_onln_data  in out  VARCHAR2
      ,n_ts_onln_indx  in out  VARCHAR2
      ,n_ts_hist_data  in out  VARCHAR2
      ,n_ts_hist_indx  in out  VARCHAR2
      ,n_usr_datatype  in out  VARCHAR2
      ,n_usr_frgn_key  in out  VARCHAR2
      ,n_copyright  in out  VARCHAR2
      );
   procedure upd
      (o_id_in  in  NUMBER
      ,n_abbr  in out  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,n_db_schema  in out  VARCHAR2
      ,n_db_schema_exp  in out  VARCHAR2
      ,n_apex_schema  in out  VARCHAR2
      ,n_apex_ws_name  in out  VARCHAR2
      ,n_apex_app_name  in out  VARCHAR2
      ,n_dbid  in out  VARCHAR2
      ,n_db_auth  in out  VARCHAR2
      ,n_description  in out  VARCHAR2
      ,n_ts_null_override  in out  VARCHAR2
      ,n_ts_onln_data  in out  VARCHAR2
      ,n_ts_onln_indx  in out  VARCHAR2
      ,n_ts_hist_data  in out  VARCHAR2
      ,n_ts_hist_indx  in out  VARCHAR2
      ,n_usr_datatype  in out  VARCHAR2
      ,n_usr_frgn_key  in out  VARCHAR2
      ,n_copyright  in out  VARCHAR2
      );
   procedure del
      (o_id_in  in  NUMBER
      );
end applications_dml;
/
select 'APPLICATIONS_DML' as "Package:"
 from  user_errors
 where name = 'APPLICATIONS_DML'
  and  type = 'PACKAGE'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'APPLICATIONS_DML'
  and  type = 'PACKAGE'
 order by sequence;

create view applications_act
      (id
      ,abbr
      ,name
      ,db_schema
      ,db_schema_exp
      ,apex_schema
      ,apex_ws_name
      ,apex_app_name
      ,dbid
      ,db_auth
      ,description
      ,ts_null_override
      ,ts_onln_data
      ,ts_onln_indx
      ,ts_hist_data
      ,ts_hist_indx
      ,usr_datatype
      ,usr_frgn_key
      ,copyright
      )
   as select
       APP.id
      ,APP.abbr
      ,APP.name
      ,APP.db_schema
      ,APP.db_schema_exp
      ,APP.apex_schema
      ,APP.apex_ws_name
      ,APP.apex_app_name
      ,APP.dbid
      ,APP.db_auth
      ,APP.description
      ,APP.ts_null_override
      ,APP.ts_onln_data
      ,APP.ts_onln_indx
      ,APP.ts_hist_data
      ,APP.ts_hist_indx
      ,APP.usr_datatype
      ,APP.usr_frgn_key
      ,APP.copyright
 from             applications APP
 ;
select 'APPLICATIONS_ACT' as "View:"
 from  user_errors
 where name = 'APPLICATIONS_ACT'
  and  type = 'VIEW'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'APPLICATIONS_ACT'
  and  type = 'VIEW'
 order by sequence;

comment on table applications_act is 'Applications to be generated';

comment on column applications_act.id is 'Surrogate Primary Key for these applications_act';
comment on column applications_act.abbr is 'Abbreviation for this application';
comment on column applications_act.name is 'Name of this application';
comment on column applications_act.db_schema is 'Name of the database schema objects owner. Used for user synonym and DB Link creation. Also used for explicit owner of all database objects if db_schema_exp flag is set.';
comment on column applications_act.db_schema_exp is 'Explicitly define the schema owner for all database object';
comment on column applications_act.apex_schema is 'Name of the APEX parsing schema owner for the generated APEX pages';
comment on column applications_act.apex_ws_name is 'Workspace name (Upper Case) for the generated APEX pages';
comment on column applications_act.apex_app_name is 'Application name (Mixed Case) for the generated APEX pages';
comment on column applications_act.dbid is 'Database link connect string for mid-tier connections to the centralized database server.';
comment on column applications_act.db_auth is 'Database link authorization for mid-tier connections to the centralized database server';
comment on column applications_act.description is 'Description of this application';
comment on column applications_act.ts_null_override is 'Flag to override all tablespace names to null';
comment on column applications_act.ts_onln_data is 'Default tableapace name for on-line data tables';
comment on column applications_act.ts_onln_indx is 'Default tablespace name for on-line indexes';
comment on column applications_act.ts_hist_data is 'Default tablespace name for history data tables';
comment on column applications_act.ts_hist_indx is 'Default tablespace name for history indexes';
comment on column applications_act.usr_datatype is 'Datatype for the "_USR" data columns in history tables tables. The default value is VARCHAR2(30).';
comment on column applications_act.usr_frgn_key is 'Foreign Key for the "_USR" data columns in history tables. Must be of the form "table", "schema.table", "table(column)",  or "schema.table(column)".';
comment on column applications_act.copyright is 'Copyright notice that is placed in the comment header in all generated scripts';

alter view applications_act add constraint applications_act_pk
   primary key (id) disable;


create TRIGGER applications_ioi
   instead of insert on applications_act
   for each row
declare
   n_id  NUMBER(38);
   n_abbr  VARCHAR2(5);
   n_name  VARCHAR2(30);
   n_db_schema  VARCHAR2(30);
   n_db_schema_exp  VARCHAR2(1);
   n_apex_schema  VARCHAR2(30);
   n_apex_ws_name  VARCHAR2(30);
   n_apex_app_name  VARCHAR2(30);
   n_dbid  VARCHAR2(2000);
   n_db_auth  VARCHAR2(200);
   n_description  VARCHAR2(1000);
   n_ts_null_override  VARCHAR2(1);
   n_ts_onln_data  VARCHAR2(30);
   n_ts_onln_indx  VARCHAR2(30);
   n_ts_hist_data  VARCHAR2(30);
   n_ts_hist_indx  VARCHAR2(30);
   n_usr_datatype  VARCHAR2(20);
   n_usr_frgn_key  VARCHAR2(100);
   n_copyright  VARCHAR2(32000);
begin

   -- Trigger Applications_Ioi
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:13 PM

   n_id := :new.id;
   n_abbr := :new.abbr;
   n_name := :new.name;
   n_db_schema := :new.db_schema;
   n_db_schema_exp := :new.db_schema_exp;
   n_apex_schema := :new.apex_schema;
   n_apex_ws_name := :new.apex_ws_name;
   n_apex_app_name := :new.apex_app_name;
   n_dbid := :new.dbid;
   n_db_auth := :new.db_auth;
   n_description := :new.description;
   n_ts_null_override := :new.ts_null_override;
   n_ts_onln_data := :new.ts_onln_data;
   n_ts_onln_indx := :new.ts_onln_indx;
   n_ts_hist_data := :new.ts_hist_data;
   n_ts_hist_indx := :new.ts_hist_indx;
   n_usr_datatype := :new.usr_datatype;
   n_usr_frgn_key := :new.usr_frgn_key;
   n_copyright := :new.copyright;
   applications_view.ins
      (n_id
      ,n_abbr
      ,n_name
      ,n_db_schema
      ,n_db_schema_exp
      ,n_apex_schema
      ,n_apex_ws_name
      ,n_apex_app_name
      ,n_dbid
      ,n_db_auth
      ,n_description
      ,n_ts_null_override
      ,n_ts_onln_data
      ,n_ts_onln_indx
      ,n_ts_hist_data
      ,n_ts_hist_indx
      ,n_usr_datatype
      ,n_usr_frgn_key
      ,n_copyright
      );
end applications_ioi;
/
select 'APPLICATIONS_IOI' as "Trigger:"
 from  user_errors
 where name = 'APPLICATIONS_IOI'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'APPLICATIONS_IOI'
  and  type = 'TRIGGER'
 order by sequence;

create TRIGGER applications_iou
   instead of update on applications_act
   for each row
declare
   n_abbr  VARCHAR2(5);
   n_name  VARCHAR2(30);
   n_db_schema  VARCHAR2(30);
   n_db_schema_exp  VARCHAR2(1);
   n_apex_schema  VARCHAR2(30);
   n_apex_ws_name  VARCHAR2(30);
   n_apex_app_name  VARCHAR2(30);
   n_dbid  VARCHAR2(2000);
   n_db_auth  VARCHAR2(200);
   n_description  VARCHAR2(1000);
   n_ts_null_override  VARCHAR2(1);
   n_ts_onln_data  VARCHAR2(30);
   n_ts_onln_indx  VARCHAR2(30);
   n_ts_hist_data  VARCHAR2(30);
   n_ts_hist_indx  VARCHAR2(30);
   n_usr_datatype  VARCHAR2(20);
   n_usr_frgn_key  VARCHAR2(100);
   n_copyright  VARCHAR2(32000);
begin

   -- Trigger Applications_Iou
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:13 PM

   n_abbr := :new.abbr;
   n_name := :new.name;
   n_db_schema := :new.db_schema;
   n_db_schema_exp := :new.db_schema_exp;
   n_apex_schema := :new.apex_schema;
   n_apex_ws_name := :new.apex_ws_name;
   n_apex_app_name := :new.apex_app_name;
   n_dbid := :new.dbid;
   n_db_auth := :new.db_auth;
   n_description := :new.description;
   n_ts_null_override := :new.ts_null_override;
   n_ts_onln_data := :new.ts_onln_data;
   n_ts_onln_indx := :new.ts_onln_indx;
   n_ts_hist_data := :new.ts_hist_data;
   n_ts_hist_indx := :new.ts_hist_indx;
   n_usr_datatype := :new.usr_datatype;
   n_usr_frgn_key := :new.usr_frgn_key;
   n_copyright := :new.copyright;
   applications_view.upd
      (:old.id
      ,:old.abbr
      ,n_abbr
      ,:old.name
      ,n_name
      ,:old.db_schema
      ,n_db_schema
      ,:old.db_schema_exp
      ,n_db_schema_exp
      ,:old.apex_schema
      ,n_apex_schema
      ,:old.apex_ws_name
      ,n_apex_ws_name
      ,:old.apex_app_name
      ,n_apex_app_name
      ,:old.dbid
      ,n_dbid
      ,:old.db_auth
      ,n_db_auth
      ,:old.description
      ,n_description
      ,:old.ts_null_override
      ,n_ts_null_override
      ,:old.ts_onln_data
      ,n_ts_onln_data
      ,:old.ts_onln_indx
      ,n_ts_onln_indx
      ,:old.ts_hist_data
      ,n_ts_hist_data
      ,:old.ts_hist_indx
      ,n_ts_hist_indx
      ,:old.usr_datatype
      ,n_usr_datatype
      ,:old.usr_frgn_key
      ,n_usr_frgn_key
      ,:old.copyright
      ,n_copyright
      );
end applications_iou;
/
select 'APPLICATIONS_IOU' as "Trigger:"
 from  user_errors
 where name = 'APPLICATIONS_IOU'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'APPLICATIONS_IOU'
  and  type = 'TRIGGER'
 order by sequence;

create TRIGGER applications_iod
   instead of delete on applications_act
   for each row
begin

   -- Trigger Applications_Iod
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:13 PM

   applications_view.del
      (:old.id
      ,:old.abbr
      ,:old.name
      ,:old.db_schema
      ,:old.db_schema_exp
      ,:old.apex_schema
      ,:old.apex_ws_name
      ,:old.apex_app_name
      ,:old.dbid
      ,:old.db_auth
      ,:old.description
      ,:old.ts_null_override
      ,:old.ts_onln_data
      ,:old.ts_onln_indx
      ,:old.ts_hist_data
      ,:old.ts_hist_indx
      ,:old.usr_datatype
      ,:old.usr_frgn_key
      ,:old.copyright
      );
end applications_iod;
/
select 'APPLICATIONS_IOD' as "Trigger:"
 from  user_errors
 where name = 'APPLICATIONS_IOD'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'APPLICATIONS_IOD'
  and  type = 'TRIGGER'
 order by sequence;

create package body applications_view
is

-- Package Body Applications_View
--    View functions
--    (DML, Foreign Keys, Paths, and )
--
--    Generated by DTGen (http://code.google.com/p/dtgen)
--    July      27, 2012  09:34:13 PM

----------------------------------------
procedure ins
      (n_id  in out  NUMBER
      ,n_abbr  in out  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,n_db_schema  in out  VARCHAR2
      ,n_db_schema_exp  in out  VARCHAR2
      ,n_apex_schema  in out  VARCHAR2
      ,n_apex_ws_name  in out  VARCHAR2
      ,n_apex_app_name  in out  VARCHAR2
      ,n_dbid  in out  VARCHAR2
      ,n_db_auth  in out  VARCHAR2
      ,n_description  in out  VARCHAR2
      ,n_ts_null_override  in out  VARCHAR2
      ,n_ts_onln_data  in out  VARCHAR2
      ,n_ts_onln_indx  in out  VARCHAR2
      ,n_ts_hist_data  in out  VARCHAR2
      ,n_ts_hist_indx  in out  VARCHAR2
      ,n_usr_datatype  in out  VARCHAR2
      ,n_usr_frgn_key  in out  VARCHAR2
      ,n_copyright  in out  VARCHAR2
      )
   -- View insert procedure
is
begin
   if util.db_object_exists('APPLICATIONS', 'MATERIALIZED VIEW')
   then
      raise_application_error(-20010, 'Insert not allowed on materialized view applications.  Inserts on applications must be performed on the central database.');
   end if;
   if not glob.get_db_constraints
   then
      applications_tab.ins
         (n_id
         ,n_abbr
         ,n_name
         ,n_db_schema
         ,n_db_schema_exp
         ,n_apex_schema
         ,n_apex_ws_name
         ,n_apex_app_name
         ,n_dbid
         ,n_db_auth
         ,n_description
         ,n_ts_null_override
         ,n_ts_onln_data
         ,n_ts_onln_indx
         ,n_ts_hist_data
         ,n_ts_hist_indx
         ,n_usr_datatype
         ,n_usr_frgn_key
         ,n_copyright
         );
   end if;
   insert into applications
         (id
         ,abbr
         ,name
         ,db_schema
         ,db_schema_exp
         ,apex_schema
         ,apex_ws_name
         ,apex_app_name
         ,dbid
         ,db_auth
         ,description
         ,ts_null_override
         ,ts_onln_data
         ,ts_onln_indx
         ,ts_hist_data
         ,ts_hist_indx
         ,usr_datatype
         ,usr_frgn_key
         ,copyright
         )
   values
         (n_id
         ,n_abbr
         ,n_name
         ,n_db_schema
         ,n_db_schema_exp
         ,n_apex_schema
         ,n_apex_ws_name
         ,n_apex_app_name
         ,n_dbid
         ,n_db_auth
         ,n_description
         ,n_ts_null_override
         ,n_ts_onln_data
         ,n_ts_onln_indx
         ,n_ts_hist_data
         ,n_ts_hist_indx
         ,n_usr_datatype
         ,n_usr_frgn_key
         ,n_copyright
         );
end ins;
----------------------------------------
procedure upd
      (o_id  in  NUMBER
      ,o_abbr  in  VARCHAR2
      ,n_abbr  in out  VARCHAR2
      ,o_name  in  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,o_db_schema  in  VARCHAR2
      ,n_db_schema  in out  VARCHAR2
      ,o_db_schema_exp  in  VARCHAR2
      ,n_db_schema_exp  in out  VARCHAR2
      ,o_apex_schema  in  VARCHAR2
      ,n_apex_schema  in out  VARCHAR2
      ,o_apex_ws_name  in  VARCHAR2
      ,n_apex_ws_name  in out  VARCHAR2
      ,o_apex_app_name  in  VARCHAR2
      ,n_apex_app_name  in out  VARCHAR2
      ,o_dbid  in  VARCHAR2
      ,n_dbid  in out  VARCHAR2
      ,o_db_auth  in  VARCHAR2
      ,n_db_auth  in out  VARCHAR2
      ,o_description  in  VARCHAR2
      ,n_description  in out  VARCHAR2
      ,o_ts_null_override  in  VARCHAR2
      ,n_ts_null_override  in out  VARCHAR2
      ,o_ts_onln_data  in  VARCHAR2
      ,n_ts_onln_data  in out  VARCHAR2
      ,o_ts_onln_indx  in  VARCHAR2
      ,n_ts_onln_indx  in out  VARCHAR2
      ,o_ts_hist_data  in  VARCHAR2
      ,n_ts_hist_data  in out  VARCHAR2
      ,o_ts_hist_indx  in  VARCHAR2
      ,n_ts_hist_indx  in out  VARCHAR2
      ,o_usr_datatype  in  VARCHAR2
      ,n_usr_datatype  in out  VARCHAR2
      ,o_usr_frgn_key  in  VARCHAR2
      ,n_usr_frgn_key  in out  VARCHAR2
      ,o_copyright  in  VARCHAR2
      ,n_copyright  in out  VARCHAR2
      )
   -- View Update procedure
is
begin
   if util.db_object_exists('APPLICATIONS', 'MATERIALIZED VIEW')
   then
      raise_application_error(-20010, 'Update not allowed on materialized view applications.  Updates on applications must be performed on the central database.');
   end if;
   if not glob.get_db_constraints
   then
      applications_tab.upd
         (o_id
         ,o_abbr
         ,n_abbr
         ,o_name
         ,n_name
         ,o_db_schema
         ,n_db_schema
         ,o_db_schema_exp
         ,n_db_schema_exp
         ,o_apex_schema
         ,n_apex_schema
         ,o_apex_ws_name
         ,n_apex_ws_name
         ,o_apex_app_name
         ,n_apex_app_name
         ,o_dbid
         ,n_dbid
         ,o_db_auth
         ,n_db_auth
         ,o_description
         ,n_description
         ,o_ts_null_override
         ,n_ts_null_override
         ,o_ts_onln_data
         ,n_ts_onln_data
         ,o_ts_onln_indx
         ,n_ts_onln_indx
         ,o_ts_hist_data
         ,n_ts_hist_data
         ,o_ts_hist_indx
         ,n_ts_hist_indx
         ,o_usr_datatype
         ,n_usr_datatype
         ,o_usr_frgn_key
         ,n_usr_frgn_key
         ,o_copyright
         ,n_copyright
         );
   end if;
   update applications APP
     set  APP.abbr = n_abbr
         ,APP.name = n_name
         ,APP.db_schema = n_db_schema
         ,APP.db_schema_exp = n_db_schema_exp
         ,APP.apex_schema = n_apex_schema
         ,APP.apex_ws_name = n_apex_ws_name
         ,APP.apex_app_name = n_apex_app_name
         ,APP.dbid = n_dbid
         ,APP.db_auth = n_db_auth
         ,APP.description = n_description
         ,APP.ts_null_override = n_ts_null_override
         ,APP.ts_onln_data = n_ts_onln_data
         ,APP.ts_onln_indx = n_ts_onln_indx
         ,APP.ts_hist_data = n_ts_hist_data
         ,APP.ts_hist_indx = n_ts_hist_indx
         ,APP.usr_datatype = n_usr_datatype
         ,APP.usr_frgn_key = n_usr_frgn_key
         ,APP.copyright = n_copyright
    where APP.id = o_id;
end upd;
----------------------------------------
procedure del
      (o_id  in  NUMBER
      ,o_abbr  in  VARCHAR2
      ,o_name  in  VARCHAR2
      ,o_db_schema  in  VARCHAR2
      ,o_db_schema_exp  in  VARCHAR2
      ,o_apex_schema  in  VARCHAR2
      ,o_apex_ws_name  in  VARCHAR2
      ,o_apex_app_name  in  VARCHAR2
      ,o_dbid  in  VARCHAR2
      ,o_db_auth  in  VARCHAR2
      ,o_description  in  VARCHAR2
      ,o_ts_null_override  in  VARCHAR2
      ,o_ts_onln_data  in  VARCHAR2
      ,o_ts_onln_indx  in  VARCHAR2
      ,o_ts_hist_data  in  VARCHAR2
      ,o_ts_hist_indx  in  VARCHAR2
      ,o_usr_datatype  in  VARCHAR2
      ,o_usr_frgn_key  in  VARCHAR2
      ,o_copyright  in  VARCHAR2
      )
is
begin
   if util.db_object_exists('APPLICATIONS', 'MATERIALIZED VIEW')
   then
      raise_application_error(-20010, 'Delete not allowed on materialized view applications.  Deletes on applications must be performed on the central database.');
   end if;
   if not glob.get_db_constraints
   then
      applications_tab.del
         (o_id
         ,o_abbr
         ,o_name
         ,o_db_schema
         ,o_db_schema_exp
         ,o_apex_schema
         ,o_apex_ws_name
         ,o_apex_app_name
         ,o_dbid
         ,o_db_auth
         ,o_description
         ,o_ts_null_override
         ,o_ts_onln_data
         ,o_ts_onln_indx
         ,o_ts_hist_data
         ,o_ts_hist_indx
         ,o_usr_datatype
         ,o_usr_frgn_key
         ,o_copyright
         );
   end if;
   delete from applications  APP
    where APP.id = o_id;
end del;
----------------------------------------
end applications_view;
/
select 'APPLICATIONS_VIEW' as "Package Body:"
 from  user_errors
 where name = 'APPLICATIONS_VIEW'
  and  type = 'PACKAGE BODY'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'APPLICATIONS_VIEW'
  and  type = 'PACKAGE BODY'
 order by sequence;

create package body applications_dml
is

 -- Package Body Applications_Dml
 -- (Data Manipulation Language, Foreign Key and Path Lookup)

 --    Generated by DTGen (http://code.google.com/p/dtgen)
 --    July      27, 2012  09:34:14 PM

----------------------------------------
function get_next_id
      return number
is
   retid  number;
begin
   select applications_seq.nextval into retid from dual;
   return retid;
end get_next_id;
----------------------------------------
function get_curr_id
      return number
is
   retid  number;
begin
   select applications_seq.currval into retid from dual;
   return retid;
end get_curr_id;
----------------------------------------
function get_id
      (applications_nk1  in  VARCHAR2
      ) return number
   -- For all the Natural Key Columns, Return an ID
is
   retid  number(38);
begin
   select id
    into  retid
    from  applications  APP
    where APP.abbr = applications_nk1
    ;
   return retid;
exception
   when no_data_found
   then
      return null;
   when others
   then
      raise;
end get_id;
----------------------------------------
function get_nk
      (id_in  in  number)
   return varchar2
   -- For an ID, return a delimited list of Natural Key Values
is
   rtxt  varchar2(32767);
begin
   select substr(   APP.abbr
                         ,1,32767)
    into  rtxt
    from  applications APP
    where APP.id = id_in;
   return rtxt;
exception
   when no_data_found then
      return null;
   when others then
      raise;
end get_nk;
----------------------------------------
function tab_to_col
      (id_in  in  number)
   return col_type
is
   -- This function is duplicated in applications_POP
   cursor acur is
      select * from applications
       where id = id_in;
   abuf   acur%ROWTYPE;
   rcol      col_type;
begin
   open acur;
   fetch acur into abuf;
   if acur%NOTFOUND
   then
      rcol := COL_TYPE(null);
      close acur;
      return rcol;
   end if;
   rcol := COL_TYPE
             (PAIR_TYPE('abbr', abuf.abbr)
             ,PAIR_TYPE('name', abuf.name)
             ,PAIR_TYPE('db_schema', abuf.db_schema)
             ,PAIR_TYPE('db_schema_exp', abuf.db_schema_exp)
             ,PAIR_TYPE('apex_schema', abuf.apex_schema)
             ,PAIR_TYPE('apex_ws_name', abuf.apex_ws_name)
             ,PAIR_TYPE('apex_app_name', abuf.apex_app_name)
             ,PAIR_TYPE('dbid', abuf.dbid)
             ,PAIR_TYPE('db_auth', abuf.db_auth)
             ,PAIR_TYPE('description', abuf.description)
             ,PAIR_TYPE('ts_null_override', abuf.ts_null_override)
             ,PAIR_TYPE('ts_onln_data', abuf.ts_onln_data)
             ,PAIR_TYPE('ts_onln_indx', abuf.ts_onln_indx)
             ,PAIR_TYPE('ts_hist_data', abuf.ts_hist_data)
             ,PAIR_TYPE('ts_hist_indx', abuf.ts_hist_indx)
             ,PAIR_TYPE('usr_datatype', abuf.usr_datatype)
             ,PAIR_TYPE('usr_frgn_key', abuf.usr_frgn_key)
             ,PAIR_TYPE('copyright', abuf.copyright)
                );
   close acur;
   return rcol;
end tab_to_col;
----------------------------------------
procedure ins
      (n_id  in out  NUMBER
      ,n_abbr  in out  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,n_db_schema  in out  VARCHAR2
      ,n_db_schema_exp  in out  VARCHAR2
      ,n_apex_schema  in out  VARCHAR2
      ,n_apex_ws_name  in out  VARCHAR2
      ,n_apex_app_name  in out  VARCHAR2
      ,n_dbid  in out  VARCHAR2
      ,n_db_auth  in out  VARCHAR2
      ,n_description  in out  VARCHAR2
      ,n_ts_null_override  in out  VARCHAR2
      ,n_ts_onln_data  in out  VARCHAR2
      ,n_ts_onln_indx  in out  VARCHAR2
      ,n_ts_hist_data  in out  VARCHAR2
      ,n_ts_hist_indx  in out  VARCHAR2
      ,n_usr_datatype  in out  VARCHAR2
      ,n_usr_frgn_key  in out  VARCHAR2
      ,n_copyright  in out  VARCHAR2
      )
   -- Application Insert procedure
is
begin
   applications_view.ins
      (n_id
      ,n_abbr
      ,n_name
      ,n_db_schema
      ,n_db_schema_exp
      ,n_apex_schema
      ,n_apex_ws_name
      ,n_apex_app_name
      ,n_dbid
      ,n_db_auth
      ,n_description
      ,n_ts_null_override
      ,n_ts_onln_data
      ,n_ts_onln_indx
      ,n_ts_hist_data
      ,n_ts_hist_indx
      ,n_usr_datatype
      ,n_usr_frgn_key
      ,n_copyright
      );
end ins;
----------------------------------------
procedure upd
      (o_id_in  in  NUMBER
      ,n_abbr  in out  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,n_db_schema  in out  VARCHAR2
      ,n_db_schema_exp  in out  VARCHAR2
      ,n_apex_schema  in out  VARCHAR2
      ,n_apex_ws_name  in out  VARCHAR2
      ,n_apex_app_name  in out  VARCHAR2
      ,n_dbid  in out  VARCHAR2
      ,n_db_auth  in out  VARCHAR2
      ,n_description  in out  VARCHAR2
      ,n_ts_null_override  in out  VARCHAR2
      ,n_ts_onln_data  in out  VARCHAR2
      ,n_ts_onln_indx  in out  VARCHAR2
      ,n_ts_hist_data  in out  VARCHAR2
      ,n_ts_hist_indx  in out  VARCHAR2
      ,n_usr_datatype  in out  VARCHAR2
      ,n_usr_frgn_key  in out  VARCHAR2
      ,n_copyright  in out  VARCHAR2
      )
   -- Application Update procedure
is
   o_abbr  VARCHAR2(5);
   o_name  VARCHAR2(30);
   o_db_schema  VARCHAR2(30);
   o_db_schema_exp  VARCHAR2(1);
   o_apex_schema  VARCHAR2(30);
   o_apex_ws_name  VARCHAR2(30);
   o_apex_app_name  VARCHAR2(30);
   o_dbid  VARCHAR2(2000);
   o_db_auth  VARCHAR2(200);
   o_description  VARCHAR2(1000);
   o_ts_null_override  VARCHAR2(1);
   o_ts_onln_data  VARCHAR2(30);
   o_ts_onln_indx  VARCHAR2(30);
   o_ts_hist_data  VARCHAR2(30);
   o_ts_hist_indx  VARCHAR2(30);
   o_usr_datatype  VARCHAR2(20);
   o_usr_frgn_key  VARCHAR2(100);
   o_copyright  VARCHAR2(32000);
begin
   -- Retrieve the old (before update) data
   select APP.abbr
         ,APP.name
         ,APP.db_schema
         ,APP.db_schema_exp
         ,APP.apex_schema
         ,APP.apex_ws_name
         ,APP.apex_app_name
         ,APP.dbid
         ,APP.db_auth
         ,APP.description
         ,APP.ts_null_override
         ,APP.ts_onln_data
         ,APP.ts_onln_indx
         ,APP.ts_hist_data
         ,APP.ts_hist_indx
         ,APP.usr_datatype
         ,APP.usr_frgn_key
         ,APP.copyright
    into  o_abbr
         ,o_name
         ,o_db_schema
         ,o_db_schema_exp
         ,o_apex_schema
         ,o_apex_ws_name
         ,o_apex_app_name
         ,o_dbid
         ,o_db_auth
         ,o_description
         ,o_ts_null_override
         ,o_ts_onln_data
         ,o_ts_onln_indx
         ,o_ts_hist_data
         ,o_ts_hist_indx
         ,o_usr_datatype
         ,o_usr_frgn_key
         ,o_copyright
    from  applications_act  APP
    where APP.id = o_id_in;
   -- Run the update
   applications_view.upd
      (o_id_in
      ,o_abbr
      ,n_abbr
      ,o_name
      ,n_name
      ,o_db_schema
      ,n_db_schema
      ,o_db_schema_exp
      ,n_db_schema_exp
      ,o_apex_schema
      ,n_apex_schema
      ,o_apex_ws_name
      ,n_apex_ws_name
      ,o_apex_app_name
      ,n_apex_app_name
      ,o_dbid
      ,n_dbid
      ,o_db_auth
      ,n_db_auth
      ,o_description
      ,n_description
      ,o_ts_null_override
      ,n_ts_null_override
      ,o_ts_onln_data
      ,n_ts_onln_data
      ,o_ts_onln_indx
      ,n_ts_onln_indx
      ,o_ts_hist_data
      ,n_ts_hist_data
      ,o_ts_hist_indx
      ,n_ts_hist_indx
      ,o_usr_datatype
      ,n_usr_datatype
      ,o_usr_frgn_key
      ,n_usr_frgn_key
      ,o_copyright
      ,n_copyright
      );
end upd;
----------------------------------------
procedure del
      (o_id_in  in  NUMBER
      )
   -- Application Delete procedure
is
   o_abbr  VARCHAR2(5);
   o_name  VARCHAR2(30);
   o_db_schema  VARCHAR2(30);
   o_db_schema_exp  VARCHAR2(1);
   o_apex_schema  VARCHAR2(30);
   o_apex_ws_name  VARCHAR2(30);
   o_apex_app_name  VARCHAR2(30);
   o_dbid  VARCHAR2(2000);
   o_db_auth  VARCHAR2(200);
   o_description  VARCHAR2(1000);
   o_ts_null_override  VARCHAR2(1);
   o_ts_onln_data  VARCHAR2(30);
   o_ts_onln_indx  VARCHAR2(30);
   o_ts_hist_data  VARCHAR2(30);
   o_ts_hist_indx  VARCHAR2(30);
   o_usr_datatype  VARCHAR2(20);
   o_usr_frgn_key  VARCHAR2(100);
   o_copyright  VARCHAR2(32000);
begin
   select APP.abbr
         ,APP.name
         ,APP.db_schema
         ,APP.db_schema_exp
         ,APP.apex_schema
         ,APP.apex_ws_name
         ,APP.apex_app_name
         ,APP.dbid
         ,APP.db_auth
         ,APP.description
         ,APP.ts_null_override
         ,APP.ts_onln_data
         ,APP.ts_onln_indx
         ,APP.ts_hist_data
         ,APP.ts_hist_indx
         ,APP.usr_datatype
         ,APP.usr_frgn_key
         ,APP.copyright
    into  o_abbr
         ,o_name
         ,o_db_schema
         ,o_db_schema_exp
         ,o_apex_schema
         ,o_apex_ws_name
         ,o_apex_app_name
         ,o_dbid
         ,o_db_auth
         ,o_description
         ,o_ts_null_override
         ,o_ts_onln_data
         ,o_ts_onln_indx
         ,o_ts_hist_data
         ,o_ts_hist_indx
         ,o_usr_datatype
         ,o_usr_frgn_key
         ,o_copyright
    from  applications  APP
    where APP.id = o_id_in;
   applications_view.del
      (o_id_in
      ,o_abbr
      ,o_name
      ,o_db_schema
      ,o_db_schema_exp
      ,o_apex_schema
      ,o_apex_ws_name
      ,o_apex_app_name
      ,o_dbid
      ,o_db_auth
      ,o_description
      ,o_ts_null_override
      ,o_ts_onln_data
      ,o_ts_onln_indx
      ,o_ts_hist_data
      ,o_ts_hist_indx
      ,o_usr_datatype
      ,o_usr_frgn_key
      ,o_copyright
      );
end del;
----------------------------------------
end applications_dml;
/
select 'APPLICATIONS_DML' as "Package Body:"
 from  user_errors
 where name = 'APPLICATIONS_DML'
  and  type = 'PACKAGE BODY'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'APPLICATIONS_DML'
  and  type = 'PACKAGE BODY'
 order by sequence;

----------------------------------------
select '***  files  ***' as TABLE_NAME from dual;
----------------------------------------

create package files_view
is

   -- Package Files_View
   --    View functions
   --    (DML, Foreign Keys, Paths, and )
   --
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:14 PM

   procedure ins
      (n_id  in out  NUMBER
      ,n_application_id  in out  NUMBER
      ,n_applications_nk1  in  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,n_type  in out  VARCHAR2
      ,n_created_dt  in out  DATE
      ,n_description  in out  VARCHAR2
      );
   procedure upd
      (o_id  in  NUMBER
      ,o_application_id  in  NUMBER
      ,o_applications_nk1  in  VARCHAR2
      ,n_application_id  in out  NUMBER
      ,n_applications_nk1  in  VARCHAR2
      ,o_name  in  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,o_type  in  VARCHAR2
      ,n_type  in out  VARCHAR2
      ,o_created_dt  in  DATE
      ,n_created_dt  in out  DATE
      ,o_description  in  VARCHAR2
      ,n_description  in out  VARCHAR2
      );
   procedure del
      (o_id  in  NUMBER
      ,o_application_id  in  NUMBER
      ,o_name  in  VARCHAR2
      ,o_type  in  VARCHAR2
      ,o_created_dt  in  DATE
      ,o_description  in  VARCHAR2
      );
end files_view;
/
select 'FILES_VIEW' as "Package:"
 from  user_errors
 where name = 'FILES_VIEW'
  and  type = 'PACKAGE'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'FILES_VIEW'
  and  type = 'PACKAGE'
 order by sequence;

create package files_dml
is

   -- Package Files_Dml
   -- (Data Manipulation Language, Foreign Key and Path Lookup)

   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:14 PM

   function get_next_id
      return number;
   function get_curr_id
      return number;

   function get_id
      (files_nk1  in  VARCHAR2
      ,files_nk2  in  VARCHAR2
      ) return number;
   function get_nk
      (id_in  in  number
      ) return varchar2;

   function tab_to_col
         (id_in  in  number)
      return col_type;

   procedure ins
      (n_id  in out  NUMBER
      ,n_application_id  in out  NUMBER
      ,n_applications_nk1_in  in  VARCHAR2  default null
      ,n_name  in out  VARCHAR2
      ,n_type  in out  VARCHAR2
      ,n_created_dt  in out  DATE
      ,n_description  in out  VARCHAR2
      );
   procedure upd
      (o_id_in  in  NUMBER
      ,n_application_id  in out  NUMBER
      ,n_applications_nk1_in  in  VARCHAR2  default null
      ,n_name  in out  VARCHAR2
      ,n_type  in out  VARCHAR2
      ,n_created_dt  in out  DATE
      ,n_description  in out  VARCHAR2
      ,nkdata_provided_in  in   VARCHAR2  default null
      );
   procedure del
      (o_id_in  in  NUMBER
      );
end files_dml;
/
select 'FILES_DML' as "Package:"
 from  user_errors
 where name = 'FILES_DML'
  and  type = 'PACKAGE'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'FILES_DML'
  and  type = 'PACKAGE'
 order by sequence;

create view files_act
      (id
      ,application_id
      ,applications_nk1
      ,name
      ,type
      ,created_dt
      ,description
      )
   as select
       F.id
      ,F.application_id
      ,APP.abbr
      ,F.name
      ,F.type
      ,F.created_dt
      ,F.description
 from             files F
       inner join applications APP on APP.id = F.application_id
 ;
select 'FILES_ACT' as "View:"
 from  user_errors
 where name = 'FILES_ACT'
  and  type = 'VIEW'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'FILES_ACT'
  and  type = 'VIEW'
 order by sequence;

comment on table files_act is 'Files for capturing scripts and logs';

comment on column files_act.id is 'Surrogate Primary Key for these files_act';
comment on column files_act.application_id is 'Surrogate Key for the application of this file';
comment on column files_act.name is 'Name of this file';
comment on column files_act.type is 'Type for this file';
comment on column files_act.created_dt is 'Time/Date this file was created';
comment on column files_act.description is 'Description for this file';
comment on column files_act.applications_nk1 is 'APPLICATIONS Natural Key Value 1: Abbreviation for this application';

alter view files_act add constraint files_act_pk
   primary key (id) disable;

alter view files_act add constraint files_act_fk1
   foreign key (application_id) references applications_act (id) disable;

create TRIGGER files_ioi
   instead of insert on files_act
   for each row
declare
   n_id  NUMBER(38);
   n_application_id  NUMBER(38);
   n_name  VARCHAR2(30);
   n_type  VARCHAR2(3);
   n_created_dt  DATE;
   n_description  VARCHAR2(1000);
begin

   -- Trigger Files_Ioi
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:15 PM

   n_id := :new.id;
   n_application_id := :new.application_id;
   n_name := :new.name;
   n_type := :new.type;
   n_created_dt := :new.created_dt;
   n_description := :new.description;
   files_view.ins
      (n_id
      ,n_application_id
      ,:new.applications_nk1
      ,n_name
      ,n_type
      ,n_created_dt
      ,n_description
      );
end files_ioi;
/
select 'FILES_IOI' as "Trigger:"
 from  user_errors
 where name = 'FILES_IOI'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'FILES_IOI'
  and  type = 'TRIGGER'
 order by sequence;

create TRIGGER files_iou
   instead of update on files_act
   for each row
declare
   n_application_id  NUMBER(38);
   n_name  VARCHAR2(30);
   n_type  VARCHAR2(3);
   n_created_dt  DATE;
   n_description  VARCHAR2(1000);
begin

   -- Trigger Files_Iou
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:15 PM

   n_application_id := :new.application_id;
   n_name := :new.name;
   n_type := :new.type;
   n_created_dt := :new.created_dt;
   n_description := :new.description;
   files_view.upd
      (:old.id
      ,:old.application_id
      ,:old.applications_nk1
      ,n_application_id
      ,:new.applications_nk1
      ,:old.name
      ,n_name
      ,:old.type
      ,n_type
      ,:old.created_dt
      ,n_created_dt
      ,:old.description
      ,n_description
      );
end files_iou;
/
select 'FILES_IOU' as "Trigger:"
 from  user_errors
 where name = 'FILES_IOU'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'FILES_IOU'
  and  type = 'TRIGGER'
 order by sequence;

create TRIGGER files_iod
   instead of delete on files_act
   for each row
begin

   -- Trigger Files_Iod
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:15 PM

   files_view.del
      (:old.id
      ,:old.application_id
      ,:old.name
      ,:old.type
      ,:old.created_dt
      ,:old.description
      );
end files_iod;
/
select 'FILES_IOD' as "Trigger:"
 from  user_errors
 where name = 'FILES_IOD'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'FILES_IOD'
  and  type = 'TRIGGER'
 order by sequence;

create package body files_view
is

-- Package Body Files_View
--    View functions
--    (DML, Foreign Keys, Paths, and )
--
--    Generated by DTGen (http://code.google.com/p/dtgen)
--    July      27, 2012  09:34:15 PM

----------------------------------------
procedure ins
      (n_id  in out  NUMBER
      ,n_application_id  in out  NUMBER
      ,n_applications_nk1  in  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,n_type  in out  VARCHAR2
      ,n_created_dt  in out  DATE
      ,n_description  in out  VARCHAR2
      )
   -- View insert procedure
is
begin
   if util.db_object_exists('FILES', 'MATERIALIZED VIEW')
   then
      raise_application_error(-20010, 'Insert not allowed on materialized view files.  Inserts on files must be performed on the central database.');
   end if;
   -- Set n_application_id, if needed
   if     n_application_id is null
      and n_applications_nk1 is not null
   then
      n_application_id :=
         applications_dml.get_id
            (n_applications_nk1
            );
   end if;
   if not glob.get_db_constraints
   then
      files_tab.ins
         (n_id
         ,n_application_id
         ,n_name
         ,n_type
         ,n_created_dt
         ,n_description
         );
   end if;
   insert into files
         (id
         ,application_id
         ,name
         ,type
         ,created_dt
         ,description
         )
   values
         (n_id
         ,n_application_id
         ,n_name
         ,n_type
         ,n_created_dt
         ,n_description
         );
end ins;
----------------------------------------
procedure upd
      (o_id  in  NUMBER
      ,o_application_id  in  NUMBER
      ,o_applications_nk1  in  VARCHAR2
      ,n_application_id  in out  NUMBER
      ,n_applications_nk1  in  VARCHAR2
      ,o_name  in  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,o_type  in  VARCHAR2
      ,n_type  in out  VARCHAR2
      ,o_created_dt  in  DATE
      ,n_created_dt  in out  DATE
      ,o_description  in  VARCHAR2
      ,n_description  in out  VARCHAR2
      )
   -- View Update procedure
is
begin
   if util.db_object_exists('FILES', 'MATERIALIZED VIEW')
   then
      raise_application_error(-20010, 'Update not allowed on materialized view files.  Updates on files must be performed on the central database.');
   end if;
   -- Set n_application_id, if needed
   if     n_application_id = o_application_id
      and (   not (n_applications_nk1 = o_applications_nk1)
          )
   then
      n_application_id :=
         applications_dml.get_id
            (n_applications_nk1
            );
   end if;
   if not glob.get_db_constraints
   then
      files_tab.upd
         (o_id
         ,o_application_id
         ,n_application_id
         ,o_name
         ,n_name
         ,o_type
         ,n_type
         ,o_created_dt
         ,n_created_dt
         ,o_description
         ,n_description
         );
   end if;
   update files F
     set  F.application_id = n_application_id
         ,F.name = n_name
         ,F.type = n_type
         ,F.created_dt = n_created_dt
         ,F.description = n_description
    where F.id = o_id;
end upd;
----------------------------------------
procedure del
      (o_id  in  NUMBER
      ,o_application_id  in  NUMBER
      ,o_name  in  VARCHAR2
      ,o_type  in  VARCHAR2
      ,o_created_dt  in  DATE
      ,o_description  in  VARCHAR2
      )
is
begin
   if util.db_object_exists('FILES', 'MATERIALIZED VIEW')
   then
      raise_application_error(-20010, 'Delete not allowed on materialized view files.  Deletes on files must be performed on the central database.');
   end if;
   if not glob.get_db_constraints
   then
      files_tab.del
         (o_id
         ,o_application_id
         ,o_name
         ,o_type
         ,o_created_dt
         ,o_description
         );
   end if;
   delete from files  F
    where F.id = o_id;
end del;
----------------------------------------
end files_view;
/
select 'FILES_VIEW' as "Package Body:"
 from  user_errors
 where name = 'FILES_VIEW'
  and  type = 'PACKAGE BODY'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'FILES_VIEW'
  and  type = 'PACKAGE BODY'
 order by sequence;

create package body files_dml
is

 -- Package Body Files_Dml
 -- (Data Manipulation Language, Foreign Key and Path Lookup)

 --    Generated by DTGen (http://code.google.com/p/dtgen)
 --    July      27, 2012  09:34:15 PM

----------------------------------------
function get_next_id
      return number
is
   retid  number;
begin
   select files_seq.nextval into retid from dual;
   return retid;
end get_next_id;
----------------------------------------
function get_curr_id
      return number
is
   retid  number;
begin
   select files_seq.currval into retid from dual;
   return retid;
end get_curr_id;
----------------------------------------
function get_id
      (files_nk1  in  VARCHAR2
      ,files_nk2  in  VARCHAR2
      ) return number
   -- For all the Natural Key Columns, Return an ID
is
   retid  number(38);
begin
   select id
    into  retid
    from  files  F
    where F.application_id = applications_dml.get_id
             (files_nk1
             )
     and  F.name = files_nk2
    ;
   return retid;
exception
   when no_data_found
   then
      return null;
   when others
   then
      raise;
end get_id;
----------------------------------------
function get_nk
      (id_in  in  number)
   return varchar2
   -- For an ID, return a delimited list of Natural Key Values
is
   rtxt  varchar2(32767);
begin
   select substr(   applications_dml.get_nk(F.application_id)
    || util.nk_sep || F.name
                         ,1,32767)
    into  rtxt
    from  files F
    where F.id = id_in;
   return rtxt;
exception
   when no_data_found then
      return null;
   when others then
      raise;
end get_nk;
----------------------------------------
function tab_to_col
      (id_in  in  number)
   return col_type
is
   -- This function is duplicated in files_POP
   cursor acur is
      select * from files
       where id = id_in;
   abuf   acur%ROWTYPE;
   rcol      col_type;
begin
   open acur;
   fetch acur into abuf;
   if acur%NOTFOUND
   then
      rcol := COL_TYPE(null);
      close acur;
      return rcol;
   end if;
   rcol := COL_TYPE
             (PAIR_TYPE('application_id', to_char(abuf.application_id))
             ,PAIR_TYPE('name', abuf.name)
             ,PAIR_TYPE('type', abuf.type)
             ,PAIR_TYPE('created_dt', to_char(abuf.created_dt, 'DD-MON-YYYY HH24:MI:SS'))
             ,PAIR_TYPE('description', abuf.description)
                );
   close acur;
   return rcol;
end tab_to_col;
----------------------------------------
procedure ins
      (n_id  in out  NUMBER
      ,n_application_id  in out  NUMBER
      ,n_applications_nk1_in  in  VARCHAR2  default null
      ,n_name  in out  VARCHAR2
      ,n_type  in out  VARCHAR2
      ,n_created_dt  in out  DATE
      ,n_description  in out  VARCHAR2
      )
   -- Application Insert procedure
is
begin
   files_view.ins
      (n_id
      ,n_application_id
      ,n_applications_nk1_in
      ,n_name
      ,n_type
      ,n_created_dt
      ,n_description
      );
end ins;
----------------------------------------
procedure upd
      (o_id_in  in  NUMBER
      ,n_application_id  in out  NUMBER
      ,n_applications_nk1_in  in  VARCHAR2  default null
      ,n_name  in out  VARCHAR2
      ,n_type  in out  VARCHAR2
      ,n_created_dt  in out  DATE
      ,n_description  in out  VARCHAR2
      ,nkdata_provided_in  in   VARCHAR2  default null
      )
   -- Application Update procedure
is
   o_application_id  NUMBER(38);
   o_applications_nk1  VARCHAR2(5);
   n_applications_nk1  VARCHAR2(5);
   o_name  VARCHAR2(30);
   o_type  VARCHAR2(3);
   o_created_dt  DATE;
   o_description  VARCHAR2(1000);
begin
   -- Retrieve the old (before update) data
   select F.application_id
         ,F.applications_nk1
         ,F.name
         ,F.type
         ,F.created_dt
         ,F.description
    into  o_application_id
         ,o_applications_nk1
         ,o_name
         ,o_type
         ,o_created_dt
         ,o_description
    from  files_act  F
    where F.id = o_id_in;
   -- Set the Natural Key data as indicated by NKDATA_PROVIDED
   if upper(substr(nkdata_provided_in,1,1)) in ('Y','T')
   then
      -- Use the Natural Key Data that was provided
      n_applications_nk1 := n_applications_nk1_in;
   else
      -- Use the old Natural Key Data
      n_applications_nk1 := o_applications_nk1;
   end if;
   -- Run the update
   files_view.upd
      (o_id_in
      ,o_application_id
      ,o_applications_nk1
      ,n_application_id
      ,n_applications_nk1
      ,o_name
      ,n_name
      ,o_type
      ,n_type
      ,o_created_dt
      ,n_created_dt
      ,o_description
      ,n_description
      );
end upd;
----------------------------------------
procedure del
      (o_id_in  in  NUMBER
      )
   -- Application Delete procedure
is
   o_application_id  NUMBER(38);
   o_name  VARCHAR2(30);
   o_type  VARCHAR2(3);
   o_created_dt  DATE;
   o_description  VARCHAR2(1000);
begin
   select F.application_id
         ,F.name
         ,F.type
         ,F.created_dt
         ,F.description
    into  o_application_id
         ,o_name
         ,o_type
         ,o_created_dt
         ,o_description
    from  files  F
    where F.id = o_id_in;
   files_view.del
      (o_id_in
      ,o_application_id
      ,o_name
      ,o_type
      ,o_created_dt
      ,o_description
      );
end del;
----------------------------------------
end files_dml;
/
select 'FILES_DML' as "Package Body:"
 from  user_errors
 where name = 'FILES_DML'
  and  type = 'PACKAGE BODY'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'FILES_DML'
  and  type = 'PACKAGE BODY'
 order by sequence;

----------------------------------------
select '***  file_lines  ***' as TABLE_NAME from dual;
----------------------------------------

create package file_lines_view
is

   -- Package File_Lines_View
   --    View functions
   --    (DML, Foreign Keys, Paths, and )
   --
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:15 PM

   procedure ins
      (n_id  in out  NUMBER
      ,n_file_id  in out  NUMBER
      ,n_files_nk1  in  VARCHAR2
      ,n_files_nk2  in  VARCHAR2
      ,n_seq  in out  NUMBER
      ,n_value  in out  VARCHAR2
      );
   procedure upd
      (o_id  in  NUMBER
      ,o_file_id  in  NUMBER
      ,o_files_nk1  in  VARCHAR2
      ,o_files_nk2  in  VARCHAR2
      ,n_file_id  in out  NUMBER
      ,n_files_nk1  in  VARCHAR2
      ,n_files_nk2  in  VARCHAR2
      ,o_seq  in  NUMBER
      ,n_seq  in out  NUMBER
      ,o_value  in  VARCHAR2
      ,n_value  in out  VARCHAR2
      );
   procedure del
      (o_id  in  NUMBER
      ,o_file_id  in  NUMBER
      ,o_seq  in  NUMBER
      ,o_value  in  VARCHAR2
      );
end file_lines_view;
/
select 'FILE_LINES_VIEW' as "Package:"
 from  user_errors
 where name = 'FILE_LINES_VIEW'
  and  type = 'PACKAGE'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'FILE_LINES_VIEW'
  and  type = 'PACKAGE'
 order by sequence;

create package file_lines_dml
is

   -- Package File_Lines_Dml
   -- (Data Manipulation Language, Foreign Key and Path Lookup)

   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:15 PM

   function get_next_id
      return number;
   function get_curr_id
      return number;

   function get_id
      (file_lines_nk1  in  VARCHAR2
      ,file_lines_nk2  in  VARCHAR2
      ,file_lines_nk3  in  NUMBER
      ) return number;
   function get_nk
      (id_in  in  number
      ) return varchar2;

   function tab_to_col
         (id_in  in  number)
      return col_type;

   procedure ins
      (n_id  in out  NUMBER
      ,n_file_id  in out  NUMBER
      ,n_files_nk1_in  in  VARCHAR2  default null
      ,n_files_nk2_in  in  VARCHAR2  default null
      ,n_seq  in out  NUMBER
      ,n_value  in out  VARCHAR2
      );
   procedure upd
      (o_id_in  in  NUMBER
      ,n_file_id  in out  NUMBER
      ,n_files_nk1_in  in  VARCHAR2  default null
      ,n_files_nk2_in  in  VARCHAR2  default null
      ,n_seq  in out  NUMBER
      ,n_value  in out  VARCHAR2
      ,nkdata_provided_in  in   VARCHAR2  default null
      );
   procedure del
      (o_id_in  in  NUMBER
      );
end file_lines_dml;
/
select 'FILE_LINES_DML' as "Package:"
 from  user_errors
 where name = 'FILE_LINES_DML'
  and  type = 'PACKAGE'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'FILE_LINES_DML'
  and  type = 'PACKAGE'
 order by sequence;

create view file_lines_act
      (id
      ,file_id
      ,files_nk1
      ,files_nk2
      ,seq
      ,value
      )
   as select
       FL.id
      ,FL.file_id
      ,APP.abbr
      ,F.name
      ,FL.seq
      ,FL.value
 from             file_lines FL
       inner join files F on F.id = FL.file_id
       inner join applications APP on APP.id = F.application_id
 ;
select 'FILE_LINES_ACT' as "View:"
 from  user_errors
 where name = 'FILE_LINES_ACT'
  and  type = 'VIEW'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'FILE_LINES_ACT'
  and  type = 'VIEW'
 order by sequence;

comment on table file_lines_act is 'Lines for files';

comment on column file_lines_act.id is 'Surrogate Primary Key for these file_lines_act';
comment on column file_lines_act.file_id is 'Surrogate Key for the file of this line';
comment on column file_lines_act.seq is 'Sequence number for this line in the file';
comment on column file_lines_act.value is 'Value or contents of this line in the file';
comment on column file_lines_act.files_nk1 is 'FILES Natural Key Value 1: Abbreviation for this application';
comment on column file_lines_act.files_nk2 is 'FILES Natural Key Value 2: Name of this file';

alter view file_lines_act add constraint file_lines_act_pk
   primary key (id) disable;

alter view file_lines_act add constraint file_lines_act_fk1
   foreign key (file_id) references files_act (id) disable;

create TRIGGER file_lines_ioi
   instead of insert on file_lines_act
   for each row
declare
   n_id  NUMBER(38);
   n_file_id  NUMBER(38);
   n_seq  NUMBER(9);
   n_value  VARCHAR2(1000);
begin

   -- Trigger File_Lines_Ioi
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:16 PM

   n_id := :new.id;
   n_file_id := :new.file_id;
   n_seq := :new.seq;
   n_value := :new.value;
   file_lines_view.ins
      (n_id
      ,n_file_id
      ,:new.files_nk1
      ,:new.files_nk2
      ,n_seq
      ,n_value
      );
end file_lines_ioi;
/
select 'FILE_LINES_IOI' as "Trigger:"
 from  user_errors
 where name = 'FILE_LINES_IOI'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'FILE_LINES_IOI'
  and  type = 'TRIGGER'
 order by sequence;

create TRIGGER file_lines_iou
   instead of update on file_lines_act
   for each row
declare
   n_file_id  NUMBER(38);
   n_seq  NUMBER(9);
   n_value  VARCHAR2(1000);
begin

   -- Trigger File_Lines_Iou
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:16 PM

   n_file_id := :new.file_id;
   n_seq := :new.seq;
   n_value := :new.value;
   file_lines_view.upd
      (:old.id
      ,:old.file_id
      ,:old.files_nk1
      ,:old.files_nk2
      ,n_file_id
      ,:new.files_nk1
      ,:new.files_nk2
      ,:old.seq
      ,n_seq
      ,:old.value
      ,n_value
      );
end file_lines_iou;
/
select 'FILE_LINES_IOU' as "Trigger:"
 from  user_errors
 where name = 'FILE_LINES_IOU'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'FILE_LINES_IOU'
  and  type = 'TRIGGER'
 order by sequence;

create TRIGGER file_lines_iod
   instead of delete on file_lines_act
   for each row
begin

   -- Trigger File_Lines_Iod
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:16 PM

   file_lines_view.del
      (:old.id
      ,:old.file_id
      ,:old.seq
      ,:old.value
      );
end file_lines_iod;
/
select 'FILE_LINES_IOD' as "Trigger:"
 from  user_errors
 where name = 'FILE_LINES_IOD'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'FILE_LINES_IOD'
  and  type = 'TRIGGER'
 order by sequence;

create package body file_lines_view
is

-- Package Body File_Lines_View
--    View functions
--    (DML, Foreign Keys, Paths, and )
--
--    Generated by DTGen (http://code.google.com/p/dtgen)
--    July      27, 2012  09:34:16 PM

----------------------------------------
procedure ins
      (n_id  in out  NUMBER
      ,n_file_id  in out  NUMBER
      ,n_files_nk1  in  VARCHAR2
      ,n_files_nk2  in  VARCHAR2
      ,n_seq  in out  NUMBER
      ,n_value  in out  VARCHAR2
      )
   -- View insert procedure
is
begin
   if util.db_object_exists('FILE_LINES', 'MATERIALIZED VIEW')
   then
      raise_application_error(-20010, 'Insert not allowed on materialized view file_lines.  Inserts on file_lines must be performed on the central database.');
   end if;
   -- Set n_file_id, if needed
   if     n_file_id is null
      and n_files_nk1 is not null
      and n_files_nk2 is not null
   then
      n_file_id :=
         files_dml.get_id
            (n_files_nk1
            ,n_files_nk2
            );
   end if;
   if not glob.get_db_constraints
   then
      file_lines_tab.ins
         (n_id
         ,n_file_id
         ,n_seq
         ,n_value
         );
   end if;
   insert into file_lines
         (id
         ,file_id
         ,seq
         ,value
         )
   values
         (n_id
         ,n_file_id
         ,n_seq
         ,n_value
         );
end ins;
----------------------------------------
procedure upd
      (o_id  in  NUMBER
      ,o_file_id  in  NUMBER
      ,o_files_nk1  in  VARCHAR2
      ,o_files_nk2  in  VARCHAR2
      ,n_file_id  in out  NUMBER
      ,n_files_nk1  in  VARCHAR2
      ,n_files_nk2  in  VARCHAR2
      ,o_seq  in  NUMBER
      ,n_seq  in out  NUMBER
      ,o_value  in  VARCHAR2
      ,n_value  in out  VARCHAR2
      )
   -- View Update procedure
is
begin
   if util.db_object_exists('FILE_LINES', 'MATERIALIZED VIEW')
   then
      raise_application_error(-20010, 'Update not allowed on materialized view file_lines.  Updates on file_lines must be performed on the central database.');
   end if;
   -- Set n_file_id, if needed
   if     n_file_id = o_file_id
      and (   not (n_files_nk1 = o_files_nk1)
           or not (n_files_nk2 = o_files_nk2)
          )
   then
      n_file_id :=
         files_dml.get_id
            (n_files_nk1
            ,n_files_nk2
            );
   end if;
   if not glob.get_db_constraints
   then
      file_lines_tab.upd
         (o_id
         ,o_file_id
         ,n_file_id
         ,o_seq
         ,n_seq
         ,o_value
         ,n_value
         );
   end if;
   update file_lines FL
     set  FL.file_id = n_file_id
         ,FL.seq = n_seq
         ,FL.value = n_value
    where FL.id = o_id;
end upd;
----------------------------------------
procedure del
      (o_id  in  NUMBER
      ,o_file_id  in  NUMBER
      ,o_seq  in  NUMBER
      ,o_value  in  VARCHAR2
      )
is
begin
   if util.db_object_exists('FILE_LINES', 'MATERIALIZED VIEW')
   then
      raise_application_error(-20010, 'Delete not allowed on materialized view file_lines.  Deletes on file_lines must be performed on the central database.');
   end if;
   if not glob.get_db_constraints
   then
      file_lines_tab.del
         (o_id
         ,o_file_id
         ,o_seq
         ,o_value
         );
   end if;
   delete from file_lines  FL
    where FL.id = o_id;
end del;
----------------------------------------
end file_lines_view;
/
select 'FILE_LINES_VIEW' as "Package Body:"
 from  user_errors
 where name = 'FILE_LINES_VIEW'
  and  type = 'PACKAGE BODY'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'FILE_LINES_VIEW'
  and  type = 'PACKAGE BODY'
 order by sequence;

create package body file_lines_dml
is

 -- Package Body File_Lines_Dml
 -- (Data Manipulation Language, Foreign Key and Path Lookup)

 --    Generated by DTGen (http://code.google.com/p/dtgen)
 --    July      27, 2012  09:34:16 PM

----------------------------------------
function get_next_id
      return number
is
   retid  number;
begin
   select file_lines_seq.nextval into retid from dual;
   return retid;
end get_next_id;
----------------------------------------
function get_curr_id
      return number
is
   retid  number;
begin
   select file_lines_seq.currval into retid from dual;
   return retid;
end get_curr_id;
----------------------------------------
function get_id
      (file_lines_nk1  in  VARCHAR2
      ,file_lines_nk2  in  VARCHAR2
      ,file_lines_nk3  in  NUMBER
      ) return number
   -- For all the Natural Key Columns, Return an ID
is
   retid  number(38);
begin
   select id
    into  retid
    from  file_lines  FL
    where FL.file_id = files_dml.get_id
             (file_lines_nk1
             ,file_lines_nk2
             )
     and  FL.seq = file_lines_nk3
    ;
   return retid;
exception
   when no_data_found
   then
      return null;
   when others
   then
      raise;
end get_id;
----------------------------------------
function get_nk
      (id_in  in  number)
   return varchar2
   -- For an ID, return a delimited list of Natural Key Values
is
   rtxt  varchar2(32767);
begin
   select substr(   files_dml.get_nk(FL.file_id)
    || util.nk_sep || FL.seq
                         ,1,32767)
    into  rtxt
    from  file_lines FL
    where FL.id = id_in;
   return rtxt;
exception
   when no_data_found then
      return null;
   when others then
      raise;
end get_nk;
----------------------------------------
function tab_to_col
      (id_in  in  number)
   return col_type
is
   -- This function is duplicated in file_lines_POP
   cursor acur is
      select * from file_lines
       where id = id_in;
   abuf   acur%ROWTYPE;
   rcol      col_type;
begin
   open acur;
   fetch acur into abuf;
   if acur%NOTFOUND
   then
      rcol := COL_TYPE(null);
      close acur;
      return rcol;
   end if;
   rcol := COL_TYPE
             (PAIR_TYPE('file_id', to_char(abuf.file_id))
             ,PAIR_TYPE('seq', to_char(abuf.seq))
             ,PAIR_TYPE('value', abuf.value)
                );
   close acur;
   return rcol;
end tab_to_col;
----------------------------------------
procedure ins
      (n_id  in out  NUMBER
      ,n_file_id  in out  NUMBER
      ,n_files_nk1_in  in  VARCHAR2  default null
      ,n_files_nk2_in  in  VARCHAR2  default null
      ,n_seq  in out  NUMBER
      ,n_value  in out  VARCHAR2
      )
   -- Application Insert procedure
is
begin
   file_lines_view.ins
      (n_id
      ,n_file_id
      ,n_files_nk1_in
      ,n_files_nk2_in
      ,n_seq
      ,n_value
      );
end ins;
----------------------------------------
procedure upd
      (o_id_in  in  NUMBER
      ,n_file_id  in out  NUMBER
      ,n_files_nk1_in  in  VARCHAR2  default null
      ,n_files_nk2_in  in  VARCHAR2  default null
      ,n_seq  in out  NUMBER
      ,n_value  in out  VARCHAR2
      ,nkdata_provided_in  in   VARCHAR2  default null
      )
   -- Application Update procedure
is
   o_file_id  NUMBER(38);
   o_files_nk1  VARCHAR2(5);
   o_files_nk2  VARCHAR2(30);
   n_files_nk1  VARCHAR2(5);
   n_files_nk2  VARCHAR2(30);
   o_seq  NUMBER(9);
   o_value  VARCHAR2(1000);
begin
   -- Retrieve the old (before update) data
   select FL.file_id
         ,FL.files_nk1
         ,FL.files_nk2
         ,FL.seq
         ,FL.value
    into  o_file_id
         ,o_files_nk1
         ,o_files_nk2
         ,o_seq
         ,o_value
    from  file_lines_act  FL
    where FL.id = o_id_in;
   -- Set the Natural Key data as indicated by NKDATA_PROVIDED
   if upper(substr(nkdata_provided_in,1,1)) in ('Y','T')
   then
      -- Use the Natural Key Data that was provided
      n_files_nk1 := n_files_nk1_in;
      n_files_nk2 := n_files_nk2_in;
   else
      -- Use the old Natural Key Data
      n_files_nk1 := o_files_nk1;
      n_files_nk2 := o_files_nk2;
   end if;
   -- Run the update
   file_lines_view.upd
      (o_id_in
      ,o_file_id
      ,o_files_nk1
      ,o_files_nk2
      ,n_file_id
      ,n_files_nk1
      ,n_files_nk2
      ,o_seq
      ,n_seq
      ,o_value
      ,n_value
      );
end upd;
----------------------------------------
procedure del
      (o_id_in  in  NUMBER
      )
   -- Application Delete procedure
is
   o_file_id  NUMBER(38);
   o_seq  NUMBER(9);
   o_value  VARCHAR2(1000);
begin
   select FL.file_id
         ,FL.seq
         ,FL.value
    into  o_file_id
         ,o_seq
         ,o_value
    from  file_lines  FL
    where FL.id = o_id_in;
   file_lines_view.del
      (o_id_in
      ,o_file_id
      ,o_seq
      ,o_value
      );
end del;
----------------------------------------
end file_lines_dml;
/
select 'FILE_LINES_DML' as "Package Body:"
 from  user_errors
 where name = 'FILE_LINES_DML'
  and  type = 'PACKAGE BODY'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'FILE_LINES_DML'
  and  type = 'PACKAGE BODY'
 order by sequence;

----------------------------------------
select '***  domains  ***' as TABLE_NAME from dual;
----------------------------------------

create package domains_view
is

   -- Package Domains_View
   --    View functions
   --    (DML, Foreign Keys, Paths, and )
   --
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:17 PM

   procedure ins
      (n_id  in out  NUMBER
      ,n_application_id  in out  NUMBER
      ,n_applications_nk1  in  VARCHAR2
      ,n_abbr  in out  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,n_fold  in out  VARCHAR2
      ,n_len  in out  NUMBER
      ,n_description  in out  VARCHAR2
      );
   procedure upd
      (o_id  in  NUMBER
      ,o_application_id  in  NUMBER
      ,o_applications_nk1  in  VARCHAR2
      ,n_application_id  in out  NUMBER
      ,n_applications_nk1  in  VARCHAR2
      ,o_abbr  in  VARCHAR2
      ,n_abbr  in out  VARCHAR2
      ,o_name  in  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,o_fold  in  VARCHAR2
      ,n_fold  in out  VARCHAR2
      ,o_len  in  NUMBER
      ,n_len  in out  NUMBER
      ,o_description  in  VARCHAR2
      ,n_description  in out  VARCHAR2
      );
   procedure del
      (o_id  in  NUMBER
      ,o_application_id  in  NUMBER
      ,o_abbr  in  VARCHAR2
      ,o_name  in  VARCHAR2
      ,o_fold  in  VARCHAR2
      ,o_len  in  NUMBER
      ,o_description  in  VARCHAR2
      );
end domains_view;
/
select 'DOMAINS_VIEW' as "Package:"
 from  user_errors
 where name = 'DOMAINS_VIEW'
  and  type = 'PACKAGE'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'DOMAINS_VIEW'
  and  type = 'PACKAGE'
 order by sequence;

create package domains_dml
is

   -- Package Domains_Dml
   -- (Data Manipulation Language, Foreign Key and Path Lookup)

   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:17 PM

   function get_next_id
      return number;
   function get_curr_id
      return number;

   function get_id
      (domains_nk1  in  VARCHAR2
      ,domains_nk2  in  VARCHAR2
      ) return number;
   function get_nk
      (id_in  in  number
      ) return varchar2;

   function tab_to_col
         (id_in  in  number)
      return col_type;

   procedure ins
      (n_id  in out  NUMBER
      ,n_application_id  in out  NUMBER
      ,n_applications_nk1_in  in  VARCHAR2  default null
      ,n_abbr  in out  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,n_fold  in out  VARCHAR2
      ,n_len  in out  NUMBER
      ,n_description  in out  VARCHAR2
      );
   procedure upd
      (o_id_in  in  NUMBER
      ,n_application_id  in out  NUMBER
      ,n_applications_nk1_in  in  VARCHAR2  default null
      ,n_abbr  in out  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,n_fold  in out  VARCHAR2
      ,n_len  in out  NUMBER
      ,n_description  in out  VARCHAR2
      ,nkdata_provided_in  in   VARCHAR2  default null
      );
   procedure del
      (o_id_in  in  NUMBER
      );
end domains_dml;
/
select 'DOMAINS_DML' as "Package:"
 from  user_errors
 where name = 'DOMAINS_DML'
  and  type = 'PACKAGE'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'DOMAINS_DML'
  and  type = 'PACKAGE'
 order by sequence;

create view domains_act
      (id
      ,application_id
      ,applications_nk1
      ,abbr
      ,name
      ,fold
      ,len
      ,description
      )
   as select
       DOM.id
      ,DOM.application_id
      ,APP.abbr
      ,DOM.abbr
      ,DOM.name
      ,DOM.fold
      ,DOM.len
      ,DOM.description
 from             domains DOM
       inner join applications APP on APP.id = DOM.application_id
 ;
select 'DOMAINS_ACT' as "View:"
 from  user_errors
 where name = 'DOMAINS_ACT'
  and  type = 'VIEW'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'DOMAINS_ACT'
  and  type = 'VIEW'
 order by sequence;

comment on table domains_act is 'Data domains to be generated as check constraints and/or lists of values for selected columns';

comment on column domains_act.id is 'Surrogate Primary Key for these domains_act';
comment on column domains_act.application_id is 'Surrogate Key for the application of this data domain';
comment on column domains_act.abbr is 'Name of this data domain';
comment on column domains_act.name is 'Name of this data domain';
comment on column domains_act.fold is 'Value of this sequence in this data domain';
comment on column domains_act.len is 'Value of this sequence in this data domain';
comment on column domains_act.description is 'Description of this data domain value';
comment on column domains_act.applications_nk1 is 'APPLICATIONS Natural Key Value 1: Abbreviation for this application';

alter view domains_act add constraint domains_act_pk
   primary key (id) disable;

alter view domains_act add constraint domains_act_fk1
   foreign key (application_id) references applications_act (id) disable;

create TRIGGER domains_ioi
   instead of insert on domains_act
   for each row
declare
   n_id  NUMBER(38);
   n_application_id  NUMBER(38);
   n_abbr  VARCHAR2(5);
   n_name  VARCHAR2(20);
   n_fold  VARCHAR2(1);
   n_len  NUMBER(2);
   n_description  VARCHAR2(1000);
begin

   -- Trigger Domains_Ioi
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:17 PM

   n_id := :new.id;
   n_application_id := :new.application_id;
   n_abbr := :new.abbr;
   n_name := :new.name;
   n_fold := :new.fold;
   n_len := :new.len;
   n_description := :new.description;
   domains_view.ins
      (n_id
      ,n_application_id
      ,:new.applications_nk1
      ,n_abbr
      ,n_name
      ,n_fold
      ,n_len
      ,n_description
      );
end domains_ioi;
/
select 'DOMAINS_IOI' as "Trigger:"
 from  user_errors
 where name = 'DOMAINS_IOI'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'DOMAINS_IOI'
  and  type = 'TRIGGER'
 order by sequence;

create TRIGGER domains_iou
   instead of update on domains_act
   for each row
declare
   n_application_id  NUMBER(38);
   n_abbr  VARCHAR2(5);
   n_name  VARCHAR2(20);
   n_fold  VARCHAR2(1);
   n_len  NUMBER(2);
   n_description  VARCHAR2(1000);
begin

   -- Trigger Domains_Iou
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:17 PM

   n_application_id := :new.application_id;
   n_abbr := :new.abbr;
   n_name := :new.name;
   n_fold := :new.fold;
   n_len := :new.len;
   n_description := :new.description;
   domains_view.upd
      (:old.id
      ,:old.application_id
      ,:old.applications_nk1
      ,n_application_id
      ,:new.applications_nk1
      ,:old.abbr
      ,n_abbr
      ,:old.name
      ,n_name
      ,:old.fold
      ,n_fold
      ,:old.len
      ,n_len
      ,:old.description
      ,n_description
      );
end domains_iou;
/
select 'DOMAINS_IOU' as "Trigger:"
 from  user_errors
 where name = 'DOMAINS_IOU'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'DOMAINS_IOU'
  and  type = 'TRIGGER'
 order by sequence;

create TRIGGER domains_iod
   instead of delete on domains_act
   for each row
begin

   -- Trigger Domains_Iod
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:17 PM

   domains_view.del
      (:old.id
      ,:old.application_id
      ,:old.abbr
      ,:old.name
      ,:old.fold
      ,:old.len
      ,:old.description
      );
end domains_iod;
/
select 'DOMAINS_IOD' as "Trigger:"
 from  user_errors
 where name = 'DOMAINS_IOD'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'DOMAINS_IOD'
  and  type = 'TRIGGER'
 order by sequence;

create package body domains_view
is

-- Package Body Domains_View
--    View functions
--    (DML, Foreign Keys, Paths, and )
--
--    Generated by DTGen (http://code.google.com/p/dtgen)
--    July      27, 2012  09:34:17 PM

----------------------------------------
procedure ins
      (n_id  in out  NUMBER
      ,n_application_id  in out  NUMBER
      ,n_applications_nk1  in  VARCHAR2
      ,n_abbr  in out  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,n_fold  in out  VARCHAR2
      ,n_len  in out  NUMBER
      ,n_description  in out  VARCHAR2
      )
   -- View insert procedure
is
begin
   if util.db_object_exists('DOMAINS', 'MATERIALIZED VIEW')
   then
      raise_application_error(-20010, 'Insert not allowed on materialized view domains.  Inserts on domains must be performed on the central database.');
   end if;
   -- Set n_application_id, if needed
   if     n_application_id is null
      and n_applications_nk1 is not null
   then
      n_application_id :=
         applications_dml.get_id
            (n_applications_nk1
            );
   end if;
   if not glob.get_db_constraints
   then
      domains_tab.ins
         (n_id
         ,n_application_id
         ,n_abbr
         ,n_name
         ,n_fold
         ,n_len
         ,n_description
         );
   end if;
   insert into domains
         (id
         ,application_id
         ,abbr
         ,name
         ,fold
         ,len
         ,description
         )
   values
         (n_id
         ,n_application_id
         ,n_abbr
         ,n_name
         ,n_fold
         ,n_len
         ,n_description
         );
end ins;
----------------------------------------
procedure upd
      (o_id  in  NUMBER
      ,o_application_id  in  NUMBER
      ,o_applications_nk1  in  VARCHAR2
      ,n_application_id  in out  NUMBER
      ,n_applications_nk1  in  VARCHAR2
      ,o_abbr  in  VARCHAR2
      ,n_abbr  in out  VARCHAR2
      ,o_name  in  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,o_fold  in  VARCHAR2
      ,n_fold  in out  VARCHAR2
      ,o_len  in  NUMBER
      ,n_len  in out  NUMBER
      ,o_description  in  VARCHAR2
      ,n_description  in out  VARCHAR2
      )
   -- View Update procedure
is
begin
   if util.db_object_exists('DOMAINS', 'MATERIALIZED VIEW')
   then
      raise_application_error(-20010, 'Update not allowed on materialized view domains.  Updates on domains must be performed on the central database.');
   end if;
   -- Set n_application_id, if needed
   if     n_application_id = o_application_id
      and (   not (n_applications_nk1 = o_applications_nk1)
          )
   then
      n_application_id :=
         applications_dml.get_id
            (n_applications_nk1
            );
   end if;
   if not glob.get_db_constraints
   then
      domains_tab.upd
         (o_id
         ,o_application_id
         ,n_application_id
         ,o_abbr
         ,n_abbr
         ,o_name
         ,n_name
         ,o_fold
         ,n_fold
         ,o_len
         ,n_len
         ,o_description
         ,n_description
         );
   end if;
   update domains DOM
     set  DOM.application_id = n_application_id
         ,DOM.abbr = n_abbr
         ,DOM.name = n_name
         ,DOM.fold = n_fold
         ,DOM.len = n_len
         ,DOM.description = n_description
    where DOM.id = o_id;
end upd;
----------------------------------------
procedure del
      (o_id  in  NUMBER
      ,o_application_id  in  NUMBER
      ,o_abbr  in  VARCHAR2
      ,o_name  in  VARCHAR2
      ,o_fold  in  VARCHAR2
      ,o_len  in  NUMBER
      ,o_description  in  VARCHAR2
      )
is
begin
   if util.db_object_exists('DOMAINS', 'MATERIALIZED VIEW')
   then
      raise_application_error(-20010, 'Delete not allowed on materialized view domains.  Deletes on domains must be performed on the central database.');
   end if;
   if not glob.get_db_constraints
   then
      domains_tab.del
         (o_id
         ,o_application_id
         ,o_abbr
         ,o_name
         ,o_fold
         ,o_len
         ,o_description
         );
   end if;
   delete from domains  DOM
    where DOM.id = o_id;
end del;
----------------------------------------
end domains_view;
/
select 'DOMAINS_VIEW' as "Package Body:"
 from  user_errors
 where name = 'DOMAINS_VIEW'
  and  type = 'PACKAGE BODY'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'DOMAINS_VIEW'
  and  type = 'PACKAGE BODY'
 order by sequence;

create package body domains_dml
is

 -- Package Body Domains_Dml
 -- (Data Manipulation Language, Foreign Key and Path Lookup)

 --    Generated by DTGen (http://code.google.com/p/dtgen)
 --    July      27, 2012  09:34:17 PM

----------------------------------------
function get_next_id
      return number
is
   retid  number;
begin
   select domains_seq.nextval into retid from dual;
   return retid;
end get_next_id;
----------------------------------------
function get_curr_id
      return number
is
   retid  number;
begin
   select domains_seq.currval into retid from dual;
   return retid;
end get_curr_id;
----------------------------------------
function get_id
      (domains_nk1  in  VARCHAR2
      ,domains_nk2  in  VARCHAR2
      ) return number
   -- For all the Natural Key Columns, Return an ID
is
   retid  number(38);
begin
   select id
    into  retid
    from  domains  DOM
    where DOM.application_id = applications_dml.get_id
             (domains_nk1
             )
     and  DOM.abbr = domains_nk2
    ;
   return retid;
exception
   when no_data_found
   then
      return null;
   when others
   then
      raise;
end get_id;
----------------------------------------
function get_nk
      (id_in  in  number)
   return varchar2
   -- For an ID, return a delimited list of Natural Key Values
is
   rtxt  varchar2(32767);
begin
   select substr(   applications_dml.get_nk(DOM.application_id)
    || util.nk_sep || DOM.abbr
                         ,1,32767)
    into  rtxt
    from  domains DOM
    where DOM.id = id_in;
   return rtxt;
exception
   when no_data_found then
      return null;
   when others then
      raise;
end get_nk;
----------------------------------------
function tab_to_col
      (id_in  in  number)
   return col_type
is
   -- This function is duplicated in domains_POP
   cursor acur is
      select * from domains
       where id = id_in;
   abuf   acur%ROWTYPE;
   rcol      col_type;
begin
   open acur;
   fetch acur into abuf;
   if acur%NOTFOUND
   then
      rcol := COL_TYPE(null);
      close acur;
      return rcol;
   end if;
   rcol := COL_TYPE
             (PAIR_TYPE('application_id', to_char(abuf.application_id))
             ,PAIR_TYPE('abbr', abuf.abbr)
             ,PAIR_TYPE('name', abuf.name)
             ,PAIR_TYPE('fold', abuf.fold)
             ,PAIR_TYPE('len', to_char(abuf.len))
             ,PAIR_TYPE('description', abuf.description)
                );
   close acur;
   return rcol;
end tab_to_col;
----------------------------------------
procedure ins
      (n_id  in out  NUMBER
      ,n_application_id  in out  NUMBER
      ,n_applications_nk1_in  in  VARCHAR2  default null
      ,n_abbr  in out  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,n_fold  in out  VARCHAR2
      ,n_len  in out  NUMBER
      ,n_description  in out  VARCHAR2
      )
   -- Application Insert procedure
is
begin
   domains_view.ins
      (n_id
      ,n_application_id
      ,n_applications_nk1_in
      ,n_abbr
      ,n_name
      ,n_fold
      ,n_len
      ,n_description
      );
end ins;
----------------------------------------
procedure upd
      (o_id_in  in  NUMBER
      ,n_application_id  in out  NUMBER
      ,n_applications_nk1_in  in  VARCHAR2  default null
      ,n_abbr  in out  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,n_fold  in out  VARCHAR2
      ,n_len  in out  NUMBER
      ,n_description  in out  VARCHAR2
      ,nkdata_provided_in  in   VARCHAR2  default null
      )
   -- Application Update procedure
is
   o_application_id  NUMBER(38);
   o_applications_nk1  VARCHAR2(5);
   n_applications_nk1  VARCHAR2(5);
   o_abbr  VARCHAR2(5);
   o_name  VARCHAR2(20);
   o_fold  VARCHAR2(1);
   o_len  NUMBER(2);
   o_description  VARCHAR2(1000);
begin
   -- Retrieve the old (before update) data
   select DOM.application_id
         ,DOM.applications_nk1
         ,DOM.abbr
         ,DOM.name
         ,DOM.fold
         ,DOM.len
         ,DOM.description
    into  o_application_id
         ,o_applications_nk1
         ,o_abbr
         ,o_name
         ,o_fold
         ,o_len
         ,o_description
    from  domains_act  DOM
    where DOM.id = o_id_in;
   -- Set the Natural Key data as indicated by NKDATA_PROVIDED
   if upper(substr(nkdata_provided_in,1,1)) in ('Y','T')
   then
      -- Use the Natural Key Data that was provided
      n_applications_nk1 := n_applications_nk1_in;
   else
      -- Use the old Natural Key Data
      n_applications_nk1 := o_applications_nk1;
   end if;
   -- Run the update
   domains_view.upd
      (o_id_in
      ,o_application_id
      ,o_applications_nk1
      ,n_application_id
      ,n_applications_nk1
      ,o_abbr
      ,n_abbr
      ,o_name
      ,n_name
      ,o_fold
      ,n_fold
      ,o_len
      ,n_len
      ,o_description
      ,n_description
      );
end upd;
----------------------------------------
procedure del
      (o_id_in  in  NUMBER
      )
   -- Application Delete procedure
is
   o_application_id  NUMBER(38);
   o_abbr  VARCHAR2(5);
   o_name  VARCHAR2(20);
   o_fold  VARCHAR2(1);
   o_len  NUMBER(2);
   o_description  VARCHAR2(1000);
begin
   select DOM.application_id
         ,DOM.abbr
         ,DOM.name
         ,DOM.fold
         ,DOM.len
         ,DOM.description
    into  o_application_id
         ,o_abbr
         ,o_name
         ,o_fold
         ,o_len
         ,o_description
    from  domains  DOM
    where DOM.id = o_id_in;
   domains_view.del
      (o_id_in
      ,o_application_id
      ,o_abbr
      ,o_name
      ,o_fold
      ,o_len
      ,o_description
      );
end del;
----------------------------------------
end domains_dml;
/
select 'DOMAINS_DML' as "Package Body:"
 from  user_errors
 where name = 'DOMAINS_DML'
  and  type = 'PACKAGE BODY'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'DOMAINS_DML'
  and  type = 'PACKAGE BODY'
 order by sequence;

----------------------------------------
select '***  domain_values  ***' as TABLE_NAME from dual;
----------------------------------------

create package domain_values_view
is

   -- Package Domain_Values_View
   --    View functions
   --    (DML, Foreign Keys, Paths, and )
   --
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:18 PM

   procedure ins
      (n_id  in out  NUMBER
      ,n_domain_id  in out  NUMBER
      ,n_domains_nk1  in  VARCHAR2
      ,n_domains_nk2  in  VARCHAR2
      ,n_seq  in out  NUMBER
      ,n_value  in out  VARCHAR2
      ,n_description  in out  VARCHAR2
      );
   procedure upd
      (o_id  in  NUMBER
      ,o_domain_id  in  NUMBER
      ,o_domains_nk1  in  VARCHAR2
      ,o_domains_nk2  in  VARCHAR2
      ,n_domain_id  in out  NUMBER
      ,n_domains_nk1  in  VARCHAR2
      ,n_domains_nk2  in  VARCHAR2
      ,o_seq  in  NUMBER
      ,n_seq  in out  NUMBER
      ,o_value  in  VARCHAR2
      ,n_value  in out  VARCHAR2
      ,o_description  in  VARCHAR2
      ,n_description  in out  VARCHAR2
      );
   procedure del
      (o_id  in  NUMBER
      ,o_domain_id  in  NUMBER
      ,o_seq  in  NUMBER
      ,o_value  in  VARCHAR2
      ,o_description  in  VARCHAR2
      );
end domain_values_view;
/
select 'DOMAIN_VALUES_VIEW' as "Package:"
 from  user_errors
 where name = 'DOMAIN_VALUES_VIEW'
  and  type = 'PACKAGE'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'DOMAIN_VALUES_VIEW'
  and  type = 'PACKAGE'
 order by sequence;

create package domain_values_dml
is

   -- Package Domain_Values_Dml
   -- (Data Manipulation Language, Foreign Key and Path Lookup)

   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:18 PM

   function get_next_id
      return number;
   function get_curr_id
      return number;

   function get_id
      (domain_values_nk1  in  VARCHAR2
      ,domain_values_nk2  in  VARCHAR2
      ,domain_values_nk3  in  VARCHAR2
      ) return number;
   function get_nk
      (id_in  in  number
      ) return varchar2;

   function tab_to_col
         (id_in  in  number)
      return col_type;

   procedure ins
      (n_id  in out  NUMBER
      ,n_domain_id  in out  NUMBER
      ,n_domains_nk1_in  in  VARCHAR2  default null
      ,n_domains_nk2_in  in  VARCHAR2  default null
      ,n_seq  in out  NUMBER
      ,n_value  in out  VARCHAR2
      ,n_description  in out  VARCHAR2
      );
   procedure upd
      (o_id_in  in  NUMBER
      ,n_domain_id  in out  NUMBER
      ,n_domains_nk1_in  in  VARCHAR2  default null
      ,n_domains_nk2_in  in  VARCHAR2  default null
      ,n_seq  in out  NUMBER
      ,n_value  in out  VARCHAR2
      ,n_description  in out  VARCHAR2
      ,nkdata_provided_in  in   VARCHAR2  default null
      );
   procedure del
      (o_id_in  in  NUMBER
      );
end domain_values_dml;
/
select 'DOMAIN_VALUES_DML' as "Package:"
 from  user_errors
 where name = 'DOMAIN_VALUES_DML'
  and  type = 'PACKAGE'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'DOMAIN_VALUES_DML'
  and  type = 'PACKAGE'
 order by sequence;

create view domain_values_act
      (id
      ,domain_id
      ,domains_nk1
      ,domains_nk2
      ,seq
      ,value
      ,description
      )
   as select
       DV.id
      ,DV.domain_id
      ,APP.abbr
      ,DOM.abbr
      ,DV.seq
      ,DV.value
      ,DV.description
 from             domain_values DV
       inner join domains DOM on DOM.id = DV.domain_id
       inner join applications APP on APP.id = DOM.application_id
 ;
select 'DOMAIN_VALUES_ACT' as "View:"
 from  user_errors
 where name = 'DOMAIN_VALUES_ACT'
  and  type = 'VIEW'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'DOMAIN_VALUES_ACT'
  and  type = 'VIEW'
 order by sequence;

comment on table domain_values_act is 'Data domains values for the data domains';

comment on column domain_values_act.id is 'Surrogate Primary Key for these domain_values_act';
comment on column domain_values_act.domain_id is 'Surrogate Key for the application of this data domain';
comment on column domain_values_act.seq is 'Sequence number for this value in this data domain';
comment on column domain_values_act.value is 'Value of this sequence in this data domain';
comment on column domain_values_act.description is 'Description of this data domain value';
comment on column domain_values_act.domains_nk1 is 'DOMAINS Natural Key Value 1: Abbreviation for this application';
comment on column domain_values_act.domains_nk2 is 'DOMAINS Natural Key Value 2: Name of this data domain';

alter view domain_values_act add constraint domain_values_act_pk
   primary key (id) disable;

alter view domain_values_act add constraint domain_values_act_fk1
   foreign key (domain_id) references domains_act (id) disable;

create TRIGGER domain_values_ioi
   instead of insert on domain_values_act
   for each row
declare
   n_id  NUMBER(38);
   n_domain_id  NUMBER(38);
   n_seq  NUMBER(2);
   n_value  VARCHAR2(100);
   n_description  VARCHAR2(1000);
begin

   -- Trigger Domain_Values_Ioi
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:18 PM

   n_id := :new.id;
   n_domain_id := :new.domain_id;
   n_seq := :new.seq;
   n_value := :new.value;
   n_description := :new.description;
   domain_values_view.ins
      (n_id
      ,n_domain_id
      ,:new.domains_nk1
      ,:new.domains_nk2
      ,n_seq
      ,n_value
      ,n_description
      );
end domain_values_ioi;
/
select 'DOMAIN_VALUES_IOI' as "Trigger:"
 from  user_errors
 where name = 'DOMAIN_VALUES_IOI'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'DOMAIN_VALUES_IOI'
  and  type = 'TRIGGER'
 order by sequence;

create TRIGGER domain_values_iou
   instead of update on domain_values_act
   for each row
declare
   n_domain_id  NUMBER(38);
   n_seq  NUMBER(2);
   n_value  VARCHAR2(100);
   n_description  VARCHAR2(1000);
begin

   -- Trigger Domain_Values_Iou
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:18 PM

   n_domain_id := :new.domain_id;
   n_seq := :new.seq;
   n_value := :new.value;
   n_description := :new.description;
   domain_values_view.upd
      (:old.id
      ,:old.domain_id
      ,:old.domains_nk1
      ,:old.domains_nk2
      ,n_domain_id
      ,:new.domains_nk1
      ,:new.domains_nk2
      ,:old.seq
      ,n_seq
      ,:old.value
      ,n_value
      ,:old.description
      ,n_description
      );
end domain_values_iou;
/
select 'DOMAIN_VALUES_IOU' as "Trigger:"
 from  user_errors
 where name = 'DOMAIN_VALUES_IOU'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'DOMAIN_VALUES_IOU'
  and  type = 'TRIGGER'
 order by sequence;

create TRIGGER domain_values_iod
   instead of delete on domain_values_act
   for each row
begin

   -- Trigger Domain_Values_Iod
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:18 PM

   domain_values_view.del
      (:old.id
      ,:old.domain_id
      ,:old.seq
      ,:old.value
      ,:old.description
      );
end domain_values_iod;
/
select 'DOMAIN_VALUES_IOD' as "Trigger:"
 from  user_errors
 where name = 'DOMAIN_VALUES_IOD'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'DOMAIN_VALUES_IOD'
  and  type = 'TRIGGER'
 order by sequence;

create package body domain_values_view
is

-- Package Body Domain_Values_View
--    View functions
--    (DML, Foreign Keys, Paths, and )
--
--    Generated by DTGen (http://code.google.com/p/dtgen)
--    July      27, 2012  09:34:18 PM

----------------------------------------
procedure ins
      (n_id  in out  NUMBER
      ,n_domain_id  in out  NUMBER
      ,n_domains_nk1  in  VARCHAR2
      ,n_domains_nk2  in  VARCHAR2
      ,n_seq  in out  NUMBER
      ,n_value  in out  VARCHAR2
      ,n_description  in out  VARCHAR2
      )
   -- View insert procedure
is
begin
   if util.db_object_exists('DOMAIN_VALUES', 'MATERIALIZED VIEW')
   then
      raise_application_error(-20010, 'Insert not allowed on materialized view domain_values.  Inserts on domain_values must be performed on the central database.');
   end if;
   -- Set n_domain_id, if needed
   if     n_domain_id is null
      and n_domains_nk1 is not null
      and n_domains_nk2 is not null
   then
      n_domain_id :=
         domains_dml.get_id
            (n_domains_nk1
            ,n_domains_nk2
            );
   end if;
   if not glob.get_db_constraints
   then
      domain_values_tab.ins
         (n_id
         ,n_domain_id
         ,n_seq
         ,n_value
         ,n_description
         );
   end if;
   insert into domain_values
         (id
         ,domain_id
         ,seq
         ,value
         ,description
         )
   values
         (n_id
         ,n_domain_id
         ,n_seq
         ,n_value
         ,n_description
         );
end ins;
----------------------------------------
procedure upd
      (o_id  in  NUMBER
      ,o_domain_id  in  NUMBER
      ,o_domains_nk1  in  VARCHAR2
      ,o_domains_nk2  in  VARCHAR2
      ,n_domain_id  in out  NUMBER
      ,n_domains_nk1  in  VARCHAR2
      ,n_domains_nk2  in  VARCHAR2
      ,o_seq  in  NUMBER
      ,n_seq  in out  NUMBER
      ,o_value  in  VARCHAR2
      ,n_value  in out  VARCHAR2
      ,o_description  in  VARCHAR2
      ,n_description  in out  VARCHAR2
      )
   -- View Update procedure
is
begin
   if util.db_object_exists('DOMAIN_VALUES', 'MATERIALIZED VIEW')
   then
      raise_application_error(-20010, 'Update not allowed on materialized view domain_values.  Updates on domain_values must be performed on the central database.');
   end if;
   -- Set n_domain_id, if needed
   if     n_domain_id = o_domain_id
      and (   not (n_domains_nk1 = o_domains_nk1)
           or not (n_domains_nk2 = o_domains_nk2)
          )
   then
      n_domain_id :=
         domains_dml.get_id
            (n_domains_nk1
            ,n_domains_nk2
            );
   end if;
   if not glob.get_db_constraints
   then
      domain_values_tab.upd
         (o_id
         ,o_domain_id
         ,n_domain_id
         ,o_seq
         ,n_seq
         ,o_value
         ,n_value
         ,o_description
         ,n_description
         );
   end if;
   update domain_values DV
     set  DV.domain_id = n_domain_id
         ,DV.seq = n_seq
         ,DV.value = n_value
         ,DV.description = n_description
    where DV.id = o_id;
end upd;
----------------------------------------
procedure del
      (o_id  in  NUMBER
      ,o_domain_id  in  NUMBER
      ,o_seq  in  NUMBER
      ,o_value  in  VARCHAR2
      ,o_description  in  VARCHAR2
      )
is
begin
   if util.db_object_exists('DOMAIN_VALUES', 'MATERIALIZED VIEW')
   then
      raise_application_error(-20010, 'Delete not allowed on materialized view domain_values.  Deletes on domain_values must be performed on the central database.');
   end if;
   if not glob.get_db_constraints
   then
      domain_values_tab.del
         (o_id
         ,o_domain_id
         ,o_seq
         ,o_value
         ,o_description
         );
   end if;
   delete from domain_values  DV
    where DV.id = o_id;
end del;
----------------------------------------
end domain_values_view;
/
select 'DOMAIN_VALUES_VIEW' as "Package Body:"
 from  user_errors
 where name = 'DOMAIN_VALUES_VIEW'
  and  type = 'PACKAGE BODY'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'DOMAIN_VALUES_VIEW'
  and  type = 'PACKAGE BODY'
 order by sequence;

create package body domain_values_dml
is

 -- Package Body Domain_Values_Dml
 -- (Data Manipulation Language, Foreign Key and Path Lookup)

 --    Generated by DTGen (http://code.google.com/p/dtgen)
 --    July      27, 2012  09:34:18 PM

----------------------------------------
function get_next_id
      return number
is
   retid  number;
begin
   select domain_values_seq.nextval into retid from dual;
   return retid;
end get_next_id;
----------------------------------------
function get_curr_id
      return number
is
   retid  number;
begin
   select domain_values_seq.currval into retid from dual;
   return retid;
end get_curr_id;
----------------------------------------
function get_id
      (domain_values_nk1  in  VARCHAR2
      ,domain_values_nk2  in  VARCHAR2
      ,domain_values_nk3  in  VARCHAR2
      ) return number
   -- For all the Natural Key Columns, Return an ID
is
   retid  number(38);
begin
   select id
    into  retid
    from  domain_values  DV
    where DV.domain_id = domains_dml.get_id
             (domain_values_nk1
             ,domain_values_nk2
             )
     and  DV.value = domain_values_nk3
    ;
   return retid;
exception
   when no_data_found
   then
      return null;
   when others
   then
      raise;
end get_id;
----------------------------------------
function get_nk
      (id_in  in  number)
   return varchar2
   -- For an ID, return a delimited list of Natural Key Values
is
   rtxt  varchar2(32767);
begin
   select substr(   domains_dml.get_nk(DV.domain_id)
    || util.nk_sep || DV.value
                         ,1,32767)
    into  rtxt
    from  domain_values DV
    where DV.id = id_in;
   return rtxt;
exception
   when no_data_found then
      return null;
   when others then
      raise;
end get_nk;
----------------------------------------
function tab_to_col
      (id_in  in  number)
   return col_type
is
   -- This function is duplicated in domain_values_POP
   cursor acur is
      select * from domain_values
       where id = id_in;
   abuf   acur%ROWTYPE;
   rcol      col_type;
begin
   open acur;
   fetch acur into abuf;
   if acur%NOTFOUND
   then
      rcol := COL_TYPE(null);
      close acur;
      return rcol;
   end if;
   rcol := COL_TYPE
             (PAIR_TYPE('domain_id', to_char(abuf.domain_id))
             ,PAIR_TYPE('seq', to_char(abuf.seq))
             ,PAIR_TYPE('value', abuf.value)
             ,PAIR_TYPE('description', abuf.description)
                );
   close acur;
   return rcol;
end tab_to_col;
----------------------------------------
procedure ins
      (n_id  in out  NUMBER
      ,n_domain_id  in out  NUMBER
      ,n_domains_nk1_in  in  VARCHAR2  default null
      ,n_domains_nk2_in  in  VARCHAR2  default null
      ,n_seq  in out  NUMBER
      ,n_value  in out  VARCHAR2
      ,n_description  in out  VARCHAR2
      )
   -- Application Insert procedure
is
begin
   domain_values_view.ins
      (n_id
      ,n_domain_id
      ,n_domains_nk1_in
      ,n_domains_nk2_in
      ,n_seq
      ,n_value
      ,n_description
      );
end ins;
----------------------------------------
procedure upd
      (o_id_in  in  NUMBER
      ,n_domain_id  in out  NUMBER
      ,n_domains_nk1_in  in  VARCHAR2  default null
      ,n_domains_nk2_in  in  VARCHAR2  default null
      ,n_seq  in out  NUMBER
      ,n_value  in out  VARCHAR2
      ,n_description  in out  VARCHAR2
      ,nkdata_provided_in  in   VARCHAR2  default null
      )
   -- Application Update procedure
is
   o_domain_id  NUMBER(38);
   o_domains_nk1  VARCHAR2(5);
   o_domains_nk2  VARCHAR2(5);
   n_domains_nk1  VARCHAR2(5);
   n_domains_nk2  VARCHAR2(5);
   o_seq  NUMBER(2);
   o_value  VARCHAR2(100);
   o_description  VARCHAR2(1000);
begin
   -- Retrieve the old (before update) data
   select DV.domain_id
         ,DV.domains_nk1
         ,DV.domains_nk2
         ,DV.seq
         ,DV.value
         ,DV.description
    into  o_domain_id
         ,o_domains_nk1
         ,o_domains_nk2
         ,o_seq
         ,o_value
         ,o_description
    from  domain_values_act  DV
    where DV.id = o_id_in;
   -- Set the Natural Key data as indicated by NKDATA_PROVIDED
   if upper(substr(nkdata_provided_in,1,1)) in ('Y','T')
   then
      -- Use the Natural Key Data that was provided
      n_domains_nk1 := n_domains_nk1_in;
      n_domains_nk2 := n_domains_nk2_in;
   else
      -- Use the old Natural Key Data
      n_domains_nk1 := o_domains_nk1;
      n_domains_nk2 := o_domains_nk2;
   end if;
   -- Run the update
   domain_values_view.upd
      (o_id_in
      ,o_domain_id
      ,o_domains_nk1
      ,o_domains_nk2
      ,n_domain_id
      ,n_domains_nk1
      ,n_domains_nk2
      ,o_seq
      ,n_seq
      ,o_value
      ,n_value
      ,o_description
      ,n_description
      );
end upd;
----------------------------------------
procedure del
      (o_id_in  in  NUMBER
      )
   -- Application Delete procedure
is
   o_domain_id  NUMBER(38);
   o_seq  NUMBER(2);
   o_value  VARCHAR2(100);
   o_description  VARCHAR2(1000);
begin
   select DV.domain_id
         ,DV.seq
         ,DV.value
         ,DV.description
    into  o_domain_id
         ,o_seq
         ,o_value
         ,o_description
    from  domain_values  DV
    where DV.id = o_id_in;
   domain_values_view.del
      (o_id_in
      ,o_domain_id
      ,o_seq
      ,o_value
      ,o_description
      );
end del;
----------------------------------------
end domain_values_dml;
/
select 'DOMAIN_VALUES_DML' as "Package Body:"
 from  user_errors
 where name = 'DOMAIN_VALUES_DML'
  and  type = 'PACKAGE BODY'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'DOMAIN_VALUES_DML'
  and  type = 'PACKAGE BODY'
 order by sequence;

----------------------------------------
select '***  tables  ***' as TABLE_NAME from dual;
----------------------------------------

create package tables_view
is

   -- Package Tables_View
   --    View functions
   --    (DML, Foreign Keys, Paths, and )
   --
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:19 PM

   procedure ins
      (n_id  in out  NUMBER
      ,n_application_id  in out  NUMBER
      ,n_applications_nk1  in  VARCHAR2
      ,n_abbr  in out  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,n_seq  in out  NUMBER
      ,n_type  in out  VARCHAR2
      ,n_group_name  in out  VARCHAR2
      ,n_mv_refresh_hr  in out  NUMBER
      ,n_ts_onln_data  in out  VARCHAR2
      ,n_ts_onln_indx  in out  VARCHAR2
      ,n_ts_hist_data  in out  VARCHAR2
      ,n_ts_hist_indx  in out  VARCHAR2
      ,n_description  in out  VARCHAR2
      );
   procedure upd
      (o_id  in  NUMBER
      ,o_application_id  in  NUMBER
      ,o_applications_nk1  in  VARCHAR2
      ,n_application_id  in out  NUMBER
      ,n_applications_nk1  in  VARCHAR2
      ,o_abbr  in  VARCHAR2
      ,n_abbr  in out  VARCHAR2
      ,o_name  in  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,o_seq  in  NUMBER
      ,n_seq  in out  NUMBER
      ,o_type  in  VARCHAR2
      ,n_type  in out  VARCHAR2
      ,o_group_name  in  VARCHAR2
      ,n_group_name  in out  VARCHAR2
      ,o_mv_refresh_hr  in  NUMBER
      ,n_mv_refresh_hr  in out  NUMBER
      ,o_ts_onln_data  in  VARCHAR2
      ,n_ts_onln_data  in out  VARCHAR2
      ,o_ts_onln_indx  in  VARCHAR2
      ,n_ts_onln_indx  in out  VARCHAR2
      ,o_ts_hist_data  in  VARCHAR2
      ,n_ts_hist_data  in out  VARCHAR2
      ,o_ts_hist_indx  in  VARCHAR2
      ,n_ts_hist_indx  in out  VARCHAR2
      ,o_description  in  VARCHAR2
      ,n_description  in out  VARCHAR2
      );
   procedure del
      (o_id  in  NUMBER
      ,o_application_id  in  NUMBER
      ,o_abbr  in  VARCHAR2
      ,o_name  in  VARCHAR2
      ,o_seq  in  NUMBER
      ,o_type  in  VARCHAR2
      ,o_group_name  in  VARCHAR2
      ,o_mv_refresh_hr  in  NUMBER
      ,o_ts_onln_data  in  VARCHAR2
      ,o_ts_onln_indx  in  VARCHAR2
      ,o_ts_hist_data  in  VARCHAR2
      ,o_ts_hist_indx  in  VARCHAR2
      ,o_description  in  VARCHAR2
      );
end tables_view;
/
select 'TABLES_VIEW' as "Package:"
 from  user_errors
 where name = 'TABLES_VIEW'
  and  type = 'PACKAGE'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'TABLES_VIEW'
  and  type = 'PACKAGE'
 order by sequence;

create package tables_dml
is

   -- Package Tables_Dml
   -- (Data Manipulation Language, Foreign Key and Path Lookup)

   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:19 PM

   function get_next_id
      return number;
   function get_curr_id
      return number;

   function get_id
      (tables_nk1  in  VARCHAR2
      ,tables_nk2  in  VARCHAR2
      ) return number;
   function get_nk
      (id_in  in  number
      ) return varchar2;

   function tab_to_col
         (id_in  in  number)
      return col_type;

   procedure ins
      (n_id  in out  NUMBER
      ,n_application_id  in out  NUMBER
      ,n_applications_nk1_in  in  VARCHAR2  default null
      ,n_abbr  in out  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,n_seq  in out  NUMBER
      ,n_type  in out  VARCHAR2
      ,n_group_name  in out  VARCHAR2
      ,n_mv_refresh_hr  in out  NUMBER
      ,n_ts_onln_data  in out  VARCHAR2
      ,n_ts_onln_indx  in out  VARCHAR2
      ,n_ts_hist_data  in out  VARCHAR2
      ,n_ts_hist_indx  in out  VARCHAR2
      ,n_description  in out  VARCHAR2
      );
   procedure upd
      (o_id_in  in  NUMBER
      ,n_application_id  in out  NUMBER
      ,n_applications_nk1_in  in  VARCHAR2  default null
      ,n_abbr  in out  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,n_seq  in out  NUMBER
      ,n_type  in out  VARCHAR2
      ,n_group_name  in out  VARCHAR2
      ,n_mv_refresh_hr  in out  NUMBER
      ,n_ts_onln_data  in out  VARCHAR2
      ,n_ts_onln_indx  in out  VARCHAR2
      ,n_ts_hist_data  in out  VARCHAR2
      ,n_ts_hist_indx  in out  VARCHAR2
      ,n_description  in out  VARCHAR2
      ,nkdata_provided_in  in   VARCHAR2  default null
      );
   procedure del
      (o_id_in  in  NUMBER
      );
end tables_dml;
/
select 'TABLES_DML' as "Package:"
 from  user_errors
 where name = 'TABLES_DML'
  and  type = 'PACKAGE'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'TABLES_DML'
  and  type = 'PACKAGE'
 order by sequence;

create view tables_act
      (id
      ,application_id
      ,applications_nk1
      ,abbr
      ,name
      ,seq
      ,type
      ,group_name
      ,mv_refresh_hr
      ,ts_onln_data
      ,ts_onln_indx
      ,ts_hist_data
      ,ts_hist_indx
      ,description
      )
   as select
       TAB.id
      ,TAB.application_id
      ,APP.abbr
      ,TAB.abbr
      ,TAB.name
      ,TAB.seq
      ,TAB.type
      ,TAB.group_name
      ,TAB.mv_refresh_hr
      ,TAB.ts_onln_data
      ,TAB.ts_onln_indx
      ,TAB.ts_hist_data
      ,TAB.ts_hist_indx
      ,TAB.description
 from             tables TAB
       inner join applications APP on APP.id = TAB.application_id
 ;
select 'TABLES_ACT' as "View:"
 from  user_errors
 where name = 'TABLES_ACT'
  and  type = 'VIEW'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'TABLES_ACT'
  and  type = 'VIEW'
 order by sequence;

comment on table tables_act is 'Tables to be generated for each application';

comment on column tables_act.id is 'Surrogate Primary Key for these tables_act';
comment on column tables_act.application_id is 'Surrogate Key for the application of this table';
comment on column tables_act.abbr is 'Abbreviation for this table';
comment on column tables_act.name is 'Name of this table';
comment on column tables_act.seq is 'Report order for this table';
comment on column tables_act.type is 'Type of this table';
comment on column tables_act.group_name is 'Group Name for this table.';
comment on column tables_act.mv_refresh_hr is 'Number of Hours between Materialized View Refresh';
comment on column tables_act.ts_onln_data is 'Tablespace name for the on-line data for this table';
comment on column tables_act.ts_onln_indx is 'Tablespace name for the on-line indexes for this table';
comment on column tables_act.ts_hist_data is 'Tablespace name for the history data for this table';
comment on column tables_act.ts_hist_indx is 'Tablespace name for the history indexes for this table';
comment on column tables_act.description is 'Description of this table';
comment on column tables_act.applications_nk1 is 'APPLICATIONS Natural Key Value 1: Abbreviation for this application';

alter view tables_act add constraint tables_act_pk
   primary key (id) disable;

alter view tables_act add constraint tables_act_fk1
   foreign key (application_id) references applications_act (id) disable;

create TRIGGER tables_ioi
   instead of insert on tables_act
   for each row
declare
   n_id  NUMBER(38);
   n_application_id  NUMBER(38);
   n_abbr  VARCHAR2(5);
   n_name  VARCHAR2(15);
   n_seq  NUMBER(2);
   n_type  VARCHAR2(3);
   n_group_name  VARCHAR2(30);
   n_mv_refresh_hr  NUMBER(3,1);
   n_ts_onln_data  VARCHAR2(30);
   n_ts_onln_indx  VARCHAR2(30);
   n_ts_hist_data  VARCHAR2(30);
   n_ts_hist_indx  VARCHAR2(30);
   n_description  VARCHAR2(1000);
begin

   -- Trigger Tables_Ioi
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:19 PM

   n_id := :new.id;
   n_application_id := :new.application_id;
   n_abbr := :new.abbr;
   n_name := :new.name;
   n_seq := :new.seq;
   n_type := :new.type;
   n_group_name := :new.group_name;
   n_mv_refresh_hr := :new.mv_refresh_hr;
   n_ts_onln_data := :new.ts_onln_data;
   n_ts_onln_indx := :new.ts_onln_indx;
   n_ts_hist_data := :new.ts_hist_data;
   n_ts_hist_indx := :new.ts_hist_indx;
   n_description := :new.description;
   tables_view.ins
      (n_id
      ,n_application_id
      ,:new.applications_nk1
      ,n_abbr
      ,n_name
      ,n_seq
      ,n_type
      ,n_group_name
      ,n_mv_refresh_hr
      ,n_ts_onln_data
      ,n_ts_onln_indx
      ,n_ts_hist_data
      ,n_ts_hist_indx
      ,n_description
      );
end tables_ioi;
/
select 'TABLES_IOI' as "Trigger:"
 from  user_errors
 where name = 'TABLES_IOI'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'TABLES_IOI'
  and  type = 'TRIGGER'
 order by sequence;

create TRIGGER tables_iou
   instead of update on tables_act
   for each row
declare
   n_application_id  NUMBER(38);
   n_abbr  VARCHAR2(5);
   n_name  VARCHAR2(15);
   n_seq  NUMBER(2);
   n_type  VARCHAR2(3);
   n_group_name  VARCHAR2(30);
   n_mv_refresh_hr  NUMBER(3,1);
   n_ts_onln_data  VARCHAR2(30);
   n_ts_onln_indx  VARCHAR2(30);
   n_ts_hist_data  VARCHAR2(30);
   n_ts_hist_indx  VARCHAR2(30);
   n_description  VARCHAR2(1000);
begin

   -- Trigger Tables_Iou
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:19 PM

   n_application_id := :new.application_id;
   n_abbr := :new.abbr;
   n_name := :new.name;
   n_seq := :new.seq;
   n_type := :new.type;
   n_group_name := :new.group_name;
   n_mv_refresh_hr := :new.mv_refresh_hr;
   n_ts_onln_data := :new.ts_onln_data;
   n_ts_onln_indx := :new.ts_onln_indx;
   n_ts_hist_data := :new.ts_hist_data;
   n_ts_hist_indx := :new.ts_hist_indx;
   n_description := :new.description;
   tables_view.upd
      (:old.id
      ,:old.application_id
      ,:old.applications_nk1
      ,n_application_id
      ,:new.applications_nk1
      ,:old.abbr
      ,n_abbr
      ,:old.name
      ,n_name
      ,:old.seq
      ,n_seq
      ,:old.type
      ,n_type
      ,:old.group_name
      ,n_group_name
      ,:old.mv_refresh_hr
      ,n_mv_refresh_hr
      ,:old.ts_onln_data
      ,n_ts_onln_data
      ,:old.ts_onln_indx
      ,n_ts_onln_indx
      ,:old.ts_hist_data
      ,n_ts_hist_data
      ,:old.ts_hist_indx
      ,n_ts_hist_indx
      ,:old.description
      ,n_description
      );
end tables_iou;
/
select 'TABLES_IOU' as "Trigger:"
 from  user_errors
 where name = 'TABLES_IOU'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'TABLES_IOU'
  and  type = 'TRIGGER'
 order by sequence;

create TRIGGER tables_iod
   instead of delete on tables_act
   for each row
begin

   -- Trigger Tables_Iod
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:19 PM

   tables_view.del
      (:old.id
      ,:old.application_id
      ,:old.abbr
      ,:old.name
      ,:old.seq
      ,:old.type
      ,:old.group_name
      ,:old.mv_refresh_hr
      ,:old.ts_onln_data
      ,:old.ts_onln_indx
      ,:old.ts_hist_data
      ,:old.ts_hist_indx
      ,:old.description
      );
end tables_iod;
/
select 'TABLES_IOD' as "Trigger:"
 from  user_errors
 where name = 'TABLES_IOD'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'TABLES_IOD'
  and  type = 'TRIGGER'
 order by sequence;

create package body tables_view
is

-- Package Body Tables_View
--    View functions
--    (DML, Foreign Keys, Paths, and )
--
--    Generated by DTGen (http://code.google.com/p/dtgen)
--    July      27, 2012  09:34:19 PM

----------------------------------------
procedure ins
      (n_id  in out  NUMBER
      ,n_application_id  in out  NUMBER
      ,n_applications_nk1  in  VARCHAR2
      ,n_abbr  in out  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,n_seq  in out  NUMBER
      ,n_type  in out  VARCHAR2
      ,n_group_name  in out  VARCHAR2
      ,n_mv_refresh_hr  in out  NUMBER
      ,n_ts_onln_data  in out  VARCHAR2
      ,n_ts_onln_indx  in out  VARCHAR2
      ,n_ts_hist_data  in out  VARCHAR2
      ,n_ts_hist_indx  in out  VARCHAR2
      ,n_description  in out  VARCHAR2
      )
   -- View insert procedure
is
begin
   if util.db_object_exists('TABLES', 'MATERIALIZED VIEW')
   then
      raise_application_error(-20010, 'Insert not allowed on materialized view tables.  Inserts on tables must be performed on the central database.');
   end if;
   -- Set n_application_id, if needed
   if     n_application_id is null
      and n_applications_nk1 is not null
   then
      n_application_id :=
         applications_dml.get_id
            (n_applications_nk1
            );
   end if;
   if not glob.get_db_constraints
   then
      tables_tab.ins
         (n_id
         ,n_application_id
         ,n_abbr
         ,n_name
         ,n_seq
         ,n_type
         ,n_group_name
         ,n_mv_refresh_hr
         ,n_ts_onln_data
         ,n_ts_onln_indx
         ,n_ts_hist_data
         ,n_ts_hist_indx
         ,n_description
         );
   end if;
   insert into tables
         (id
         ,application_id
         ,abbr
         ,name
         ,seq
         ,type
         ,group_name
         ,mv_refresh_hr
         ,ts_onln_data
         ,ts_onln_indx
         ,ts_hist_data
         ,ts_hist_indx
         ,description
         )
   values
         (n_id
         ,n_application_id
         ,n_abbr
         ,n_name
         ,n_seq
         ,n_type
         ,n_group_name
         ,n_mv_refresh_hr
         ,n_ts_onln_data
         ,n_ts_onln_indx
         ,n_ts_hist_data
         ,n_ts_hist_indx
         ,n_description
         );
end ins;
----------------------------------------
procedure upd
      (o_id  in  NUMBER
      ,o_application_id  in  NUMBER
      ,o_applications_nk1  in  VARCHAR2
      ,n_application_id  in out  NUMBER
      ,n_applications_nk1  in  VARCHAR2
      ,o_abbr  in  VARCHAR2
      ,n_abbr  in out  VARCHAR2
      ,o_name  in  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,o_seq  in  NUMBER
      ,n_seq  in out  NUMBER
      ,o_type  in  VARCHAR2
      ,n_type  in out  VARCHAR2
      ,o_group_name  in  VARCHAR2
      ,n_group_name  in out  VARCHAR2
      ,o_mv_refresh_hr  in  NUMBER
      ,n_mv_refresh_hr  in out  NUMBER
      ,o_ts_onln_data  in  VARCHAR2
      ,n_ts_onln_data  in out  VARCHAR2
      ,o_ts_onln_indx  in  VARCHAR2
      ,n_ts_onln_indx  in out  VARCHAR2
      ,o_ts_hist_data  in  VARCHAR2
      ,n_ts_hist_data  in out  VARCHAR2
      ,o_ts_hist_indx  in  VARCHAR2
      ,n_ts_hist_indx  in out  VARCHAR2
      ,o_description  in  VARCHAR2
      ,n_description  in out  VARCHAR2
      )
   -- View Update procedure
is
begin
   if util.db_object_exists('TABLES', 'MATERIALIZED VIEW')
   then
      raise_application_error(-20010, 'Update not allowed on materialized view tables.  Updates on tables must be performed on the central database.');
   end if;
   -- Set n_application_id, if needed
   if     n_application_id = o_application_id
      and (   not (n_applications_nk1 = o_applications_nk1)
          )
   then
      n_application_id :=
         applications_dml.get_id
            (n_applications_nk1
            );
   end if;
   if not glob.get_db_constraints
   then
      tables_tab.upd
         (o_id
         ,o_application_id
         ,n_application_id
         ,o_abbr
         ,n_abbr
         ,o_name
         ,n_name
         ,o_seq
         ,n_seq
         ,o_type
         ,n_type
         ,o_group_name
         ,n_group_name
         ,o_mv_refresh_hr
         ,n_mv_refresh_hr
         ,o_ts_onln_data
         ,n_ts_onln_data
         ,o_ts_onln_indx
         ,n_ts_onln_indx
         ,o_ts_hist_data
         ,n_ts_hist_data
         ,o_ts_hist_indx
         ,n_ts_hist_indx
         ,o_description
         ,n_description
         );
   end if;
   update tables TAB
     set  TAB.application_id = n_application_id
         ,TAB.abbr = n_abbr
         ,TAB.name = n_name
         ,TAB.seq = n_seq
         ,TAB.type = n_type
         ,TAB.group_name = n_group_name
         ,TAB.mv_refresh_hr = n_mv_refresh_hr
         ,TAB.ts_onln_data = n_ts_onln_data
         ,TAB.ts_onln_indx = n_ts_onln_indx
         ,TAB.ts_hist_data = n_ts_hist_data
         ,TAB.ts_hist_indx = n_ts_hist_indx
         ,TAB.description = n_description
    where TAB.id = o_id;
end upd;
----------------------------------------
procedure del
      (o_id  in  NUMBER
      ,o_application_id  in  NUMBER
      ,o_abbr  in  VARCHAR2
      ,o_name  in  VARCHAR2
      ,o_seq  in  NUMBER
      ,o_type  in  VARCHAR2
      ,o_group_name  in  VARCHAR2
      ,o_mv_refresh_hr  in  NUMBER
      ,o_ts_onln_data  in  VARCHAR2
      ,o_ts_onln_indx  in  VARCHAR2
      ,o_ts_hist_data  in  VARCHAR2
      ,o_ts_hist_indx  in  VARCHAR2
      ,o_description  in  VARCHAR2
      )
is
begin
   if util.db_object_exists('TABLES', 'MATERIALIZED VIEW')
   then
      raise_application_error(-20010, 'Delete not allowed on materialized view tables.  Deletes on tables must be performed on the central database.');
   end if;
   if not glob.get_db_constraints
   then
      tables_tab.del
         (o_id
         ,o_application_id
         ,o_abbr
         ,o_name
         ,o_seq
         ,o_type
         ,o_group_name
         ,o_mv_refresh_hr
         ,o_ts_onln_data
         ,o_ts_onln_indx
         ,o_ts_hist_data
         ,o_ts_hist_indx
         ,o_description
         );
   end if;
   delete from tables  TAB
    where TAB.id = o_id;
end del;
----------------------------------------
end tables_view;
/
select 'TABLES_VIEW' as "Package Body:"
 from  user_errors
 where name = 'TABLES_VIEW'
  and  type = 'PACKAGE BODY'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'TABLES_VIEW'
  and  type = 'PACKAGE BODY'
 order by sequence;

create package body tables_dml
is

 -- Package Body Tables_Dml
 -- (Data Manipulation Language, Foreign Key and Path Lookup)

 --    Generated by DTGen (http://code.google.com/p/dtgen)
 --    July      27, 2012  09:34:20 PM

----------------------------------------
function get_next_id
      return number
is
   retid  number;
begin
   select tables_seq.nextval into retid from dual;
   return retid;
end get_next_id;
----------------------------------------
function get_curr_id
      return number
is
   retid  number;
begin
   select tables_seq.currval into retid from dual;
   return retid;
end get_curr_id;
----------------------------------------
function get_id
      (tables_nk1  in  VARCHAR2
      ,tables_nk2  in  VARCHAR2
      ) return number
   -- For all the Natural Key Columns, Return an ID
is
   retid  number(38);
begin
   select id
    into  retid
    from  tables  TAB
    where TAB.application_id = applications_dml.get_id
             (tables_nk1
             )
     and  TAB.abbr = tables_nk2
    ;
   return retid;
exception
   when no_data_found
   then
      return null;
   when others
   then
      raise;
end get_id;
----------------------------------------
function get_nk
      (id_in  in  number)
   return varchar2
   -- For an ID, return a delimited list of Natural Key Values
is
   rtxt  varchar2(32767);
begin
   select substr(   applications_dml.get_nk(TAB.application_id)
    || util.nk_sep || TAB.abbr
                         ,1,32767)
    into  rtxt
    from  tables TAB
    where TAB.id = id_in;
   return rtxt;
exception
   when no_data_found then
      return null;
   when others then
      raise;
end get_nk;
----------------------------------------
function tab_to_col
      (id_in  in  number)
   return col_type
is
   -- This function is duplicated in tables_POP
   cursor acur is
      select * from tables
       where id = id_in;
   abuf   acur%ROWTYPE;
   rcol      col_type;
begin
   open acur;
   fetch acur into abuf;
   if acur%NOTFOUND
   then
      rcol := COL_TYPE(null);
      close acur;
      return rcol;
   end if;
   rcol := COL_TYPE
             (PAIR_TYPE('application_id', to_char(abuf.application_id))
             ,PAIR_TYPE('abbr', abuf.abbr)
             ,PAIR_TYPE('name', abuf.name)
             ,PAIR_TYPE('seq', to_char(abuf.seq))
             ,PAIR_TYPE('type', abuf.type)
             ,PAIR_TYPE('group_name', abuf.group_name)
             ,PAIR_TYPE('mv_refresh_hr', to_char(abuf.mv_refresh_hr))
             ,PAIR_TYPE('ts_onln_data', abuf.ts_onln_data)
             ,PAIR_TYPE('ts_onln_indx', abuf.ts_onln_indx)
             ,PAIR_TYPE('ts_hist_data', abuf.ts_hist_data)
             ,PAIR_TYPE('ts_hist_indx', abuf.ts_hist_indx)
             ,PAIR_TYPE('description', abuf.description)
                );
   close acur;
   return rcol;
end tab_to_col;
----------------------------------------
procedure ins
      (n_id  in out  NUMBER
      ,n_application_id  in out  NUMBER
      ,n_applications_nk1_in  in  VARCHAR2  default null
      ,n_abbr  in out  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,n_seq  in out  NUMBER
      ,n_type  in out  VARCHAR2
      ,n_group_name  in out  VARCHAR2
      ,n_mv_refresh_hr  in out  NUMBER
      ,n_ts_onln_data  in out  VARCHAR2
      ,n_ts_onln_indx  in out  VARCHAR2
      ,n_ts_hist_data  in out  VARCHAR2
      ,n_ts_hist_indx  in out  VARCHAR2
      ,n_description  in out  VARCHAR2
      )
   -- Application Insert procedure
is
begin
   tables_view.ins
      (n_id
      ,n_application_id
      ,n_applications_nk1_in
      ,n_abbr
      ,n_name
      ,n_seq
      ,n_type
      ,n_group_name
      ,n_mv_refresh_hr
      ,n_ts_onln_data
      ,n_ts_onln_indx
      ,n_ts_hist_data
      ,n_ts_hist_indx
      ,n_description
      );
end ins;
----------------------------------------
procedure upd
      (o_id_in  in  NUMBER
      ,n_application_id  in out  NUMBER
      ,n_applications_nk1_in  in  VARCHAR2  default null
      ,n_abbr  in out  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,n_seq  in out  NUMBER
      ,n_type  in out  VARCHAR2
      ,n_group_name  in out  VARCHAR2
      ,n_mv_refresh_hr  in out  NUMBER
      ,n_ts_onln_data  in out  VARCHAR2
      ,n_ts_onln_indx  in out  VARCHAR2
      ,n_ts_hist_data  in out  VARCHAR2
      ,n_ts_hist_indx  in out  VARCHAR2
      ,n_description  in out  VARCHAR2
      ,nkdata_provided_in  in   VARCHAR2  default null
      )
   -- Application Update procedure
is
   o_application_id  NUMBER(38);
   o_applications_nk1  VARCHAR2(5);
   n_applications_nk1  VARCHAR2(5);
   o_abbr  VARCHAR2(5);
   o_name  VARCHAR2(15);
   o_seq  NUMBER(2);
   o_type  VARCHAR2(3);
   o_group_name  VARCHAR2(30);
   o_mv_refresh_hr  NUMBER(3,1);
   o_ts_onln_data  VARCHAR2(30);
   o_ts_onln_indx  VARCHAR2(30);
   o_ts_hist_data  VARCHAR2(30);
   o_ts_hist_indx  VARCHAR2(30);
   o_description  VARCHAR2(1000);
begin
   -- Retrieve the old (before update) data
   select TAB.application_id
         ,TAB.applications_nk1
         ,TAB.abbr
         ,TAB.name
         ,TAB.seq
         ,TAB.type
         ,TAB.group_name
         ,TAB.mv_refresh_hr
         ,TAB.ts_onln_data
         ,TAB.ts_onln_indx
         ,TAB.ts_hist_data
         ,TAB.ts_hist_indx
         ,TAB.description
    into  o_application_id
         ,o_applications_nk1
         ,o_abbr
         ,o_name
         ,o_seq
         ,o_type
         ,o_group_name
         ,o_mv_refresh_hr
         ,o_ts_onln_data
         ,o_ts_onln_indx
         ,o_ts_hist_data
         ,o_ts_hist_indx
         ,o_description
    from  tables_act  TAB
    where TAB.id = o_id_in;
   -- Set the Natural Key data as indicated by NKDATA_PROVIDED
   if upper(substr(nkdata_provided_in,1,1)) in ('Y','T')
   then
      -- Use the Natural Key Data that was provided
      n_applications_nk1 := n_applications_nk1_in;
   else
      -- Use the old Natural Key Data
      n_applications_nk1 := o_applications_nk1;
   end if;
   -- Run the update
   tables_view.upd
      (o_id_in
      ,o_application_id
      ,o_applications_nk1
      ,n_application_id
      ,n_applications_nk1
      ,o_abbr
      ,n_abbr
      ,o_name
      ,n_name
      ,o_seq
      ,n_seq
      ,o_type
      ,n_type
      ,o_group_name
      ,n_group_name
      ,o_mv_refresh_hr
      ,n_mv_refresh_hr
      ,o_ts_onln_data
      ,n_ts_onln_data
      ,o_ts_onln_indx
      ,n_ts_onln_indx
      ,o_ts_hist_data
      ,n_ts_hist_data
      ,o_ts_hist_indx
      ,n_ts_hist_indx
      ,o_description
      ,n_description
      );
end upd;
----------------------------------------
procedure del
      (o_id_in  in  NUMBER
      )
   -- Application Delete procedure
is
   o_application_id  NUMBER(38);
   o_abbr  VARCHAR2(5);
   o_name  VARCHAR2(15);
   o_seq  NUMBER(2);
   o_type  VARCHAR2(3);
   o_group_name  VARCHAR2(30);
   o_mv_refresh_hr  NUMBER(3,1);
   o_ts_onln_data  VARCHAR2(30);
   o_ts_onln_indx  VARCHAR2(30);
   o_ts_hist_data  VARCHAR2(30);
   o_ts_hist_indx  VARCHAR2(30);
   o_description  VARCHAR2(1000);
begin
   select TAB.application_id
         ,TAB.abbr
         ,TAB.name
         ,TAB.seq
         ,TAB.type
         ,TAB.group_name
         ,TAB.mv_refresh_hr
         ,TAB.ts_onln_data
         ,TAB.ts_onln_indx
         ,TAB.ts_hist_data
         ,TAB.ts_hist_indx
         ,TAB.description
    into  o_application_id
         ,o_abbr
         ,o_name
         ,o_seq
         ,o_type
         ,o_group_name
         ,o_mv_refresh_hr
         ,o_ts_onln_data
         ,o_ts_onln_indx
         ,o_ts_hist_data
         ,o_ts_hist_indx
         ,o_description
    from  tables  TAB
    where TAB.id = o_id_in;
   tables_view.del
      (o_id_in
      ,o_application_id
      ,o_abbr
      ,o_name
      ,o_seq
      ,o_type
      ,o_group_name
      ,o_mv_refresh_hr
      ,o_ts_onln_data
      ,o_ts_onln_indx
      ,o_ts_hist_data
      ,o_ts_hist_indx
      ,o_description
      );
end del;
----------------------------------------
end tables_dml;
/
select 'TABLES_DML' as "Package Body:"
 from  user_errors
 where name = 'TABLES_DML'
  and  type = 'PACKAGE BODY'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'TABLES_DML'
  and  type = 'PACKAGE BODY'
 order by sequence;

----------------------------------------
select '***  tab_cols  ***' as TABLE_NAME from dual;
----------------------------------------

create package tab_cols_view
is

   -- Package Tab_Cols_View
   --    View functions
   --    (DML, Foreign Keys, Paths, and )
   --
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:21 PM

   procedure ins
      (n_id  in out  NUMBER
      ,n_table_id  in out  NUMBER
      ,n_tables_nk1  in  VARCHAR2
      ,n_tables_nk2  in  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,n_seq  in out  NUMBER
      ,n_nk  in out  NUMBER
      ,n_req  in out  VARCHAR2
      ,n_fk_prefix  in out  VARCHAR2
      ,n_fk_table_id  in out  NUMBER
      ,n_fk_tables_nk1  in  VARCHAR2
      ,n_fk_tables_nk2  in  VARCHAR2
      ,n_d_domain_id  in out  NUMBER
      ,n_d_domains_nk1  in  VARCHAR2
      ,n_d_domains_nk2  in  VARCHAR2
      ,n_type  in out  VARCHAR2
      ,n_len  in out  NUMBER
      ,n_scale  in out  NUMBER
      ,n_fold  in out  VARCHAR2
      ,n_default_value  in out  VARCHAR2
      ,n_upd_res_pct  in out  NUMBER
      ,n_description  in out  VARCHAR2
      );
   procedure upd
      (o_id  in  NUMBER
      ,o_table_id  in  NUMBER
      ,o_tables_nk1  in  VARCHAR2
      ,o_tables_nk2  in  VARCHAR2
      ,n_table_id  in out  NUMBER
      ,n_tables_nk1  in  VARCHAR2
      ,n_tables_nk2  in  VARCHAR2
      ,o_name  in  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,o_seq  in  NUMBER
      ,n_seq  in out  NUMBER
      ,o_nk  in  NUMBER
      ,n_nk  in out  NUMBER
      ,o_req  in  VARCHAR2
      ,n_req  in out  VARCHAR2
      ,o_fk_prefix  in  VARCHAR2
      ,n_fk_prefix  in out  VARCHAR2
      ,o_fk_table_id  in  NUMBER
      ,o_fk_tables_nk1  in  VARCHAR2
      ,o_fk_tables_nk2  in  VARCHAR2
      ,n_fk_table_id  in out  NUMBER
      ,n_fk_tables_nk1  in  VARCHAR2
      ,n_fk_tables_nk2  in  VARCHAR2
      ,o_d_domain_id  in  NUMBER
      ,o_d_domains_nk1  in  VARCHAR2
      ,o_d_domains_nk2  in  VARCHAR2
      ,n_d_domain_id  in out  NUMBER
      ,n_d_domains_nk1  in  VARCHAR2
      ,n_d_domains_nk2  in  VARCHAR2
      ,o_type  in  VARCHAR2
      ,n_type  in out  VARCHAR2
      ,o_len  in  NUMBER
      ,n_len  in out  NUMBER
      ,o_scale  in  NUMBER
      ,n_scale  in out  NUMBER
      ,o_fold  in  VARCHAR2
      ,n_fold  in out  VARCHAR2
      ,o_default_value  in  VARCHAR2
      ,n_default_value  in out  VARCHAR2
      ,o_upd_res_pct  in  NUMBER
      ,n_upd_res_pct  in out  NUMBER
      ,o_description  in  VARCHAR2
      ,n_description  in out  VARCHAR2
      );
   procedure del
      (o_id  in  NUMBER
      ,o_table_id  in  NUMBER
      ,o_name  in  VARCHAR2
      ,o_seq  in  NUMBER
      ,o_nk  in  NUMBER
      ,o_req  in  VARCHAR2
      ,o_fk_prefix  in  VARCHAR2
      ,o_fk_table_id  in  NUMBER
      ,o_d_domain_id  in  NUMBER
      ,o_type  in  VARCHAR2
      ,o_len  in  NUMBER
      ,o_scale  in  NUMBER
      ,o_fold  in  VARCHAR2
      ,o_default_value  in  VARCHAR2
      ,o_upd_res_pct  in  NUMBER
      ,o_description  in  VARCHAR2
      );
end tab_cols_view;
/
select 'TAB_COLS_VIEW' as "Package:"
 from  user_errors
 where name = 'TAB_COLS_VIEW'
  and  type = 'PACKAGE'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'TAB_COLS_VIEW'
  and  type = 'PACKAGE'
 order by sequence;

create package tab_cols_dml
is

   -- Package Tab_Cols_Dml
   -- (Data Manipulation Language, Foreign Key and Path Lookup)

   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:21 PM

   function get_next_id
      return number;
   function get_curr_id
      return number;

   function get_id
      (tab_cols_nk1  in  VARCHAR2
      ,tab_cols_nk2  in  VARCHAR2
      ,tab_cols_nk3  in  VARCHAR2
      ) return number;
   function get_nk
      (id_in  in  number
      ) return varchar2;

   function tab_to_col
         (id_in  in  number)
      return col_type;

   procedure ins
      (n_id  in out  NUMBER
      ,n_table_id  in out  NUMBER
      ,n_tables_nk1_in  in  VARCHAR2  default null
      ,n_tables_nk2_in  in  VARCHAR2  default null
      ,n_name  in out  VARCHAR2
      ,n_seq  in out  NUMBER
      ,n_nk  in out  NUMBER
      ,n_req  in out  VARCHAR2
      ,n_fk_prefix  in out  VARCHAR2
      ,n_fk_table_id  in out  NUMBER
      ,n_fk_tables_nk1_in  in  VARCHAR2  default null
      ,n_fk_tables_nk2_in  in  VARCHAR2  default null
      ,n_d_domain_id  in out  NUMBER
      ,n_d_domains_nk1_in  in  VARCHAR2  default null
      ,n_d_domains_nk2_in  in  VARCHAR2  default null
      ,n_type  in out  VARCHAR2
      ,n_len  in out  NUMBER
      ,n_scale  in out  NUMBER
      ,n_fold  in out  VARCHAR2
      ,n_default_value  in out  VARCHAR2
      ,n_upd_res_pct  in out  NUMBER
      ,n_description  in out  VARCHAR2
      );
   procedure upd
      (o_id_in  in  NUMBER
      ,n_table_id  in out  NUMBER
      ,n_tables_nk1_in  in  VARCHAR2  default null
      ,n_tables_nk2_in  in  VARCHAR2  default null
      ,n_name  in out  VARCHAR2
      ,n_seq  in out  NUMBER
      ,n_nk  in out  NUMBER
      ,n_req  in out  VARCHAR2
      ,n_fk_prefix  in out  VARCHAR2
      ,n_fk_table_id  in out  NUMBER
      ,n_fk_tables_nk1_in  in  VARCHAR2  default null
      ,n_fk_tables_nk2_in  in  VARCHAR2  default null
      ,n_d_domain_id  in out  NUMBER
      ,n_d_domains_nk1_in  in  VARCHAR2  default null
      ,n_d_domains_nk2_in  in  VARCHAR2  default null
      ,n_type  in out  VARCHAR2
      ,n_len  in out  NUMBER
      ,n_scale  in out  NUMBER
      ,n_fold  in out  VARCHAR2
      ,n_default_value  in out  VARCHAR2
      ,n_upd_res_pct  in out  NUMBER
      ,n_description  in out  VARCHAR2
      ,nkdata_provided_in  in   VARCHAR2  default null
      );
   procedure del
      (o_id_in  in  NUMBER
      );
end tab_cols_dml;
/
select 'TAB_COLS_DML' as "Package:"
 from  user_errors
 where name = 'TAB_COLS_DML'
  and  type = 'PACKAGE'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'TAB_COLS_DML'
  and  type = 'PACKAGE'
 order by sequence;

create view tab_cols_act
      (id
      ,table_id
      ,tables_nk1
      ,tables_nk2
      ,name
      ,seq
      ,nk
      ,req
      ,fk_prefix
      ,fk_table_id
      ,fk_tables_nk1
      ,fk_tables_nk2
      ,d_domain_id
      ,d_domains_nk1
      ,d_domains_nk2
      ,type
      ,len
      ,scale
      ,fold
      ,default_value
      ,upd_res_pct
      ,description
      )
   as select
       COL.id
      ,COL.table_id
      ,APP.abbr
      ,TAB.abbr
      ,COL.name
      ,COL.seq
      ,COL.nk
      ,COL.req
      ,COL.fk_prefix
      ,COL.fk_table_id
      ,fk_APP.abbr
      ,fk_TAB.abbr
      ,COL.d_domain_id
      ,d_APP.abbr
      ,d_DOM.abbr
      ,COL.type
      ,COL.len
      ,COL.scale
      ,COL.fold
      ,COL.default_value
      ,COL.upd_res_pct
      ,COL.description
 from             tab_cols COL
       inner join tables TAB on TAB.id = COL.table_id
       inner join applications APP on APP.id = TAB.application_id
  left outer join tables fk_TAB on fk_TAB.id = COL.fk_table_id
  left outer join applications fk_APP on fk_APP.id = fk_TAB.application_id
  left outer join domains d_DOM on d_DOM.id = COL.d_domain_id
  left outer join applications d_APP on d_APP.id = d_DOM.application_id
 ;
select 'TAB_COLS_ACT' as "View:"
 from  user_errors
 where name = 'TAB_COLS_ACT'
  and  type = 'VIEW'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'TAB_COLS_ACT'
  and  type = 'VIEW'
 order by sequence;

comment on table tab_cols_act is 'Columns to be generated for each table';

comment on column tab_cols_act.id is 'Surrogate Primary Key for these tab_cols_act';
comment on column tab_cols_act.table_id is 'Surrogate Key for the table of this column';
comment on column tab_cols_act.name is 'Name of this column';
comment on column tab_cols_act.seq is 'Sequence number for this column';
comment on column tab_cols_act.nk is 'Natural key sequence number for this column.  Implies this column requires data (not null).';
comment on column tab_cols_act.req is 'Flag to indicate if this column is required';
comment on column tab_cols_act.fk_prefix is 'Foreign key prefix for multiple foreign keys to the same table';
comment on column tab_cols_act.fk_table_id is 'Surrogate Key for the foreign key table of this column';
comment on column tab_cols_act.d_domain_id is 'Surrogate Key for the domain of this column';
comment on column tab_cols_act.type is 'Type for this column';
comment on column tab_cols_act.len is 'The total number of significant decimal digits in a number, or the length of a string, or the number of digits for fractional seconds in a timestamp';
comment on column tab_cols_act.scale is 'The number of digits from the decimal point to the least significant digit';
comment on column tab_cols_act.fold is 'Flag to indicate if this column should be character case folded';
comment on column tab_cols_act.default_value is 'Default Value if no value is provided for this column';
comment on column tab_cols_act.upd_res_pct is 'Percentage of column space reserved for data updates';
comment on column tab_cols_act.description is 'Description for this column';
comment on column tab_cols_act.tables_nk1 is 'TABLES Natural Key Value 1: Abbreviation for this application';
comment on column tab_cols_act.tables_nk2 is 'TABLES Natural Key Value 2: Abbreviation for this table';
comment on column tab_cols_act.fk_tables_nk1 is 'TABLES Natural Key Value 1: Abbreviation for this application';
comment on column tab_cols_act.fk_tables_nk2 is 'TABLES Natural Key Value 2: Abbreviation for this table';
comment on column tab_cols_act.d_domains_nk1 is 'DOMAINS Natural Key Value 1: Abbreviation for this application';
comment on column tab_cols_act.d_domains_nk2 is 'DOMAINS Natural Key Value 2: Name of this data domain';

alter view tab_cols_act add constraint tab_cols_act_pk
   primary key (id) disable;

alter view tab_cols_act add constraint tab_cols_act_fk1
   foreign key (table_id) references tables_act (id) disable;
alter view tab_cols_act add constraint tab_cols_act_fk2
   foreign key (fk_table_id) references tables_act (id) disable;
alter view tab_cols_act add constraint tab_cols_act_fk3
   foreign key (d_domain_id) references domains_act (id) disable;

create TRIGGER tab_cols_ioi
   instead of insert on tab_cols_act
   for each row
declare
   n_id  NUMBER(38);
   n_table_id  NUMBER(38);
   n_name  VARCHAR2(25);
   n_seq  NUMBER(2);
   n_nk  NUMBER(1);
   n_req  VARCHAR2(1);
   n_fk_prefix  VARCHAR2(4);
   n_fk_table_id  NUMBER(38);
   n_d_domain_id  NUMBER(38);
   n_type  VARCHAR2(30);
   n_len  NUMBER(5);
   n_scale  NUMBER(3);
   n_fold  VARCHAR2(1);
   n_default_value  VARCHAR2(1000);
   n_upd_res_pct  NUMBER(2,0);
   n_description  VARCHAR2(1000);
begin

   -- Trigger Tab_Cols_Ioi
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:21 PM

   n_id := :new.id;
   n_table_id := :new.table_id;
   n_name := :new.name;
   n_seq := :new.seq;
   n_nk := :new.nk;
   n_req := :new.req;
   n_fk_prefix := :new.fk_prefix;
   n_fk_table_id := :new.fk_table_id;
   n_d_domain_id := :new.d_domain_id;
   n_type := :new.type;
   n_len := :new.len;
   n_scale := :new.scale;
   n_fold := :new.fold;
   n_default_value := :new.default_value;
   n_upd_res_pct := :new.upd_res_pct;
   n_description := :new.description;
   tab_cols_view.ins
      (n_id
      ,n_table_id
      ,:new.tables_nk1
      ,:new.tables_nk2
      ,n_name
      ,n_seq
      ,n_nk
      ,n_req
      ,n_fk_prefix
      ,n_fk_table_id
      ,:new.fk_tables_nk1
      ,:new.fk_tables_nk2
      ,n_d_domain_id
      ,:new.d_domains_nk1
      ,:new.d_domains_nk2
      ,n_type
      ,n_len
      ,n_scale
      ,n_fold
      ,n_default_value
      ,n_upd_res_pct
      ,n_description
      );
end tab_cols_ioi;
/
select 'TAB_COLS_IOI' as "Trigger:"
 from  user_errors
 where name = 'TAB_COLS_IOI'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'TAB_COLS_IOI'
  and  type = 'TRIGGER'
 order by sequence;

create TRIGGER tab_cols_iou
   instead of update on tab_cols_act
   for each row
declare
   n_table_id  NUMBER(38);
   n_name  VARCHAR2(25);
   n_seq  NUMBER(2);
   n_nk  NUMBER(1);
   n_req  VARCHAR2(1);
   n_fk_prefix  VARCHAR2(4);
   n_fk_table_id  NUMBER(38);
   n_d_domain_id  NUMBER(38);
   n_type  VARCHAR2(30);
   n_len  NUMBER(5);
   n_scale  NUMBER(3);
   n_fold  VARCHAR2(1);
   n_default_value  VARCHAR2(1000);
   n_upd_res_pct  NUMBER(2,0);
   n_description  VARCHAR2(1000);
begin

   -- Trigger Tab_Cols_Iou
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:21 PM

   n_table_id := :new.table_id;
   n_name := :new.name;
   n_seq := :new.seq;
   n_nk := :new.nk;
   n_req := :new.req;
   n_fk_prefix := :new.fk_prefix;
   n_fk_table_id := :new.fk_table_id;
   n_d_domain_id := :new.d_domain_id;
   n_type := :new.type;
   n_len := :new.len;
   n_scale := :new.scale;
   n_fold := :new.fold;
   n_default_value := :new.default_value;
   n_upd_res_pct := :new.upd_res_pct;
   n_description := :new.description;
   tab_cols_view.upd
      (:old.id
      ,:old.table_id
      ,:old.tables_nk1
      ,:old.tables_nk2
      ,n_table_id
      ,:new.tables_nk1
      ,:new.tables_nk2
      ,:old.name
      ,n_name
      ,:old.seq
      ,n_seq
      ,:old.nk
      ,n_nk
      ,:old.req
      ,n_req
      ,:old.fk_prefix
      ,n_fk_prefix
      ,:old.fk_table_id
      ,:old.fk_tables_nk1
      ,:old.fk_tables_nk2
      ,n_fk_table_id
      ,:new.fk_tables_nk1
      ,:new.fk_tables_nk2
      ,:old.d_domain_id
      ,:old.d_domains_nk1
      ,:old.d_domains_nk2
      ,n_d_domain_id
      ,:new.d_domains_nk1
      ,:new.d_domains_nk2
      ,:old.type
      ,n_type
      ,:old.len
      ,n_len
      ,:old.scale
      ,n_scale
      ,:old.fold
      ,n_fold
      ,:old.default_value
      ,n_default_value
      ,:old.upd_res_pct
      ,n_upd_res_pct
      ,:old.description
      ,n_description
      );
end tab_cols_iou;
/
select 'TAB_COLS_IOU' as "Trigger:"
 from  user_errors
 where name = 'TAB_COLS_IOU'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'TAB_COLS_IOU'
  and  type = 'TRIGGER'
 order by sequence;

create TRIGGER tab_cols_iod
   instead of delete on tab_cols_act
   for each row
begin

   -- Trigger Tab_Cols_Iod
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:21 PM

   tab_cols_view.del
      (:old.id
      ,:old.table_id
      ,:old.name
      ,:old.seq
      ,:old.nk
      ,:old.req
      ,:old.fk_prefix
      ,:old.fk_table_id
      ,:old.d_domain_id
      ,:old.type
      ,:old.len
      ,:old.scale
      ,:old.fold
      ,:old.default_value
      ,:old.upd_res_pct
      ,:old.description
      );
end tab_cols_iod;
/
select 'TAB_COLS_IOD' as "Trigger:"
 from  user_errors
 where name = 'TAB_COLS_IOD'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'TAB_COLS_IOD'
  and  type = 'TRIGGER'
 order by sequence;

create package body tab_cols_view
is

-- Package Body Tab_Cols_View
--    View functions
--    (DML, Foreign Keys, Paths, and )
--
--    Generated by DTGen (http://code.google.com/p/dtgen)
--    July      27, 2012  09:34:22 PM

----------------------------------------
procedure ins
      (n_id  in out  NUMBER
      ,n_table_id  in out  NUMBER
      ,n_tables_nk1  in  VARCHAR2
      ,n_tables_nk2  in  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,n_seq  in out  NUMBER
      ,n_nk  in out  NUMBER
      ,n_req  in out  VARCHAR2
      ,n_fk_prefix  in out  VARCHAR2
      ,n_fk_table_id  in out  NUMBER
      ,n_fk_tables_nk1  in  VARCHAR2
      ,n_fk_tables_nk2  in  VARCHAR2
      ,n_d_domain_id  in out  NUMBER
      ,n_d_domains_nk1  in  VARCHAR2
      ,n_d_domains_nk2  in  VARCHAR2
      ,n_type  in out  VARCHAR2
      ,n_len  in out  NUMBER
      ,n_scale  in out  NUMBER
      ,n_fold  in out  VARCHAR2
      ,n_default_value  in out  VARCHAR2
      ,n_upd_res_pct  in out  NUMBER
      ,n_description  in out  VARCHAR2
      )
   -- View insert procedure
is
begin
   if util.db_object_exists('TAB_COLS', 'MATERIALIZED VIEW')
   then
      raise_application_error(-20010, 'Insert not allowed on materialized view tab_cols.  Inserts on tab_cols must be performed on the central database.');
   end if;
   -- Set n_table_id, if needed
   if     n_table_id is null
      and n_tables_nk1 is not null
      and n_tables_nk2 is not null
   then
      n_table_id :=
         tables_dml.get_id
            (n_tables_nk1
            ,n_tables_nk2
            );
   end if;
   -- Set n_fk_table_id, if needed
   if     n_fk_table_id is null
      and n_fk_tables_nk1 is not null
      and n_fk_tables_nk2 is not null
   then
      n_fk_table_id :=
         tables_dml.get_id
            (n_fk_tables_nk1
            ,n_fk_tables_nk2
            );
   end if;
   -- Set n_d_domain_id, if needed
   if     n_d_domain_id is null
      and n_d_domains_nk1 is not null
      and n_d_domains_nk2 is not null
   then
      n_d_domain_id :=
         domains_dml.get_id
            (n_d_domains_nk1
            ,n_d_domains_nk2
            );
   end if;
   if not glob.get_db_constraints
   then
      tab_cols_tab.ins
         (n_id
         ,n_table_id
         ,n_name
         ,n_seq
         ,n_nk
         ,n_req
         ,n_fk_prefix
         ,n_fk_table_id
         ,n_d_domain_id
         ,n_type
         ,n_len
         ,n_scale
         ,n_fold
         ,n_default_value
         ,n_upd_res_pct
         ,n_description
         );
   end if;
   insert into tab_cols
         (id
         ,table_id
         ,name
         ,seq
         ,nk
         ,req
         ,fk_prefix
         ,fk_table_id
         ,d_domain_id
         ,type
         ,len
         ,scale
         ,fold
         ,default_value
         ,upd_res_pct
         ,description
         )
   values
         (n_id
         ,n_table_id
         ,n_name
         ,n_seq
         ,n_nk
         ,n_req
         ,n_fk_prefix
         ,n_fk_table_id
         ,n_d_domain_id
         ,n_type
         ,n_len
         ,n_scale
         ,n_fold
         ,n_default_value
         ,n_upd_res_pct
         ,n_description
         );
end ins;
----------------------------------------
procedure upd
      (o_id  in  NUMBER
      ,o_table_id  in  NUMBER
      ,o_tables_nk1  in  VARCHAR2
      ,o_tables_nk2  in  VARCHAR2
      ,n_table_id  in out  NUMBER
      ,n_tables_nk1  in  VARCHAR2
      ,n_tables_nk2  in  VARCHAR2
      ,o_name  in  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,o_seq  in  NUMBER
      ,n_seq  in out  NUMBER
      ,o_nk  in  NUMBER
      ,n_nk  in out  NUMBER
      ,o_req  in  VARCHAR2
      ,n_req  in out  VARCHAR2
      ,o_fk_prefix  in  VARCHAR2
      ,n_fk_prefix  in out  VARCHAR2
      ,o_fk_table_id  in  NUMBER
      ,o_fk_tables_nk1  in  VARCHAR2
      ,o_fk_tables_nk2  in  VARCHAR2
      ,n_fk_table_id  in out  NUMBER
      ,n_fk_tables_nk1  in  VARCHAR2
      ,n_fk_tables_nk2  in  VARCHAR2
      ,o_d_domain_id  in  NUMBER
      ,o_d_domains_nk1  in  VARCHAR2
      ,o_d_domains_nk2  in  VARCHAR2
      ,n_d_domain_id  in out  NUMBER
      ,n_d_domains_nk1  in  VARCHAR2
      ,n_d_domains_nk2  in  VARCHAR2
      ,o_type  in  VARCHAR2
      ,n_type  in out  VARCHAR2
      ,o_len  in  NUMBER
      ,n_len  in out  NUMBER
      ,o_scale  in  NUMBER
      ,n_scale  in out  NUMBER
      ,o_fold  in  VARCHAR2
      ,n_fold  in out  VARCHAR2
      ,o_default_value  in  VARCHAR2
      ,n_default_value  in out  VARCHAR2
      ,o_upd_res_pct  in  NUMBER
      ,n_upd_res_pct  in out  NUMBER
      ,o_description  in  VARCHAR2
      ,n_description  in out  VARCHAR2
      )
   -- View Update procedure
is
begin
   if util.db_object_exists('TAB_COLS', 'MATERIALIZED VIEW')
   then
      raise_application_error(-20010, 'Update not allowed on materialized view tab_cols.  Updates on tab_cols must be performed on the central database.');
   end if;
   -- Set n_table_id, if needed
   if     n_table_id = o_table_id
      and (   not (n_tables_nk1 = o_tables_nk1)
           or not (n_tables_nk2 = o_tables_nk2)
          )
   then
      n_table_id :=
         tables_dml.get_id
            (n_tables_nk1
            ,n_tables_nk2
            );
   end if;
   -- Set n_fk_table_id, if needed
   if     util.is_equal(n_fk_table_id, o_fk_table_id)
      and (   not util.is_equal(n_fk_tables_nk1, o_fk_tables_nk1)
           or not util.is_equal(n_fk_tables_nk2, o_fk_tables_nk2)
          )
   then
      n_fk_table_id :=
         tables_dml.get_id
            (n_fk_tables_nk1
            ,n_fk_tables_nk2
            );
   end if;
   -- Set n_d_domain_id, if needed
   if     util.is_equal(n_d_domain_id, o_d_domain_id)
      and (   not util.is_equal(n_d_domains_nk1, o_d_domains_nk1)
           or not util.is_equal(n_d_domains_nk2, o_d_domains_nk2)
          )
   then
      n_d_domain_id :=
         domains_dml.get_id
            (n_d_domains_nk1
            ,n_d_domains_nk2
            );
   end if;
   if not glob.get_db_constraints
   then
      tab_cols_tab.upd
         (o_id
         ,o_table_id
         ,n_table_id
         ,o_name
         ,n_name
         ,o_seq
         ,n_seq
         ,o_nk
         ,n_nk
         ,o_req
         ,n_req
         ,o_fk_prefix
         ,n_fk_prefix
         ,o_fk_table_id
         ,n_fk_table_id
         ,o_d_domain_id
         ,n_d_domain_id
         ,o_type
         ,n_type
         ,o_len
         ,n_len
         ,o_scale
         ,n_scale
         ,o_fold
         ,n_fold
         ,o_default_value
         ,n_default_value
         ,o_upd_res_pct
         ,n_upd_res_pct
         ,o_description
         ,n_description
         );
   end if;
   update tab_cols COL
     set  COL.table_id = n_table_id
         ,COL.name = n_name
         ,COL.seq = n_seq
         ,COL.nk = n_nk
         ,COL.req = n_req
         ,COL.fk_prefix = n_fk_prefix
         ,COL.fk_table_id = n_fk_table_id
         ,COL.d_domain_id = n_d_domain_id
         ,COL.type = n_type
         ,COL.len = n_len
         ,COL.scale = n_scale
         ,COL.fold = n_fold
         ,COL.default_value = n_default_value
         ,COL.upd_res_pct = n_upd_res_pct
         ,COL.description = n_description
    where COL.id = o_id;
end upd;
----------------------------------------
procedure del
      (o_id  in  NUMBER
      ,o_table_id  in  NUMBER
      ,o_name  in  VARCHAR2
      ,o_seq  in  NUMBER
      ,o_nk  in  NUMBER
      ,o_req  in  VARCHAR2
      ,o_fk_prefix  in  VARCHAR2
      ,o_fk_table_id  in  NUMBER
      ,o_d_domain_id  in  NUMBER
      ,o_type  in  VARCHAR2
      ,o_len  in  NUMBER
      ,o_scale  in  NUMBER
      ,o_fold  in  VARCHAR2
      ,o_default_value  in  VARCHAR2
      ,o_upd_res_pct  in  NUMBER
      ,o_description  in  VARCHAR2
      )
is
begin
   if util.db_object_exists('TAB_COLS', 'MATERIALIZED VIEW')
   then
      raise_application_error(-20010, 'Delete not allowed on materialized view tab_cols.  Deletes on tab_cols must be performed on the central database.');
   end if;
   if not glob.get_db_constraints
   then
      tab_cols_tab.del
         (o_id
         ,o_table_id
         ,o_name
         ,o_seq
         ,o_nk
         ,o_req
         ,o_fk_prefix
         ,o_fk_table_id
         ,o_d_domain_id
         ,o_type
         ,o_len
         ,o_scale
         ,o_fold
         ,o_default_value
         ,o_upd_res_pct
         ,o_description
         );
   end if;
   delete from tab_cols  COL
    where COL.id = o_id;
end del;
----------------------------------------
end tab_cols_view;
/
select 'TAB_COLS_VIEW' as "Package Body:"
 from  user_errors
 where name = 'TAB_COLS_VIEW'
  and  type = 'PACKAGE BODY'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'TAB_COLS_VIEW'
  and  type = 'PACKAGE BODY'
 order by sequence;

create package body tab_cols_dml
is

 -- Package Body Tab_Cols_Dml
 -- (Data Manipulation Language, Foreign Key and Path Lookup)

 --    Generated by DTGen (http://code.google.com/p/dtgen)
 --    July      27, 2012  09:34:22 PM

----------------------------------------
function get_next_id
      return number
is
   retid  number;
begin
   select tab_cols_seq.nextval into retid from dual;
   return retid;
end get_next_id;
----------------------------------------
function get_curr_id
      return number
is
   retid  number;
begin
   select tab_cols_seq.currval into retid from dual;
   return retid;
end get_curr_id;
----------------------------------------
function get_id
      (tab_cols_nk1  in  VARCHAR2
      ,tab_cols_nk2  in  VARCHAR2
      ,tab_cols_nk3  in  VARCHAR2
      ) return number
   -- For all the Natural Key Columns, Return an ID
is
   retid  number(38);
begin
   select id
    into  retid
    from  tab_cols  COL
    where COL.table_id = tables_dml.get_id
             (tab_cols_nk1
             ,tab_cols_nk2
             )
     and  COL.name = tab_cols_nk3
    ;
   return retid;
exception
   when no_data_found
   then
      return null;
   when others
   then
      raise;
end get_id;
----------------------------------------
function get_nk
      (id_in  in  number)
   return varchar2
   -- For an ID, return a delimited list of Natural Key Values
is
   rtxt  varchar2(32767);
begin
   select substr(   tables_dml.get_nk(COL.table_id)
    || util.nk_sep || COL.name
                         ,1,32767)
    into  rtxt
    from  tab_cols COL
    where COL.id = id_in;
   return rtxt;
exception
   when no_data_found then
      return null;
   when others then
      raise;
end get_nk;
----------------------------------------
function tab_to_col
      (id_in  in  number)
   return col_type
is
   -- This function is duplicated in tab_cols_POP
   cursor acur is
      select * from tab_cols
       where id = id_in;
   abuf   acur%ROWTYPE;
   rcol      col_type;
begin
   open acur;
   fetch acur into abuf;
   if acur%NOTFOUND
   then
      rcol := COL_TYPE(null);
      close acur;
      return rcol;
   end if;
   rcol := COL_TYPE
             (PAIR_TYPE('table_id', to_char(abuf.table_id))
             ,PAIR_TYPE('name', abuf.name)
             ,PAIR_TYPE('seq', to_char(abuf.seq))
             ,PAIR_TYPE('nk', to_char(abuf.nk))
             ,PAIR_TYPE('req', abuf.req)
             ,PAIR_TYPE('fk_prefix', abuf.fk_prefix)
             ,PAIR_TYPE('fk_table_id', to_char(abuf.fk_table_id))
             ,PAIR_TYPE('d_domain_id', to_char(abuf.d_domain_id))
             ,PAIR_TYPE('type', abuf.type)
             ,PAIR_TYPE('len', to_char(abuf.len))
             ,PAIR_TYPE('scale', to_char(abuf.scale))
             ,PAIR_TYPE('fold', abuf.fold)
             ,PAIR_TYPE('default_value', abuf.default_value)
             ,PAIR_TYPE('upd_res_pct', to_char(abuf.upd_res_pct))
             ,PAIR_TYPE('description', abuf.description)
                );
   close acur;
   return rcol;
end tab_to_col;
----------------------------------------
procedure ins
      (n_id  in out  NUMBER
      ,n_table_id  in out  NUMBER
      ,n_tables_nk1_in  in  VARCHAR2  default null
      ,n_tables_nk2_in  in  VARCHAR2  default null
      ,n_name  in out  VARCHAR2
      ,n_seq  in out  NUMBER
      ,n_nk  in out  NUMBER
      ,n_req  in out  VARCHAR2
      ,n_fk_prefix  in out  VARCHAR2
      ,n_fk_table_id  in out  NUMBER
      ,n_fk_tables_nk1_in  in  VARCHAR2  default null
      ,n_fk_tables_nk2_in  in  VARCHAR2  default null
      ,n_d_domain_id  in out  NUMBER
      ,n_d_domains_nk1_in  in  VARCHAR2  default null
      ,n_d_domains_nk2_in  in  VARCHAR2  default null
      ,n_type  in out  VARCHAR2
      ,n_len  in out  NUMBER
      ,n_scale  in out  NUMBER
      ,n_fold  in out  VARCHAR2
      ,n_default_value  in out  VARCHAR2
      ,n_upd_res_pct  in out  NUMBER
      ,n_description  in out  VARCHAR2
      )
   -- Application Insert procedure
is
begin
   tab_cols_view.ins
      (n_id
      ,n_table_id
      ,n_tables_nk1_in
      ,n_tables_nk2_in
      ,n_name
      ,n_seq
      ,n_nk
      ,n_req
      ,n_fk_prefix
      ,n_fk_table_id
      ,n_fk_tables_nk1_in
      ,n_fk_tables_nk2_in
      ,n_d_domain_id
      ,n_d_domains_nk1_in
      ,n_d_domains_nk2_in
      ,n_type
      ,n_len
      ,n_scale
      ,n_fold
      ,n_default_value
      ,n_upd_res_pct
      ,n_description
      );
end ins;
----------------------------------------
procedure upd
      (o_id_in  in  NUMBER
      ,n_table_id  in out  NUMBER
      ,n_tables_nk1_in  in  VARCHAR2  default null
      ,n_tables_nk2_in  in  VARCHAR2  default null
      ,n_name  in out  VARCHAR2
      ,n_seq  in out  NUMBER
      ,n_nk  in out  NUMBER
      ,n_req  in out  VARCHAR2
      ,n_fk_prefix  in out  VARCHAR2
      ,n_fk_table_id  in out  NUMBER
      ,n_fk_tables_nk1_in  in  VARCHAR2  default null
      ,n_fk_tables_nk2_in  in  VARCHAR2  default null
      ,n_d_domain_id  in out  NUMBER
      ,n_d_domains_nk1_in  in  VARCHAR2  default null
      ,n_d_domains_nk2_in  in  VARCHAR2  default null
      ,n_type  in out  VARCHAR2
      ,n_len  in out  NUMBER
      ,n_scale  in out  NUMBER
      ,n_fold  in out  VARCHAR2
      ,n_default_value  in out  VARCHAR2
      ,n_upd_res_pct  in out  NUMBER
      ,n_description  in out  VARCHAR2
      ,nkdata_provided_in  in   VARCHAR2  default null
      )
   -- Application Update procedure
is
   o_table_id  NUMBER(38);
   o_tables_nk1  VARCHAR2(5);
   o_tables_nk2  VARCHAR2(5);
   n_tables_nk1  VARCHAR2(5);
   n_tables_nk2  VARCHAR2(5);
   o_name  VARCHAR2(25);
   o_seq  NUMBER(2);
   o_nk  NUMBER(1);
   o_req  VARCHAR2(1);
   o_fk_prefix  VARCHAR2(4);
   o_fk_table_id  NUMBER(38);
   o_fk_tables_nk1  VARCHAR2(5);
   o_fk_tables_nk2  VARCHAR2(5);
   n_fk_tables_nk1  VARCHAR2(5);
   n_fk_tables_nk2  VARCHAR2(5);
   o_d_domain_id  NUMBER(38);
   o_d_domains_nk1  VARCHAR2(5);
   o_d_domains_nk2  VARCHAR2(5);
   n_d_domains_nk1  VARCHAR2(5);
   n_d_domains_nk2  VARCHAR2(5);
   o_type  VARCHAR2(30);
   o_len  NUMBER(5);
   o_scale  NUMBER(3);
   o_fold  VARCHAR2(1);
   o_default_value  VARCHAR2(1000);
   o_upd_res_pct  NUMBER(2,0);
   o_description  VARCHAR2(1000);
begin
   -- Retrieve the old (before update) data
   select COL.table_id
         ,COL.tables_nk1
         ,COL.tables_nk2
         ,COL.name
         ,COL.seq
         ,COL.nk
         ,COL.req
         ,COL.fk_prefix
         ,COL.fk_table_id
         ,COL.fk_tables_nk1
         ,COL.fk_tables_nk2
         ,COL.d_domain_id
         ,COL.d_domains_nk1
         ,COL.d_domains_nk2
         ,COL.type
         ,COL.len
         ,COL.scale
         ,COL.fold
         ,COL.default_value
         ,COL.upd_res_pct
         ,COL.description
    into  o_table_id
         ,o_tables_nk1
         ,o_tables_nk2
         ,o_name
         ,o_seq
         ,o_nk
         ,o_req
         ,o_fk_prefix
         ,o_fk_table_id
         ,o_fk_tables_nk1
         ,o_fk_tables_nk2
         ,o_d_domain_id
         ,o_d_domains_nk1
         ,o_d_domains_nk2
         ,o_type
         ,o_len
         ,o_scale
         ,o_fold
         ,o_default_value
         ,o_upd_res_pct
         ,o_description
    from  tab_cols_act  COL
    where COL.id = o_id_in;
   -- Set the Natural Key data as indicated by NKDATA_PROVIDED
   if upper(substr(nkdata_provided_in,1,1)) in ('Y','T')
   then
      -- Use the Natural Key Data that was provided
      n_tables_nk1 := n_tables_nk1_in;
      n_tables_nk2 := n_tables_nk2_in;
      n_fk_tables_nk1 := n_fk_tables_nk1_in;
      n_fk_tables_nk2 := n_fk_tables_nk2_in;
      n_d_domains_nk1 := n_d_domains_nk1_in;
      n_d_domains_nk2 := n_d_domains_nk2_in;
   else
      -- Use the old Natural Key Data
      n_tables_nk1 := o_tables_nk1;
      n_tables_nk2 := o_tables_nk2;
      n_fk_tables_nk1 := o_fk_tables_nk1;
      n_fk_tables_nk2 := o_fk_tables_nk2;
      n_d_domains_nk1 := o_d_domains_nk1;
      n_d_domains_nk2 := o_d_domains_nk2;
   end if;
   -- Run the update
   tab_cols_view.upd
      (o_id_in
      ,o_table_id
      ,o_tables_nk1
      ,o_tables_nk2
      ,n_table_id
      ,n_tables_nk1
      ,n_tables_nk2
      ,o_name
      ,n_name
      ,o_seq
      ,n_seq
      ,o_nk
      ,n_nk
      ,o_req
      ,n_req
      ,o_fk_prefix
      ,n_fk_prefix
      ,o_fk_table_id
      ,o_fk_tables_nk1
      ,o_fk_tables_nk2
      ,n_fk_table_id
      ,n_fk_tables_nk1
      ,n_fk_tables_nk2
      ,o_d_domain_id
      ,o_d_domains_nk1
      ,o_d_domains_nk2
      ,n_d_domain_id
      ,n_d_domains_nk1
      ,n_d_domains_nk2
      ,o_type
      ,n_type
      ,o_len
      ,n_len
      ,o_scale
      ,n_scale
      ,o_fold
      ,n_fold
      ,o_default_value
      ,n_default_value
      ,o_upd_res_pct
      ,n_upd_res_pct
      ,o_description
      ,n_description
      );
end upd;
----------------------------------------
procedure del
      (o_id_in  in  NUMBER
      )
   -- Application Delete procedure
is
   o_table_id  NUMBER(38);
   o_name  VARCHAR2(25);
   o_seq  NUMBER(2);
   o_nk  NUMBER(1);
   o_req  VARCHAR2(1);
   o_fk_prefix  VARCHAR2(4);
   o_fk_table_id  NUMBER(38);
   o_d_domain_id  NUMBER(38);
   o_type  VARCHAR2(30);
   o_len  NUMBER(5);
   o_scale  NUMBER(3);
   o_fold  VARCHAR2(1);
   o_default_value  VARCHAR2(1000);
   o_upd_res_pct  NUMBER(2,0);
   o_description  VARCHAR2(1000);
begin
   select COL.table_id
         ,COL.name
         ,COL.seq
         ,COL.nk
         ,COL.req
         ,COL.fk_prefix
         ,COL.fk_table_id
         ,COL.d_domain_id
         ,COL.type
         ,COL.len
         ,COL.scale
         ,COL.fold
         ,COL.default_value
         ,COL.upd_res_pct
         ,COL.description
    into  o_table_id
         ,o_name
         ,o_seq
         ,o_nk
         ,o_req
         ,o_fk_prefix
         ,o_fk_table_id
         ,o_d_domain_id
         ,o_type
         ,o_len
         ,o_scale
         ,o_fold
         ,o_default_value
         ,o_upd_res_pct
         ,o_description
    from  tab_cols  COL
    where COL.id = o_id_in;
   tab_cols_view.del
      (o_id_in
      ,o_table_id
      ,o_name
      ,o_seq
      ,o_nk
      ,o_req
      ,o_fk_prefix
      ,o_fk_table_id
      ,o_d_domain_id
      ,o_type
      ,o_len
      ,o_scale
      ,o_fold
      ,o_default_value
      ,o_upd_res_pct
      ,o_description
      );
end del;
----------------------------------------
end tab_cols_dml;
/
select 'TAB_COLS_DML' as "Package Body:"
 from  user_errors
 where name = 'TAB_COLS_DML'
  and  type = 'PACKAGE BODY'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'TAB_COLS_DML'
  and  type = 'PACKAGE BODY'
 order by sequence;

----------------------------------------
select '***  indexes  ***' as TABLE_NAME from dual;
----------------------------------------

create package indexes_view
is

   -- Package Indexes_View
   --    View functions
   --    (DML, Foreign Keys, Paths, and )
   --
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:23 PM

   procedure ins
      (n_id  in out  NUMBER
      ,n_tab_col_id  in out  NUMBER
      ,n_tab_cols_nk1  in  VARCHAR2
      ,n_tab_cols_nk2  in  VARCHAR2
      ,n_tab_cols_nk3  in  VARCHAR2
      ,n_tag  in out  VARCHAR2
      ,n_seq  in out  NUMBER
      );
   procedure upd
      (o_id  in  NUMBER
      ,o_tab_col_id  in  NUMBER
      ,o_tab_cols_nk1  in  VARCHAR2
      ,o_tab_cols_nk2  in  VARCHAR2
      ,o_tab_cols_nk3  in  VARCHAR2
      ,n_tab_col_id  in out  NUMBER
      ,n_tab_cols_nk1  in  VARCHAR2
      ,n_tab_cols_nk2  in  VARCHAR2
      ,n_tab_cols_nk3  in  VARCHAR2
      ,o_tag  in  VARCHAR2
      ,n_tag  in out  VARCHAR2
      ,o_seq  in  NUMBER
      ,n_seq  in out  NUMBER
      );
   procedure del
      (o_id  in  NUMBER
      ,o_tab_col_id  in  NUMBER
      ,o_tag  in  VARCHAR2
      ,o_seq  in  NUMBER
      );
end indexes_view;
/
select 'INDEXES_VIEW' as "Package:"
 from  user_errors
 where name = 'INDEXES_VIEW'
  and  type = 'PACKAGE'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'INDEXES_VIEW'
  and  type = 'PACKAGE'
 order by sequence;

create package indexes_dml
is

   -- Package Indexes_Dml
   -- (Data Manipulation Language, Foreign Key and Path Lookup)

   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:23 PM

   function get_next_id
      return number;
   function get_curr_id
      return number;

   function get_id
      (indexes_nk1  in  VARCHAR2
      ,indexes_nk2  in  VARCHAR2
      ,indexes_nk3  in  VARCHAR2
      ,indexes_nk4  in  VARCHAR2
      ,indexes_nk5  in  NUMBER
      ) return number;
   function get_nk
      (id_in  in  number
      ) return varchar2;

   function tab_to_col
         (id_in  in  number)
      return col_type;

   procedure ins
      (n_id  in out  NUMBER
      ,n_tab_col_id  in out  NUMBER
      ,n_tab_cols_nk1_in  in  VARCHAR2  default null
      ,n_tab_cols_nk2_in  in  VARCHAR2  default null
      ,n_tab_cols_nk3_in  in  VARCHAR2  default null
      ,n_tag  in out  VARCHAR2
      ,n_seq  in out  NUMBER
      );
   procedure upd
      (o_id_in  in  NUMBER
      ,n_tab_col_id  in out  NUMBER
      ,n_tab_cols_nk1_in  in  VARCHAR2  default null
      ,n_tab_cols_nk2_in  in  VARCHAR2  default null
      ,n_tab_cols_nk3_in  in  VARCHAR2  default null
      ,n_tag  in out  VARCHAR2
      ,n_seq  in out  NUMBER
      ,nkdata_provided_in  in   VARCHAR2  default null
      );
   procedure del
      (o_id_in  in  NUMBER
      );
end indexes_dml;
/
select 'INDEXES_DML' as "Package:"
 from  user_errors
 where name = 'INDEXES_DML'
  and  type = 'PACKAGE'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'INDEXES_DML'
  and  type = 'PACKAGE'
 order by sequence;

create view indexes_act
      (id
      ,tab_col_id
      ,tab_cols_nk1
      ,tab_cols_nk2
      ,tab_cols_nk3
      ,tag
      ,seq
      )
   as select
       IND.id
      ,IND.tab_col_id
      ,APP.abbr
      ,TAB.abbr
      ,COL.name
      ,IND.tag
      ,IND.seq
 from             indexes IND
       inner join tab_cols COL on COL.id = IND.tab_col_id
       inner join tables TAB on TAB.id = COL.table_id
       inner join applications APP on APP.id = TAB.application_id
 ;
select 'INDEXES_ACT' as "View:"
 from  user_errors
 where name = 'INDEXES_ACT'
  and  type = 'VIEW'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'INDEXES_ACT'
  and  type = 'VIEW'
 order by sequence;

comment on table indexes_act is 'Unique and non-unique indexes for this table';

comment on column indexes_act.id is 'Surrogate Primary Key for these indexes_act';
comment on column indexes_act.tab_col_id is 'Surrogate Key for the column for this index';
comment on column indexes_act.tag is 'Tag attached to the table name for this column that uniquely identifies this index';
comment on column indexes_act.seq is 'Sequence number for this column for this index';
comment on column indexes_act.tab_cols_nk1 is 'TAB_COLS Natural Key Value 1: Abbreviation for this application';
comment on column indexes_act.tab_cols_nk2 is 'TAB_COLS Natural Key Value 2: Abbreviation for this table';
comment on column indexes_act.tab_cols_nk3 is 'TAB_COLS Natural Key Value 3: Name of this column';

alter view indexes_act add constraint indexes_act_pk
   primary key (id) disable;

alter view indexes_act add constraint indexes_act_fk1
   foreign key (tab_col_id) references tab_cols_act (id) disable;

create TRIGGER indexes_ioi
   instead of insert on indexes_act
   for each row
declare
   n_id  NUMBER(38);
   n_tab_col_id  NUMBER(38);
   n_tag  VARCHAR2(4);
   n_seq  NUMBER(1);
begin

   -- Trigger Indexes_Ioi
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:23 PM

   n_id := :new.id;
   n_tab_col_id := :new.tab_col_id;
   n_tag := :new.tag;
   n_seq := :new.seq;
   indexes_view.ins
      (n_id
      ,n_tab_col_id
      ,:new.tab_cols_nk1
      ,:new.tab_cols_nk2
      ,:new.tab_cols_nk3
      ,n_tag
      ,n_seq
      );
end indexes_ioi;
/
select 'INDEXES_IOI' as "Trigger:"
 from  user_errors
 where name = 'INDEXES_IOI'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'INDEXES_IOI'
  and  type = 'TRIGGER'
 order by sequence;

create TRIGGER indexes_iou
   instead of update on indexes_act
   for each row
declare
   n_tab_col_id  NUMBER(38);
   n_tag  VARCHAR2(4);
   n_seq  NUMBER(1);
begin

   -- Trigger Indexes_Iou
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:23 PM

   n_tab_col_id := :new.tab_col_id;
   n_tag := :new.tag;
   n_seq := :new.seq;
   indexes_view.upd
      (:old.id
      ,:old.tab_col_id
      ,:old.tab_cols_nk1
      ,:old.tab_cols_nk2
      ,:old.tab_cols_nk3
      ,n_tab_col_id
      ,:new.tab_cols_nk1
      ,:new.tab_cols_nk2
      ,:new.tab_cols_nk3
      ,:old.tag
      ,n_tag
      ,:old.seq
      ,n_seq
      );
end indexes_iou;
/
select 'INDEXES_IOU' as "Trigger:"
 from  user_errors
 where name = 'INDEXES_IOU'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'INDEXES_IOU'
  and  type = 'TRIGGER'
 order by sequence;

create TRIGGER indexes_iod
   instead of delete on indexes_act
   for each row
begin

   -- Trigger Indexes_Iod
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:23 PM

   indexes_view.del
      (:old.id
      ,:old.tab_col_id
      ,:old.tag
      ,:old.seq
      );
end indexes_iod;
/
select 'INDEXES_IOD' as "Trigger:"
 from  user_errors
 where name = 'INDEXES_IOD'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'INDEXES_IOD'
  and  type = 'TRIGGER'
 order by sequence;

create package body indexes_view
is

-- Package Body Indexes_View
--    View functions
--    (DML, Foreign Keys, Paths, and )
--
--    Generated by DTGen (http://code.google.com/p/dtgen)
--    July      27, 2012  09:34:23 PM

----------------------------------------
procedure ins
      (n_id  in out  NUMBER
      ,n_tab_col_id  in out  NUMBER
      ,n_tab_cols_nk1  in  VARCHAR2
      ,n_tab_cols_nk2  in  VARCHAR2
      ,n_tab_cols_nk3  in  VARCHAR2
      ,n_tag  in out  VARCHAR2
      ,n_seq  in out  NUMBER
      )
   -- View insert procedure
is
begin
   if util.db_object_exists('INDEXES', 'MATERIALIZED VIEW')
   then
      raise_application_error(-20010, 'Insert not allowed on materialized view indexes.  Inserts on indexes must be performed on the central database.');
   end if;
   -- Set n_tab_col_id, if needed
   if     n_tab_col_id is null
      and n_tab_cols_nk1 is not null
      and n_tab_cols_nk2 is not null
      and n_tab_cols_nk3 is not null
   then
      n_tab_col_id :=
         tab_cols_dml.get_id
            (n_tab_cols_nk1
            ,n_tab_cols_nk2
            ,n_tab_cols_nk3
            );
   end if;
   if not glob.get_db_constraints
   then
      indexes_tab.ins
         (n_id
         ,n_tab_col_id
         ,n_tag
         ,n_seq
         );
   end if;
   insert into indexes
         (id
         ,tab_col_id
         ,tag
         ,seq
         )
   values
         (n_id
         ,n_tab_col_id
         ,n_tag
         ,n_seq
         );
end ins;
----------------------------------------
procedure upd
      (o_id  in  NUMBER
      ,o_tab_col_id  in  NUMBER
      ,o_tab_cols_nk1  in  VARCHAR2
      ,o_tab_cols_nk2  in  VARCHAR2
      ,o_tab_cols_nk3  in  VARCHAR2
      ,n_tab_col_id  in out  NUMBER
      ,n_tab_cols_nk1  in  VARCHAR2
      ,n_tab_cols_nk2  in  VARCHAR2
      ,n_tab_cols_nk3  in  VARCHAR2
      ,o_tag  in  VARCHAR2
      ,n_tag  in out  VARCHAR2
      ,o_seq  in  NUMBER
      ,n_seq  in out  NUMBER
      )
   -- View Update procedure
is
begin
   if util.db_object_exists('INDEXES', 'MATERIALIZED VIEW')
   then
      raise_application_error(-20010, 'Update not allowed on materialized view indexes.  Updates on indexes must be performed on the central database.');
   end if;
   -- Set n_tab_col_id, if needed
   if     n_tab_col_id = o_tab_col_id
      and (   not (n_tab_cols_nk1 = o_tab_cols_nk1)
           or not (n_tab_cols_nk2 = o_tab_cols_nk2)
           or not (n_tab_cols_nk3 = o_tab_cols_nk3)
          )
   then
      n_tab_col_id :=
         tab_cols_dml.get_id
            (n_tab_cols_nk1
            ,n_tab_cols_nk2
            ,n_tab_cols_nk3
            );
   end if;
   if not glob.get_db_constraints
   then
      indexes_tab.upd
         (o_id
         ,o_tab_col_id
         ,n_tab_col_id
         ,o_tag
         ,n_tag
         ,o_seq
         ,n_seq
         );
   end if;
   update indexes IND
     set  IND.tab_col_id = n_tab_col_id
         ,IND.tag = n_tag
         ,IND.seq = n_seq
    where IND.id = o_id;
end upd;
----------------------------------------
procedure del
      (o_id  in  NUMBER
      ,o_tab_col_id  in  NUMBER
      ,o_tag  in  VARCHAR2
      ,o_seq  in  NUMBER
      )
is
begin
   if util.db_object_exists('INDEXES', 'MATERIALIZED VIEW')
   then
      raise_application_error(-20010, 'Delete not allowed on materialized view indexes.  Deletes on indexes must be performed on the central database.');
   end if;
   if not glob.get_db_constraints
   then
      indexes_tab.del
         (o_id
         ,o_tab_col_id
         ,o_tag
         ,o_seq
         );
   end if;
   delete from indexes  IND
    where IND.id = o_id;
end del;
----------------------------------------
end indexes_view;
/
select 'INDEXES_VIEW' as "Package Body:"
 from  user_errors
 where name = 'INDEXES_VIEW'
  and  type = 'PACKAGE BODY'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'INDEXES_VIEW'
  and  type = 'PACKAGE BODY'
 order by sequence;

create package body indexes_dml
is

 -- Package Body Indexes_Dml
 -- (Data Manipulation Language, Foreign Key and Path Lookup)

 --    Generated by DTGen (http://code.google.com/p/dtgen)
 --    July      27, 2012  09:34:24 PM

----------------------------------------
function get_next_id
      return number
is
   retid  number;
begin
   select indexes_seq.nextval into retid from dual;
   return retid;
end get_next_id;
----------------------------------------
function get_curr_id
      return number
is
   retid  number;
begin
   select indexes_seq.currval into retid from dual;
   return retid;
end get_curr_id;
----------------------------------------
function get_id
      (indexes_nk1  in  VARCHAR2
      ,indexes_nk2  in  VARCHAR2
      ,indexes_nk3  in  VARCHAR2
      ,indexes_nk4  in  VARCHAR2
      ,indexes_nk5  in  NUMBER
      ) return number
   -- For all the Natural Key Columns, Return an ID
is
   retid  number(38);
begin
   select id
    into  retid
    from  indexes  IND
    where IND.tab_col_id = tab_cols_dml.get_id
             (indexes_nk1
             ,indexes_nk2
             ,indexes_nk3
             )
     and  IND.tag = indexes_nk4
     and  IND.seq = indexes_nk5
    ;
   return retid;
exception
   when no_data_found
   then
      return null;
   when others
   then
      raise;
end get_id;
----------------------------------------
function get_nk
      (id_in  in  number)
   return varchar2
   -- For an ID, return a delimited list of Natural Key Values
is
   rtxt  varchar2(32767);
begin
   select substr(   tab_cols_dml.get_nk(IND.tab_col_id)
    || util.nk_sep || IND.tag
    || util.nk_sep || IND.seq
                         ,1,32767)
    into  rtxt
    from  indexes IND
    where IND.id = id_in;
   return rtxt;
exception
   when no_data_found then
      return null;
   when others then
      raise;
end get_nk;
----------------------------------------
function tab_to_col
      (id_in  in  number)
   return col_type
is
   -- This function is duplicated in indexes_POP
   cursor acur is
      select * from indexes
       where id = id_in;
   abuf   acur%ROWTYPE;
   rcol      col_type;
begin
   open acur;
   fetch acur into abuf;
   if acur%NOTFOUND
   then
      rcol := COL_TYPE(null);
      close acur;
      return rcol;
   end if;
   rcol := COL_TYPE
             (PAIR_TYPE('tab_col_id', to_char(abuf.tab_col_id))
             ,PAIR_TYPE('tag', abuf.tag)
             ,PAIR_TYPE('seq', to_char(abuf.seq))
                );
   close acur;
   return rcol;
end tab_to_col;
----------------------------------------
procedure ins
      (n_id  in out  NUMBER
      ,n_tab_col_id  in out  NUMBER
      ,n_tab_cols_nk1_in  in  VARCHAR2  default null
      ,n_tab_cols_nk2_in  in  VARCHAR2  default null
      ,n_tab_cols_nk3_in  in  VARCHAR2  default null
      ,n_tag  in out  VARCHAR2
      ,n_seq  in out  NUMBER
      )
   -- Application Insert procedure
is
begin
   indexes_view.ins
      (n_id
      ,n_tab_col_id
      ,n_tab_cols_nk1_in
      ,n_tab_cols_nk2_in
      ,n_tab_cols_nk3_in
      ,n_tag
      ,n_seq
      );
end ins;
----------------------------------------
procedure upd
      (o_id_in  in  NUMBER
      ,n_tab_col_id  in out  NUMBER
      ,n_tab_cols_nk1_in  in  VARCHAR2  default null
      ,n_tab_cols_nk2_in  in  VARCHAR2  default null
      ,n_tab_cols_nk3_in  in  VARCHAR2  default null
      ,n_tag  in out  VARCHAR2
      ,n_seq  in out  NUMBER
      ,nkdata_provided_in  in   VARCHAR2  default null
      )
   -- Application Update procedure
is
   o_tab_col_id  NUMBER(38);
   o_tab_cols_nk1  VARCHAR2(5);
   o_tab_cols_nk2  VARCHAR2(5);
   o_tab_cols_nk3  VARCHAR2(25);
   n_tab_cols_nk1  VARCHAR2(5);
   n_tab_cols_nk2  VARCHAR2(5);
   n_tab_cols_nk3  VARCHAR2(25);
   o_tag  VARCHAR2(4);
   o_seq  NUMBER(1);
begin
   -- Retrieve the old (before update) data
   select IND.tab_col_id
         ,IND.tab_cols_nk1
         ,IND.tab_cols_nk2
         ,IND.tab_cols_nk3
         ,IND.tag
         ,IND.seq
    into  o_tab_col_id
         ,o_tab_cols_nk1
         ,o_tab_cols_nk2
         ,o_tab_cols_nk3
         ,o_tag
         ,o_seq
    from  indexes_act  IND
    where IND.id = o_id_in;
   -- Set the Natural Key data as indicated by NKDATA_PROVIDED
   if upper(substr(nkdata_provided_in,1,1)) in ('Y','T')
   then
      -- Use the Natural Key Data that was provided
      n_tab_cols_nk1 := n_tab_cols_nk1_in;
      n_tab_cols_nk2 := n_tab_cols_nk2_in;
      n_tab_cols_nk3 := n_tab_cols_nk3_in;
   else
      -- Use the old Natural Key Data
      n_tab_cols_nk1 := o_tab_cols_nk1;
      n_tab_cols_nk2 := o_tab_cols_nk2;
      n_tab_cols_nk3 := o_tab_cols_nk3;
   end if;
   -- Run the update
   indexes_view.upd
      (o_id_in
      ,o_tab_col_id
      ,o_tab_cols_nk1
      ,o_tab_cols_nk2
      ,o_tab_cols_nk3
      ,n_tab_col_id
      ,n_tab_cols_nk1
      ,n_tab_cols_nk2
      ,n_tab_cols_nk3
      ,o_tag
      ,n_tag
      ,o_seq
      ,n_seq
      );
end upd;
----------------------------------------
procedure del
      (o_id_in  in  NUMBER
      )
   -- Application Delete procedure
is
   o_tab_col_id  NUMBER(38);
   o_tag  VARCHAR2(4);
   o_seq  NUMBER(1);
begin
   select IND.tab_col_id
         ,IND.tag
         ,IND.seq
    into  o_tab_col_id
         ,o_tag
         ,o_seq
    from  indexes  IND
    where IND.id = o_id_in;
   indexes_view.del
      (o_id_in
      ,o_tab_col_id
      ,o_tag
      ,o_seq
      );
end del;
----------------------------------------
end indexes_dml;
/
select 'INDEXES_DML' as "Package Body:"
 from  user_errors
 where name = 'INDEXES_DML'
  and  type = 'PACKAGE BODY'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'INDEXES_DML'
  and  type = 'PACKAGE BODY'
 order by sequence;

----------------------------------------
select '***  check_cons  ***' as TABLE_NAME from dual;
----------------------------------------

create package check_cons_view
is

   -- Package Check_Cons_View
   --    View functions
   --    (DML, Foreign Keys, Paths, and )
   --
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:24 PM

   procedure ins
      (n_id  in out  NUMBER
      ,n_table_id  in out  NUMBER
      ,n_tables_nk1  in  VARCHAR2
      ,n_tables_nk2  in  VARCHAR2
      ,n_seq  in out  NUMBER
      ,n_text  in out  VARCHAR2
      ,n_description  in out  VARCHAR2
      );
   procedure upd
      (o_id  in  NUMBER
      ,o_table_id  in  NUMBER
      ,o_tables_nk1  in  VARCHAR2
      ,o_tables_nk2  in  VARCHAR2
      ,n_table_id  in out  NUMBER
      ,n_tables_nk1  in  VARCHAR2
      ,n_tables_nk2  in  VARCHAR2
      ,o_seq  in  NUMBER
      ,n_seq  in out  NUMBER
      ,o_text  in  VARCHAR2
      ,n_text  in out  VARCHAR2
      ,o_description  in  VARCHAR2
      ,n_description  in out  VARCHAR2
      );
   procedure del
      (o_id  in  NUMBER
      ,o_table_id  in  NUMBER
      ,o_seq  in  NUMBER
      ,o_text  in  VARCHAR2
      ,o_description  in  VARCHAR2
      );
end check_cons_view;
/
select 'CHECK_CONS_VIEW' as "Package:"
 from  user_errors
 where name = 'CHECK_CONS_VIEW'
  and  type = 'PACKAGE'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'CHECK_CONS_VIEW'
  and  type = 'PACKAGE'
 order by sequence;

create package check_cons_dml
is

   -- Package Check_Cons_Dml
   -- (Data Manipulation Language, Foreign Key and Path Lookup)

   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:24 PM

   function get_next_id
      return number;
   function get_curr_id
      return number;

   function get_id
      (check_cons_nk1  in  VARCHAR2
      ,check_cons_nk2  in  VARCHAR2
      ,check_cons_nk3  in  NUMBER
      ) return number;
   function get_nk
      (id_in  in  number
      ) return varchar2;

   function tab_to_col
         (id_in  in  number)
      return col_type;

   procedure ins
      (n_id  in out  NUMBER
      ,n_table_id  in out  NUMBER
      ,n_tables_nk1_in  in  VARCHAR2  default null
      ,n_tables_nk2_in  in  VARCHAR2  default null
      ,n_seq  in out  NUMBER
      ,n_text  in out  VARCHAR2
      ,n_description  in out  VARCHAR2
      );
   procedure upd
      (o_id_in  in  NUMBER
      ,n_table_id  in out  NUMBER
      ,n_tables_nk1_in  in  VARCHAR2  default null
      ,n_tables_nk2_in  in  VARCHAR2  default null
      ,n_seq  in out  NUMBER
      ,n_text  in out  VARCHAR2
      ,n_description  in out  VARCHAR2
      ,nkdata_provided_in  in   VARCHAR2  default null
      );
   procedure del
      (o_id_in  in  NUMBER
      );
end check_cons_dml;
/
select 'CHECK_CONS_DML' as "Package:"
 from  user_errors
 where name = 'CHECK_CONS_DML'
  and  type = 'PACKAGE'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'CHECK_CONS_DML'
  and  type = 'PACKAGE'
 order by sequence;

create view check_cons_act
      (id
      ,table_id
      ,tables_nk1
      ,tables_nk2
      ,seq
      ,text
      ,description
      )
   as select
       CK.id
      ,CK.table_id
      ,APP.abbr
      ,TAB.abbr
      ,CK.seq
      ,CK.text
      ,CK.description
 from             check_cons CK
       inner join tables TAB on TAB.id = CK.table_id
       inner join applications APP on APP.id = TAB.application_id
 ;
select 'CHECK_CONS_ACT' as "View:"
 from  user_errors
 where name = 'CHECK_CONS_ACT'
  and  type = 'VIEW'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'CHECK_CONS_ACT'
  and  type = 'VIEW'
 order by sequence;

comment on table check_cons_act is 'Check constraints to be generated for each table';

comment on column check_cons_act.id is 'Surrogate Primary Key for these check_cons_act';
comment on column check_cons_act.table_id is 'Surrogate Key for the table of this check constraint';
comment on column check_cons_act.seq is 'Sequence number of this check constraint';
comment on column check_cons_act.text is 'Execution (PL/SQL) text for this check constraint';
comment on column check_cons_act.description is 'Description of this check constraint';
comment on column check_cons_act.tables_nk1 is 'TABLES Natural Key Value 1: Abbreviation for this application';
comment on column check_cons_act.tables_nk2 is 'TABLES Natural Key Value 2: Abbreviation for this table';

alter view check_cons_act add constraint check_cons_act_pk
   primary key (id) disable;

alter view check_cons_act add constraint check_cons_act_fk1
   foreign key (table_id) references tables_act (id) disable;

create TRIGGER check_cons_ioi
   instead of insert on check_cons_act
   for each row
declare
   n_id  NUMBER(38);
   n_table_id  NUMBER(38);
   n_seq  NUMBER(2);
   n_text  VARCHAR2(1000);
   n_description  VARCHAR2(1000);
begin

   -- Trigger Check_Cons_Ioi
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:24 PM

   n_id := :new.id;
   n_table_id := :new.table_id;
   n_seq := :new.seq;
   n_text := :new.text;
   n_description := :new.description;
   check_cons_view.ins
      (n_id
      ,n_table_id
      ,:new.tables_nk1
      ,:new.tables_nk2
      ,n_seq
      ,n_text
      ,n_description
      );
end check_cons_ioi;
/
select 'CHECK_CONS_IOI' as "Trigger:"
 from  user_errors
 where name = 'CHECK_CONS_IOI'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'CHECK_CONS_IOI'
  and  type = 'TRIGGER'
 order by sequence;

create TRIGGER check_cons_iou
   instead of update on check_cons_act
   for each row
declare
   n_table_id  NUMBER(38);
   n_seq  NUMBER(2);
   n_text  VARCHAR2(1000);
   n_description  VARCHAR2(1000);
begin

   -- Trigger Check_Cons_Iou
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:24 PM

   n_table_id := :new.table_id;
   n_seq := :new.seq;
   n_text := :new.text;
   n_description := :new.description;
   check_cons_view.upd
      (:old.id
      ,:old.table_id
      ,:old.tables_nk1
      ,:old.tables_nk2
      ,n_table_id
      ,:new.tables_nk1
      ,:new.tables_nk2
      ,:old.seq
      ,n_seq
      ,:old.text
      ,n_text
      ,:old.description
      ,n_description
      );
end check_cons_iou;
/
select 'CHECK_CONS_IOU' as "Trigger:"
 from  user_errors
 where name = 'CHECK_CONS_IOU'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'CHECK_CONS_IOU'
  and  type = 'TRIGGER'
 order by sequence;

create TRIGGER check_cons_iod
   instead of delete on check_cons_act
   for each row
begin

   -- Trigger Check_Cons_Iod
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:25 PM

   check_cons_view.del
      (:old.id
      ,:old.table_id
      ,:old.seq
      ,:old.text
      ,:old.description
      );
end check_cons_iod;
/
select 'CHECK_CONS_IOD' as "Trigger:"
 from  user_errors
 where name = 'CHECK_CONS_IOD'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'CHECK_CONS_IOD'
  and  type = 'TRIGGER'
 order by sequence;

create package body check_cons_view
is

-- Package Body Check_Cons_View
--    View functions
--    (DML, Foreign Keys, Paths, and )
--
--    Generated by DTGen (http://code.google.com/p/dtgen)
--    July      27, 2012  09:34:25 PM

----------------------------------------
procedure ins
      (n_id  in out  NUMBER
      ,n_table_id  in out  NUMBER
      ,n_tables_nk1  in  VARCHAR2
      ,n_tables_nk2  in  VARCHAR2
      ,n_seq  in out  NUMBER
      ,n_text  in out  VARCHAR2
      ,n_description  in out  VARCHAR2
      )
   -- View insert procedure
is
begin
   if util.db_object_exists('CHECK_CONS', 'MATERIALIZED VIEW')
   then
      raise_application_error(-20010, 'Insert not allowed on materialized view check_cons.  Inserts on check_cons must be performed on the central database.');
   end if;
   -- Set n_table_id, if needed
   if     n_table_id is null
      and n_tables_nk1 is not null
      and n_tables_nk2 is not null
   then
      n_table_id :=
         tables_dml.get_id
            (n_tables_nk1
            ,n_tables_nk2
            );
   end if;
   if not glob.get_db_constraints
   then
      check_cons_tab.ins
         (n_id
         ,n_table_id
         ,n_seq
         ,n_text
         ,n_description
         );
   end if;
   insert into check_cons
         (id
         ,table_id
         ,seq
         ,text
         ,description
         )
   values
         (n_id
         ,n_table_id
         ,n_seq
         ,n_text
         ,n_description
         );
end ins;
----------------------------------------
procedure upd
      (o_id  in  NUMBER
      ,o_table_id  in  NUMBER
      ,o_tables_nk1  in  VARCHAR2
      ,o_tables_nk2  in  VARCHAR2
      ,n_table_id  in out  NUMBER
      ,n_tables_nk1  in  VARCHAR2
      ,n_tables_nk2  in  VARCHAR2
      ,o_seq  in  NUMBER
      ,n_seq  in out  NUMBER
      ,o_text  in  VARCHAR2
      ,n_text  in out  VARCHAR2
      ,o_description  in  VARCHAR2
      ,n_description  in out  VARCHAR2
      )
   -- View Update procedure
is
begin
   if util.db_object_exists('CHECK_CONS', 'MATERIALIZED VIEW')
   then
      raise_application_error(-20010, 'Update not allowed on materialized view check_cons.  Updates on check_cons must be performed on the central database.');
   end if;
   -- Set n_table_id, if needed
   if     n_table_id = o_table_id
      and (   not (n_tables_nk1 = o_tables_nk1)
           or not (n_tables_nk2 = o_tables_nk2)
          )
   then
      n_table_id :=
         tables_dml.get_id
            (n_tables_nk1
            ,n_tables_nk2
            );
   end if;
   if not glob.get_db_constraints
   then
      check_cons_tab.upd
         (o_id
         ,o_table_id
         ,n_table_id
         ,o_seq
         ,n_seq
         ,o_text
         ,n_text
         ,o_description
         ,n_description
         );
   end if;
   update check_cons CK
     set  CK.table_id = n_table_id
         ,CK.seq = n_seq
         ,CK.text = n_text
         ,CK.description = n_description
    where CK.id = o_id;
end upd;
----------------------------------------
procedure del
      (o_id  in  NUMBER
      ,o_table_id  in  NUMBER
      ,o_seq  in  NUMBER
      ,o_text  in  VARCHAR2
      ,o_description  in  VARCHAR2
      )
is
begin
   if util.db_object_exists('CHECK_CONS', 'MATERIALIZED VIEW')
   then
      raise_application_error(-20010, 'Delete not allowed on materialized view check_cons.  Deletes on check_cons must be performed on the central database.');
   end if;
   if not glob.get_db_constraints
   then
      check_cons_tab.del
         (o_id
         ,o_table_id
         ,o_seq
         ,o_text
         ,o_description
         );
   end if;
   delete from check_cons  CK
    where CK.id = o_id;
end del;
----------------------------------------
end check_cons_view;
/
select 'CHECK_CONS_VIEW' as "Package Body:"
 from  user_errors
 where name = 'CHECK_CONS_VIEW'
  and  type = 'PACKAGE BODY'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'CHECK_CONS_VIEW'
  and  type = 'PACKAGE BODY'
 order by sequence;

create package body check_cons_dml
is

 -- Package Body Check_Cons_Dml
 -- (Data Manipulation Language, Foreign Key and Path Lookup)

 --    Generated by DTGen (http://code.google.com/p/dtgen)
 --    July      27, 2012  09:34:25 PM

----------------------------------------
function get_next_id
      return number
is
   retid  number;
begin
   select check_cons_seq.nextval into retid from dual;
   return retid;
end get_next_id;
----------------------------------------
function get_curr_id
      return number
is
   retid  number;
begin
   select check_cons_seq.currval into retid from dual;
   return retid;
end get_curr_id;
----------------------------------------
function get_id
      (check_cons_nk1  in  VARCHAR2
      ,check_cons_nk2  in  VARCHAR2
      ,check_cons_nk3  in  NUMBER
      ) return number
   -- For all the Natural Key Columns, Return an ID
is
   retid  number(38);
begin
   select id
    into  retid
    from  check_cons  CK
    where CK.table_id = tables_dml.get_id
             (check_cons_nk1
             ,check_cons_nk2
             )
     and  CK.seq = check_cons_nk3
    ;
   return retid;
exception
   when no_data_found
   then
      return null;
   when others
   then
      raise;
end get_id;
----------------------------------------
function get_nk
      (id_in  in  number)
   return varchar2
   -- For an ID, return a delimited list of Natural Key Values
is
   rtxt  varchar2(32767);
begin
   select substr(   tables_dml.get_nk(CK.table_id)
    || util.nk_sep || CK.seq
                         ,1,32767)
    into  rtxt
    from  check_cons CK
    where CK.id = id_in;
   return rtxt;
exception
   when no_data_found then
      return null;
   when others then
      raise;
end get_nk;
----------------------------------------
function tab_to_col
      (id_in  in  number)
   return col_type
is
   -- This function is duplicated in check_cons_POP
   cursor acur is
      select * from check_cons
       where id = id_in;
   abuf   acur%ROWTYPE;
   rcol      col_type;
begin
   open acur;
   fetch acur into abuf;
   if acur%NOTFOUND
   then
      rcol := COL_TYPE(null);
      close acur;
      return rcol;
   end if;
   rcol := COL_TYPE
             (PAIR_TYPE('table_id', to_char(abuf.table_id))
             ,PAIR_TYPE('seq', to_char(abuf.seq))
             ,PAIR_TYPE('text', abuf.text)
             ,PAIR_TYPE('description', abuf.description)
                );
   close acur;
   return rcol;
end tab_to_col;
----------------------------------------
procedure ins
      (n_id  in out  NUMBER
      ,n_table_id  in out  NUMBER
      ,n_tables_nk1_in  in  VARCHAR2  default null
      ,n_tables_nk2_in  in  VARCHAR2  default null
      ,n_seq  in out  NUMBER
      ,n_text  in out  VARCHAR2
      ,n_description  in out  VARCHAR2
      )
   -- Application Insert procedure
is
begin
   check_cons_view.ins
      (n_id
      ,n_table_id
      ,n_tables_nk1_in
      ,n_tables_nk2_in
      ,n_seq
      ,n_text
      ,n_description
      );
end ins;
----------------------------------------
procedure upd
      (o_id_in  in  NUMBER
      ,n_table_id  in out  NUMBER
      ,n_tables_nk1_in  in  VARCHAR2  default null
      ,n_tables_nk2_in  in  VARCHAR2  default null
      ,n_seq  in out  NUMBER
      ,n_text  in out  VARCHAR2
      ,n_description  in out  VARCHAR2
      ,nkdata_provided_in  in   VARCHAR2  default null
      )
   -- Application Update procedure
is
   o_table_id  NUMBER(38);
   o_tables_nk1  VARCHAR2(5);
   o_tables_nk2  VARCHAR2(5);
   n_tables_nk1  VARCHAR2(5);
   n_tables_nk2  VARCHAR2(5);
   o_seq  NUMBER(2);
   o_text  VARCHAR2(1000);
   o_description  VARCHAR2(1000);
begin
   -- Retrieve the old (before update) data
   select CK.table_id
         ,CK.tables_nk1
         ,CK.tables_nk2
         ,CK.seq
         ,CK.text
         ,CK.description
    into  o_table_id
         ,o_tables_nk1
         ,o_tables_nk2
         ,o_seq
         ,o_text
         ,o_description
    from  check_cons_act  CK
    where CK.id = o_id_in;
   -- Set the Natural Key data as indicated by NKDATA_PROVIDED
   if upper(substr(nkdata_provided_in,1,1)) in ('Y','T')
   then
      -- Use the Natural Key Data that was provided
      n_tables_nk1 := n_tables_nk1_in;
      n_tables_nk2 := n_tables_nk2_in;
   else
      -- Use the old Natural Key Data
      n_tables_nk1 := o_tables_nk1;
      n_tables_nk2 := o_tables_nk2;
   end if;
   -- Run the update
   check_cons_view.upd
      (o_id_in
      ,o_table_id
      ,o_tables_nk1
      ,o_tables_nk2
      ,n_table_id
      ,n_tables_nk1
      ,n_tables_nk2
      ,o_seq
      ,n_seq
      ,o_text
      ,n_text
      ,o_description
      ,n_description
      );
end upd;
----------------------------------------
procedure del
      (o_id_in  in  NUMBER
      )
   -- Application Delete procedure
is
   o_table_id  NUMBER(38);
   o_seq  NUMBER(2);
   o_text  VARCHAR2(1000);
   o_description  VARCHAR2(1000);
begin
   select CK.table_id
         ,CK.seq
         ,CK.text
         ,CK.description
    into  o_table_id
         ,o_seq
         ,o_text
         ,o_description
    from  check_cons  CK
    where CK.id = o_id_in;
   check_cons_view.del
      (o_id_in
      ,o_table_id
      ,o_seq
      ,o_text
      ,o_description
      );
end del;
----------------------------------------
end check_cons_dml;
/
select 'CHECK_CONS_DML' as "Package Body:"
 from  user_errors
 where name = 'CHECK_CONS_DML'
  and  type = 'PACKAGE BODY'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'CHECK_CONS_DML'
  and  type = 'PACKAGE BODY'
 order by sequence;

----------------------------------------
select '***  programs  ***' as TABLE_NAME from dual;
----------------------------------------

create package programs_view
is

   -- Package Programs_View
   --    View functions
   --    (DML, Foreign Keys, Paths, and )
   --
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:25 PM

   procedure ins
      (n_id  in out  NUMBER
      ,n_application_id  in out  NUMBER
      ,n_applications_nk1  in  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,n_type  in out  VARCHAR2
      ,n_description  in out  VARCHAR2
      );
   procedure upd
      (o_id  in  NUMBER
      ,o_application_id  in  NUMBER
      ,o_applications_nk1  in  VARCHAR2
      ,n_application_id  in out  NUMBER
      ,n_applications_nk1  in  VARCHAR2
      ,o_name  in  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,o_type  in  VARCHAR2
      ,n_type  in out  VARCHAR2
      ,o_description  in  VARCHAR2
      ,n_description  in out  VARCHAR2
      );
   procedure del
      (o_id  in  NUMBER
      ,o_application_id  in  NUMBER
      ,o_name  in  VARCHAR2
      ,o_type  in  VARCHAR2
      ,o_description  in  VARCHAR2
      );
end programs_view;
/
select 'PROGRAMS_VIEW' as "Package:"
 from  user_errors
 where name = 'PROGRAMS_VIEW'
  and  type = 'PACKAGE'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'PROGRAMS_VIEW'
  and  type = 'PACKAGE'
 order by sequence;

create package programs_dml
is

   -- Package Programs_Dml
   -- (Data Manipulation Language, Foreign Key and Path Lookup)

   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:25 PM

   function get_next_id
      return number;
   function get_curr_id
      return number;

   function get_id
      (programs_nk1  in  VARCHAR2
      ,programs_nk2  in  VARCHAR2
      ) return number;
   function get_nk
      (id_in  in  number
      ) return varchar2;

   function tab_to_col
         (id_in  in  number)
      return col_type;

   procedure ins
      (n_id  in out  NUMBER
      ,n_application_id  in out  NUMBER
      ,n_applications_nk1_in  in  VARCHAR2  default null
      ,n_name  in out  VARCHAR2
      ,n_type  in out  VARCHAR2
      ,n_description  in out  VARCHAR2
      );
   procedure upd
      (o_id_in  in  NUMBER
      ,n_application_id  in out  NUMBER
      ,n_applications_nk1_in  in  VARCHAR2  default null
      ,n_name  in out  VARCHAR2
      ,n_type  in out  VARCHAR2
      ,n_description  in out  VARCHAR2
      ,nkdata_provided_in  in   VARCHAR2  default null
      );
   procedure del
      (o_id_in  in  NUMBER
      );
end programs_dml;
/
select 'PROGRAMS_DML' as "Package:"
 from  user_errors
 where name = 'PROGRAMS_DML'
  and  type = 'PACKAGE'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'PROGRAMS_DML'
  and  type = 'PACKAGE'
 order by sequence;

create view programs_act
      (id
      ,application_id
      ,applications_nk1
      ,name
      ,type
      ,description
      )
   as select
       PRG.id
      ,PRG.application_id
      ,APP.abbr
      ,PRG.name
      ,PRG.type
      ,PRG.description
 from             programs PRG
       inner join applications APP on APP.id = PRG.application_id
 ;
select 'PROGRAMS_ACT' as "View:"
 from  user_errors
 where name = 'PROGRAMS_ACT'
  and  type = 'VIEW'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'PROGRAMS_ACT'
  and  type = 'VIEW'
 order by sequence;

comment on table programs_act is 'Programs Registered to Run with the Application';

comment on column programs_act.id is 'Surrogate Primary Key for these programs_act';
comment on column programs_act.application_id is 'Surrogate Key for the application of this Shared Program Unit';
comment on column programs_act.name is 'Name of this Stored Program Unit';
comment on column programs_act.type is 'Type of this Stored Program Unit';
comment on column programs_act.description is 'Description of this Stored Program Unit';
comment on column programs_act.applications_nk1 is 'APPLICATIONS Natural Key Value 1: Abbreviation for this application';

alter view programs_act add constraint programs_act_pk
   primary key (id) disable;

alter view programs_act add constraint programs_act_fk1
   foreign key (application_id) references applications_act (id) disable;

create TRIGGER programs_ioi
   instead of insert on programs_act
   for each row
declare
   n_id  NUMBER(38);
   n_application_id  NUMBER(38);
   n_name  VARCHAR2(30);
   n_type  VARCHAR2(30);
   n_description  VARCHAR2(1000);
begin

   -- Trigger Programs_Ioi
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:26 PM

   n_id := :new.id;
   n_application_id := :new.application_id;
   n_name := :new.name;
   n_type := :new.type;
   n_description := :new.description;
   programs_view.ins
      (n_id
      ,n_application_id
      ,:new.applications_nk1
      ,n_name
      ,n_type
      ,n_description
      );
end programs_ioi;
/
select 'PROGRAMS_IOI' as "Trigger:"
 from  user_errors
 where name = 'PROGRAMS_IOI'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'PROGRAMS_IOI'
  and  type = 'TRIGGER'
 order by sequence;

create TRIGGER programs_iou
   instead of update on programs_act
   for each row
declare
   n_application_id  NUMBER(38);
   n_name  VARCHAR2(30);
   n_type  VARCHAR2(30);
   n_description  VARCHAR2(1000);
begin

   -- Trigger Programs_Iou
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:26 PM

   n_application_id := :new.application_id;
   n_name := :new.name;
   n_type := :new.type;
   n_description := :new.description;
   programs_view.upd
      (:old.id
      ,:old.application_id
      ,:old.applications_nk1
      ,n_application_id
      ,:new.applications_nk1
      ,:old.name
      ,n_name
      ,:old.type
      ,n_type
      ,:old.description
      ,n_description
      );
end programs_iou;
/
select 'PROGRAMS_IOU' as "Trigger:"
 from  user_errors
 where name = 'PROGRAMS_IOU'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'PROGRAMS_IOU'
  and  type = 'TRIGGER'
 order by sequence;

create TRIGGER programs_iod
   instead of delete on programs_act
   for each row
begin

   -- Trigger Programs_Iod
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:26 PM

   programs_view.del
      (:old.id
      ,:old.application_id
      ,:old.name
      ,:old.type
      ,:old.description
      );
end programs_iod;
/
select 'PROGRAMS_IOD' as "Trigger:"
 from  user_errors
 where name = 'PROGRAMS_IOD'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'PROGRAMS_IOD'
  and  type = 'TRIGGER'
 order by sequence;

create package body programs_view
is

-- Package Body Programs_View
--    View functions
--    (DML, Foreign Keys, Paths, and )
--
--    Generated by DTGen (http://code.google.com/p/dtgen)
--    July      27, 2012  09:34:26 PM

----------------------------------------
procedure ins
      (n_id  in out  NUMBER
      ,n_application_id  in out  NUMBER
      ,n_applications_nk1  in  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,n_type  in out  VARCHAR2
      ,n_description  in out  VARCHAR2
      )
   -- View insert procedure
is
begin
   if util.db_object_exists('PROGRAMS', 'MATERIALIZED VIEW')
   then
      raise_application_error(-20010, 'Insert not allowed on materialized view programs.  Inserts on programs must be performed on the central database.');
   end if;
   -- Set n_application_id, if needed
   if     n_application_id is null
      and n_applications_nk1 is not null
   then
      n_application_id :=
         applications_dml.get_id
            (n_applications_nk1
            );
   end if;
   if not glob.get_db_constraints
   then
      programs_tab.ins
         (n_id
         ,n_application_id
         ,n_name
         ,n_type
         ,n_description
         );
   end if;
   insert into programs
         (id
         ,application_id
         ,name
         ,type
         ,description
         )
   values
         (n_id
         ,n_application_id
         ,n_name
         ,n_type
         ,n_description
         );
end ins;
----------------------------------------
procedure upd
      (o_id  in  NUMBER
      ,o_application_id  in  NUMBER
      ,o_applications_nk1  in  VARCHAR2
      ,n_application_id  in out  NUMBER
      ,n_applications_nk1  in  VARCHAR2
      ,o_name  in  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,o_type  in  VARCHAR2
      ,n_type  in out  VARCHAR2
      ,o_description  in  VARCHAR2
      ,n_description  in out  VARCHAR2
      )
   -- View Update procedure
is
begin
   if util.db_object_exists('PROGRAMS', 'MATERIALIZED VIEW')
   then
      raise_application_error(-20010, 'Update not allowed on materialized view programs.  Updates on programs must be performed on the central database.');
   end if;
   -- Set n_application_id, if needed
   if     n_application_id = o_application_id
      and (   not (n_applications_nk1 = o_applications_nk1)
          )
   then
      n_application_id :=
         applications_dml.get_id
            (n_applications_nk1
            );
   end if;
   if not glob.get_db_constraints
   then
      programs_tab.upd
         (o_id
         ,o_application_id
         ,n_application_id
         ,o_name
         ,n_name
         ,o_type
         ,n_type
         ,o_description
         ,n_description
         );
   end if;
   update programs PRG
     set  PRG.application_id = n_application_id
         ,PRG.name = n_name
         ,PRG.type = n_type
         ,PRG.description = n_description
    where PRG.id = o_id;
end upd;
----------------------------------------
procedure del
      (o_id  in  NUMBER
      ,o_application_id  in  NUMBER
      ,o_name  in  VARCHAR2
      ,o_type  in  VARCHAR2
      ,o_description  in  VARCHAR2
      )
is
begin
   if util.db_object_exists('PROGRAMS', 'MATERIALIZED VIEW')
   then
      raise_application_error(-20010, 'Delete not allowed on materialized view programs.  Deletes on programs must be performed on the central database.');
   end if;
   if not glob.get_db_constraints
   then
      programs_tab.del
         (o_id
         ,o_application_id
         ,o_name
         ,o_type
         ,o_description
         );
   end if;
   delete from programs  PRG
    where PRG.id = o_id;
end del;
----------------------------------------
end programs_view;
/
select 'PROGRAMS_VIEW' as "Package Body:"
 from  user_errors
 where name = 'PROGRAMS_VIEW'
  and  type = 'PACKAGE BODY'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'PROGRAMS_VIEW'
  and  type = 'PACKAGE BODY'
 order by sequence;

create package body programs_dml
is

 -- Package Body Programs_Dml
 -- (Data Manipulation Language, Foreign Key and Path Lookup)

 --    Generated by DTGen (http://code.google.com/p/dtgen)
 --    July      27, 2012  09:34:26 PM

----------------------------------------
function get_next_id
      return number
is
   retid  number;
begin
   select programs_seq.nextval into retid from dual;
   return retid;
end get_next_id;
----------------------------------------
function get_curr_id
      return number
is
   retid  number;
begin
   select programs_seq.currval into retid from dual;
   return retid;
end get_curr_id;
----------------------------------------
function get_id
      (programs_nk1  in  VARCHAR2
      ,programs_nk2  in  VARCHAR2
      ) return number
   -- For all the Natural Key Columns, Return an ID
is
   retid  number(38);
begin
   select id
    into  retid
    from  programs  PRG
    where PRG.application_id = applications_dml.get_id
             (programs_nk1
             )
     and  PRG.name = programs_nk2
    ;
   return retid;
exception
   when no_data_found
   then
      return null;
   when others
   then
      raise;
end get_id;
----------------------------------------
function get_nk
      (id_in  in  number)
   return varchar2
   -- For an ID, return a delimited list of Natural Key Values
is
   rtxt  varchar2(32767);
begin
   select substr(   applications_dml.get_nk(PRG.application_id)
    || util.nk_sep || PRG.name
                         ,1,32767)
    into  rtxt
    from  programs PRG
    where PRG.id = id_in;
   return rtxt;
exception
   when no_data_found then
      return null;
   when others then
      raise;
end get_nk;
----------------------------------------
function tab_to_col
      (id_in  in  number)
   return col_type
is
   -- This function is duplicated in programs_POP
   cursor acur is
      select * from programs
       where id = id_in;
   abuf   acur%ROWTYPE;
   rcol      col_type;
begin
   open acur;
   fetch acur into abuf;
   if acur%NOTFOUND
   then
      rcol := COL_TYPE(null);
      close acur;
      return rcol;
   end if;
   rcol := COL_TYPE
             (PAIR_TYPE('application_id', to_char(abuf.application_id))
             ,PAIR_TYPE('name', abuf.name)
             ,PAIR_TYPE('type', abuf.type)
             ,PAIR_TYPE('description', abuf.description)
                );
   close acur;
   return rcol;
end tab_to_col;
----------------------------------------
procedure ins
      (n_id  in out  NUMBER
      ,n_application_id  in out  NUMBER
      ,n_applications_nk1_in  in  VARCHAR2  default null
      ,n_name  in out  VARCHAR2
      ,n_type  in out  VARCHAR2
      ,n_description  in out  VARCHAR2
      )
   -- Application Insert procedure
is
begin
   programs_view.ins
      (n_id
      ,n_application_id
      ,n_applications_nk1_in
      ,n_name
      ,n_type
      ,n_description
      );
end ins;
----------------------------------------
procedure upd
      (o_id_in  in  NUMBER
      ,n_application_id  in out  NUMBER
      ,n_applications_nk1_in  in  VARCHAR2  default null
      ,n_name  in out  VARCHAR2
      ,n_type  in out  VARCHAR2
      ,n_description  in out  VARCHAR2
      ,nkdata_provided_in  in   VARCHAR2  default null
      )
   -- Application Update procedure
is
   o_application_id  NUMBER(38);
   o_applications_nk1  VARCHAR2(5);
   n_applications_nk1  VARCHAR2(5);
   o_name  VARCHAR2(30);
   o_type  VARCHAR2(30);
   o_description  VARCHAR2(1000);
begin
   -- Retrieve the old (before update) data
   select PRG.application_id
         ,PRG.applications_nk1
         ,PRG.name
         ,PRG.type
         ,PRG.description
    into  o_application_id
         ,o_applications_nk1
         ,o_name
         ,o_type
         ,o_description
    from  programs_act  PRG
    where PRG.id = o_id_in;
   -- Set the Natural Key data as indicated by NKDATA_PROVIDED
   if upper(substr(nkdata_provided_in,1,1)) in ('Y','T')
   then
      -- Use the Natural Key Data that was provided
      n_applications_nk1 := n_applications_nk1_in;
   else
      -- Use the old Natural Key Data
      n_applications_nk1 := o_applications_nk1;
   end if;
   -- Run the update
   programs_view.upd
      (o_id_in
      ,o_application_id
      ,o_applications_nk1
      ,n_application_id
      ,n_applications_nk1
      ,o_name
      ,n_name
      ,o_type
      ,n_type
      ,o_description
      ,n_description
      );
end upd;
----------------------------------------
procedure del
      (o_id_in  in  NUMBER
      )
   -- Application Delete procedure
is
   o_application_id  NUMBER(38);
   o_name  VARCHAR2(30);
   o_type  VARCHAR2(30);
   o_description  VARCHAR2(1000);
begin
   select PRG.application_id
         ,PRG.name
         ,PRG.type
         ,PRG.description
    into  o_application_id
         ,o_name
         ,o_type
         ,o_description
    from  programs  PRG
    where PRG.id = o_id_in;
   programs_view.del
      (o_id_in
      ,o_application_id
      ,o_name
      ,o_type
      ,o_description
      );
end del;
----------------------------------------
end programs_dml;
/
select 'PROGRAMS_DML' as "Package Body:"
 from  user_errors
 where name = 'PROGRAMS_DML'
  and  type = 'PACKAGE BODY'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'PROGRAMS_DML'
  and  type = 'PACKAGE BODY'
 order by sequence;

----------------------------------------
select '***  exceptions  ***' as TABLE_NAME from dual;
----------------------------------------

create package exceptions_view
is

   -- Package Exceptions_View
   --    View functions
   --    (DML, Foreign Keys, Paths, and )
   --
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:27 PM

   procedure ins
      (n_id  in out  NUMBER
      ,n_application_id  in out  NUMBER
      ,n_applications_nk1  in  VARCHAR2
      ,n_code  in out  NUMBER
      ,n_name  in out  VARCHAR2
      ,n_message  in out  VARCHAR2
      ,n_cause  in out  VARCHAR2
      ,n_action  in out  VARCHAR2
      );
   procedure upd
      (o_id  in  NUMBER
      ,o_application_id  in  NUMBER
      ,o_applications_nk1  in  VARCHAR2
      ,n_application_id  in out  NUMBER
      ,n_applications_nk1  in  VARCHAR2
      ,o_code  in  NUMBER
      ,n_code  in out  NUMBER
      ,o_name  in  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,o_message  in  VARCHAR2
      ,n_message  in out  VARCHAR2
      ,o_cause  in  VARCHAR2
      ,n_cause  in out  VARCHAR2
      ,o_action  in  VARCHAR2
      ,n_action  in out  VARCHAR2
      );
   procedure del
      (o_id  in  NUMBER
      ,o_application_id  in  NUMBER
      ,o_code  in  NUMBER
      ,o_name  in  VARCHAR2
      ,o_message  in  VARCHAR2
      ,o_cause  in  VARCHAR2
      ,o_action  in  VARCHAR2
      );
end exceptions_view;
/
select 'EXCEPTIONS_VIEW' as "Package:"
 from  user_errors
 where name = 'EXCEPTIONS_VIEW'
  and  type = 'PACKAGE'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'EXCEPTIONS_VIEW'
  and  type = 'PACKAGE'
 order by sequence;

create package exceptions_dml
is

   -- Package Exceptions_Dml
   -- (Data Manipulation Language, Foreign Key and Path Lookup)

   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:27 PM

   function get_next_id
      return number;
   function get_curr_id
      return number;

   function get_id
      (exceptions_nk1  in  VARCHAR2
      ,exceptions_nk2  in  NUMBER
      ) return number;
   function get_nk
      (id_in  in  number
      ) return varchar2;

   function tab_to_col
         (id_in  in  number)
      return col_type;

   procedure ins
      (n_id  in out  NUMBER
      ,n_application_id  in out  NUMBER
      ,n_applications_nk1_in  in  VARCHAR2  default null
      ,n_code  in out  NUMBER
      ,n_name  in out  VARCHAR2
      ,n_message  in out  VARCHAR2
      ,n_cause  in out  VARCHAR2
      ,n_action  in out  VARCHAR2
      );
   procedure upd
      (o_id_in  in  NUMBER
      ,n_application_id  in out  NUMBER
      ,n_applications_nk1_in  in  VARCHAR2  default null
      ,n_code  in out  NUMBER
      ,n_name  in out  VARCHAR2
      ,n_message  in out  VARCHAR2
      ,n_cause  in out  VARCHAR2
      ,n_action  in out  VARCHAR2
      ,nkdata_provided_in  in   VARCHAR2  default null
      );
   procedure del
      (o_id_in  in  NUMBER
      );
end exceptions_dml;
/
select 'EXCEPTIONS_DML' as "Package:"
 from  user_errors
 where name = 'EXCEPTIONS_DML'
  and  type = 'PACKAGE'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'EXCEPTIONS_DML'
  and  type = 'PACKAGE'
 order by sequence;

create view exceptions_act
      (id
      ,application_id
      ,applications_nk1
      ,code
      ,name
      ,message
      ,cause
      ,action
      )
   as select
       EXC.id
      ,EXC.application_id
      ,APP.abbr
      ,EXC.code
      ,EXC.name
      ,EXC.message
      ,EXC.cause
      ,EXC.action
 from             exceptions EXC
       inner join applications APP on APP.id = EXC.application_id
 ;
select 'EXCEPTIONS_ACT' as "View:"
 from  user_errors
 where name = 'EXCEPTIONS_ACT'
  and  type = 'VIEW'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'EXCEPTIONS_ACT'
  and  type = 'VIEW'
 order by sequence;

comment on table exceptions_act is 'Application Exceptions for Error Trapping';

comment on column exceptions_act.id is 'Surrogate Primary Key for these exceptions_act';
comment on column exceptions_act.application_id is 'Surrogate Key for the application of this exception';
comment on column exceptions_act.code is 'RAISE_APPLICATION_ERROR Code for this exception';
comment on column exceptions_act.name is 'PRAGMA EXCEPTION_INIT Name for this exception';
comment on column exceptions_act.message is 'Error Message for this exception';
comment on column exceptions_act.cause is 'Error Cause for this exception';
comment on column exceptions_act.action is 'Possible Solution for this exception';
comment on column exceptions_act.applications_nk1 is 'APPLICATIONS Natural Key Value 1: Abbreviation for this application';

alter view exceptions_act add constraint exceptions_act_pk
   primary key (id) disable;

alter view exceptions_act add constraint exceptions_act_fk1
   foreign key (application_id) references applications_act (id) disable;

create TRIGGER exceptions_ioi
   instead of insert on exceptions_act
   for each row
declare
   n_id  NUMBER(38);
   n_application_id  NUMBER(38);
   n_code  NUMBER(5);
   n_name  VARCHAR2(30);
   n_message  VARCHAR2(2048);
   n_cause  VARCHAR2(2048);
   n_action  VARCHAR2(2048);
begin

   -- Trigger Exceptions_Ioi
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:27 PM

   n_id := :new.id;
   n_application_id := :new.application_id;
   n_code := :new.code;
   n_name := :new.name;
   n_message := :new.message;
   n_cause := :new.cause;
   n_action := :new.action;
   exceptions_view.ins
      (n_id
      ,n_application_id
      ,:new.applications_nk1
      ,n_code
      ,n_name
      ,n_message
      ,n_cause
      ,n_action
      );
end exceptions_ioi;
/
select 'EXCEPTIONS_IOI' as "Trigger:"
 from  user_errors
 where name = 'EXCEPTIONS_IOI'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'EXCEPTIONS_IOI'
  and  type = 'TRIGGER'
 order by sequence;

create TRIGGER exceptions_iou
   instead of update on exceptions_act
   for each row
declare
   n_application_id  NUMBER(38);
   n_code  NUMBER(5);
   n_name  VARCHAR2(30);
   n_message  VARCHAR2(2048);
   n_cause  VARCHAR2(2048);
   n_action  VARCHAR2(2048);
begin

   -- Trigger Exceptions_Iou
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:27 PM

   n_application_id := :new.application_id;
   n_code := :new.code;
   n_name := :new.name;
   n_message := :new.message;
   n_cause := :new.cause;
   n_action := :new.action;
   exceptions_view.upd
      (:old.id
      ,:old.application_id
      ,:old.applications_nk1
      ,n_application_id
      ,:new.applications_nk1
      ,:old.code
      ,n_code
      ,:old.name
      ,n_name
      ,:old.message
      ,n_message
      ,:old.cause
      ,n_cause
      ,:old.action
      ,n_action
      );
end exceptions_iou;
/
select 'EXCEPTIONS_IOU' as "Trigger:"
 from  user_errors
 where name = 'EXCEPTIONS_IOU'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'EXCEPTIONS_IOU'
  and  type = 'TRIGGER'
 order by sequence;

create TRIGGER exceptions_iod
   instead of delete on exceptions_act
   for each row
begin

   -- Trigger Exceptions_Iod
   --    Generated by DTGen (http://code.google.com/p/dtgen)
   --    July      27, 2012  09:34:27 PM

   exceptions_view.del
      (:old.id
      ,:old.application_id
      ,:old.code
      ,:old.name
      ,:old.message
      ,:old.cause
      ,:old.action
      );
end exceptions_iod;
/
select 'EXCEPTIONS_IOD' as "Trigger:"
 from  user_errors
 where name = 'EXCEPTIONS_IOD'
  and  type = 'TRIGGER'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'EXCEPTIONS_IOD'
  and  type = 'TRIGGER'
 order by sequence;

create package body exceptions_view
is

-- Package Body Exceptions_View
--    View functions
--    (DML, Foreign Keys, Paths, and )
--
--    Generated by DTGen (http://code.google.com/p/dtgen)
--    July      27, 2012  09:34:27 PM

----------------------------------------
procedure ins
      (n_id  in out  NUMBER
      ,n_application_id  in out  NUMBER
      ,n_applications_nk1  in  VARCHAR2
      ,n_code  in out  NUMBER
      ,n_name  in out  VARCHAR2
      ,n_message  in out  VARCHAR2
      ,n_cause  in out  VARCHAR2
      ,n_action  in out  VARCHAR2
      )
   -- View insert procedure
is
begin
   if util.db_object_exists('EXCEPTIONS', 'MATERIALIZED VIEW')
   then
      raise_application_error(-20010, 'Insert not allowed on materialized view exceptions.  Inserts on exceptions must be performed on the central database.');
   end if;
   -- Set n_application_id, if needed
   if     n_application_id is null
      and n_applications_nk1 is not null
   then
      n_application_id :=
         applications_dml.get_id
            (n_applications_nk1
            );
   end if;
   if not glob.get_db_constraints
   then
      exceptions_tab.ins
         (n_id
         ,n_application_id
         ,n_code
         ,n_name
         ,n_message
         ,n_cause
         ,n_action
         );
   end if;
   insert into exceptions
         (id
         ,application_id
         ,code
         ,name
         ,message
         ,cause
         ,action
         )
   values
         (n_id
         ,n_application_id
         ,n_code
         ,n_name
         ,n_message
         ,n_cause
         ,n_action
         );
end ins;
----------------------------------------
procedure upd
      (o_id  in  NUMBER
      ,o_application_id  in  NUMBER
      ,o_applications_nk1  in  VARCHAR2
      ,n_application_id  in out  NUMBER
      ,n_applications_nk1  in  VARCHAR2
      ,o_code  in  NUMBER
      ,n_code  in out  NUMBER
      ,o_name  in  VARCHAR2
      ,n_name  in out  VARCHAR2
      ,o_message  in  VARCHAR2
      ,n_message  in out  VARCHAR2
      ,o_cause  in  VARCHAR2
      ,n_cause  in out  VARCHAR2
      ,o_action  in  VARCHAR2
      ,n_action  in out  VARCHAR2
      )
   -- View Update procedure
is
begin
   if util.db_object_exists('EXCEPTIONS', 'MATERIALIZED VIEW')
   then
      raise_application_error(-20010, 'Update not allowed on materialized view exceptions.  Updates on exceptions must be performed on the central database.');
   end if;
   -- Set n_application_id, if needed
   if     n_application_id = o_application_id
      and (   not (n_applications_nk1 = o_applications_nk1)
          )
   then
      n_application_id :=
         applications_dml.get_id
            (n_applications_nk1
            );
   end if;
   if not glob.get_db_constraints
   then
      exceptions_tab.upd
         (o_id
         ,o_application_id
         ,n_application_id
         ,o_code
         ,n_code
         ,o_name
         ,n_name
         ,o_message
         ,n_message
         ,o_cause
         ,n_cause
         ,o_action
         ,n_action
         );
   end if;
   update exceptions EXC
     set  EXC.application_id = n_application_id
         ,EXC.code = n_code
         ,EXC.name = n_name
         ,EXC.message = n_message
         ,EXC.cause = n_cause
         ,EXC.action = n_action
    where EXC.id = o_id;
end upd;
----------------------------------------
procedure del
      (o_id  in  NUMBER
      ,o_application_id  in  NUMBER
      ,o_code  in  NUMBER
      ,o_name  in  VARCHAR2
      ,o_message  in  VARCHAR2
      ,o_cause  in  VARCHAR2
      ,o_action  in  VARCHAR2
      )
is
begin
   if util.db_object_exists('EXCEPTIONS', 'MATERIALIZED VIEW')
   then
      raise_application_error(-20010, 'Delete not allowed on materialized view exceptions.  Deletes on exceptions must be performed on the central database.');
   end if;
   if not glob.get_db_constraints
   then
      exceptions_tab.del
         (o_id
         ,o_application_id
         ,o_code
         ,o_name
         ,o_message
         ,o_cause
         ,o_action
         );
   end if;
   delete from exceptions  EXC
    where EXC.id = o_id;
end del;
----------------------------------------
end exceptions_view;
/
select 'EXCEPTIONS_VIEW' as "Package Body:"
 from  user_errors
 where name = 'EXCEPTIONS_VIEW'
  and  type = 'PACKAGE BODY'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'EXCEPTIONS_VIEW'
  and  type = 'PACKAGE BODY'
 order by sequence;

create package body exceptions_dml
is

 -- Package Body Exceptions_Dml
 -- (Data Manipulation Language, Foreign Key and Path Lookup)

 --    Generated by DTGen (http://code.google.com/p/dtgen)
 --    July      27, 2012  09:34:28 PM

----------------------------------------
function get_next_id
      return number
is
   retid  number;
begin
   select exceptions_seq.nextval into retid from dual;
   return retid;
end get_next_id;
----------------------------------------
function get_curr_id
      return number
is
   retid  number;
begin
   select exceptions_seq.currval into retid from dual;
   return retid;
end get_curr_id;
----------------------------------------
function get_id
      (exceptions_nk1  in  VARCHAR2
      ,exceptions_nk2  in  NUMBER
      ) return number
   -- For all the Natural Key Columns, Return an ID
is
   retid  number(38);
begin
   select id
    into  retid
    from  exceptions  EXC
    where EXC.application_id = applications_dml.get_id
             (exceptions_nk1
             )
     and  EXC.code = exceptions_nk2
    ;
   return retid;
exception
   when no_data_found
   then
      return null;
   when others
   then
      raise;
end get_id;
----------------------------------------
function get_nk
      (id_in  in  number)
   return varchar2
   -- For an ID, return a delimited list of Natural Key Values
is
   rtxt  varchar2(32767);
begin
   select substr(   applications_dml.get_nk(EXC.application_id)
    || util.nk_sep || EXC.code
                         ,1,32767)
    into  rtxt
    from  exceptions EXC
    where EXC.id = id_in;
   return rtxt;
exception
   when no_data_found then
      return null;
   when others then
      raise;
end get_nk;
----------------------------------------
function tab_to_col
      (id_in  in  number)
   return col_type
is
   -- This function is duplicated in exceptions_POP
   cursor acur is
      select * from exceptions
       where id = id_in;
   abuf   acur%ROWTYPE;
   rcol      col_type;
begin
   open acur;
   fetch acur into abuf;
   if acur%NOTFOUND
   then
      rcol := COL_TYPE(null);
      close acur;
      return rcol;
   end if;
   rcol := COL_TYPE
             (PAIR_TYPE('application_id', to_char(abuf.application_id))
             ,PAIR_TYPE('code', to_char(abuf.code))
             ,PAIR_TYPE('name', abuf.name)
             ,PAIR_TYPE('message', abuf.message)
             ,PAIR_TYPE('cause', abuf.cause)
             ,PAIR_TYPE('action', abuf.action)
                );
   close acur;
   return rcol;
end tab_to_col;
----------------------------------------
procedure ins
      (n_id  in out  NUMBER
      ,n_application_id  in out  NUMBER
      ,n_applications_nk1_in  in  VARCHAR2  default null
      ,n_code  in out  NUMBER
      ,n_name  in out  VARCHAR2
      ,n_message  in out  VARCHAR2
      ,n_cause  in out  VARCHAR2
      ,n_action  in out  VARCHAR2
      )
   -- Application Insert procedure
is
begin
   exceptions_view.ins
      (n_id
      ,n_application_id
      ,n_applications_nk1_in
      ,n_code
      ,n_name
      ,n_message
      ,n_cause
      ,n_action
      );
end ins;
----------------------------------------
procedure upd
      (o_id_in  in  NUMBER
      ,n_application_id  in out  NUMBER
      ,n_applications_nk1_in  in  VARCHAR2  default null
      ,n_code  in out  NUMBER
      ,n_name  in out  VARCHAR2
      ,n_message  in out  VARCHAR2
      ,n_cause  in out  VARCHAR2
      ,n_action  in out  VARCHAR2
      ,nkdata_provided_in  in   VARCHAR2  default null
      )
   -- Application Update procedure
is
   o_application_id  NUMBER(38);
   o_applications_nk1  VARCHAR2(5);
   n_applications_nk1  VARCHAR2(5);
   o_code  NUMBER(5);
   o_name  VARCHAR2(30);
   o_message  VARCHAR2(2048);
   o_cause  VARCHAR2(2048);
   o_action  VARCHAR2(2048);
begin
   -- Retrieve the old (before update) data
   select EXC.application_id
         ,EXC.applications_nk1
         ,EXC.code
         ,EXC.name
         ,EXC.message
         ,EXC.cause
         ,EXC.action
    into  o_application_id
         ,o_applications_nk1
         ,o_code
         ,o_name
         ,o_message
         ,o_cause
         ,o_action
    from  exceptions_act  EXC
    where EXC.id = o_id_in;
   -- Set the Natural Key data as indicated by NKDATA_PROVIDED
   if upper(substr(nkdata_provided_in,1,1)) in ('Y','T')
   then
      -- Use the Natural Key Data that was provided
      n_applications_nk1 := n_applications_nk1_in;
   else
      -- Use the old Natural Key Data
      n_applications_nk1 := o_applications_nk1;
   end if;
   -- Run the update
   exceptions_view.upd
      (o_id_in
      ,o_application_id
      ,o_applications_nk1
      ,n_application_id
      ,n_applications_nk1
      ,o_code
      ,n_code
      ,o_name
      ,n_name
      ,o_message
      ,n_message
      ,o_cause
      ,n_cause
      ,o_action
      ,n_action
      );
end upd;
----------------------------------------
procedure del
      (o_id_in  in  NUMBER
      )
   -- Application Delete procedure
is
   o_application_id  NUMBER(38);
   o_code  NUMBER(5);
   o_name  VARCHAR2(30);
   o_message  VARCHAR2(2048);
   o_cause  VARCHAR2(2048);
   o_action  VARCHAR2(2048);
begin
   select EXC.application_id
         ,EXC.code
         ,EXC.name
         ,EXC.message
         ,EXC.cause
         ,EXC.action
    into  o_application_id
         ,o_code
         ,o_name
         ,o_message
         ,o_cause
         ,o_action
    from  exceptions  EXC
    where EXC.id = o_id_in;
   exceptions_view.del
      (o_id_in
      ,o_application_id
      ,o_code
      ,o_name
      ,o_message
      ,o_cause
      ,o_action
      );
end del;
----------------------------------------
end exceptions_dml;
/
select 'EXCEPTIONS_DML' as "Package Body:"
 from  user_errors
 where name = 'EXCEPTIONS_DML'
  and  type = 'PACKAGE BODY'
  and  rownum = 1;
select '('||line||'/'||position||') '||text as error
 from  user_errors
 where name = 'EXCEPTIONS_DML'
  and  type = 'PACKAGE BODY'
 order by sequence;



select ' -) create_aa  ' as FILE_NAME from dual;



select ' -) create_mods  ' as FILE_NAME from dual;


-- Script File "create_mods"
--    Create Program Modules
--
--    Generated by DTGen (http://code.google.com/p/dtgen)
--    July      27, 2012  09:34:29 PM


create PACKAGE assemble
as
end assemble;
/

create PACKAGE generate
as
end generate;
/


