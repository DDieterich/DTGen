create or replace
package body glob
is

-- Package Body Glob
--    Globally available settings and functions
--    (Centrally located, but globally visible)
--
--    Generated by DTGen (http://code.google.com/p/dtgen)
--    April     02, 2012  04:02:19 PM

st_expiration_specs   INTEGER;        -- Single Threaded DBMS_LOCK
st_lockhandle         varchar2(128);  -- Single Threaded DBMS_LOCK
st_lockmode           INTEGER;        -- Single Threaded DBMS_LOCK
st_lockname           varchar2(128);  -- Single Threaded DBMS_LOCK
st_release_on_commit  BOOLEAN;        -- Single Threaded DBMS_LOCK
st_timeout            number;         -- Single Threaded DBMS_LOCK

----------------------------------------
function get_db_constraints
      return boolean
is
begin
   return glob.db_constraints;
end get_db_constraints;
----------------------------------------
function get_fold_strings
      return boolean
is
begin
   return glob.fold_strings;
end get_fold_strings;
----------------------------------------
function get_dtm
      return timestamp with local time zone
is
begin
   return systimestamp;
end get_dtm;
----------------------------------------
procedure upd_early_eff
   (table_name  in  varchar2
   ,eff_dtm_in  in  timestamp
   )
   -- Centralized procedure to set next ETL start date/time
is
begin
   null;
end upd_early_eff;
----------------------------------------
function request_lock
      (lockname_in  in  varchar2)
   return varchar2
is
   retcd number;
begin
   if st_lockname is not null
   then
      if st_lockname = lockname_in
      then
         return 'SUCCESS';
      else
         return 'RELEASE ONLY';
      end if;
   end if;
   st_expiration_specs  := 3000;
   st_lockmode          := DBMS_LOCK.X_MODE;
   st_lockname          := lockname_in;
   st_release_on_commit := FALSE;
   st_timeout           := 1;
   dbms_lock.allocate_unique(lockname_in
                            ,st_lockhandle
                            ,st_expiration_specs);
   retcd := dbms_lock.request(st_lockhandle
                             ,st_lockmode
                             ,st_timeout);
   case retcd
      when 0 then
         return 'SUCCESS';
      when 4 then
         -- This session already owns the lock
         return 'SUCCESS';
      when 1 then
         st_lockname   := null;
         return 'TIMEOUT';
      when 2 then
         st_lockname   := null;
         return 'DEADLOCK';
      when 3 then
         st_lockname   := null;
         return 'PARAMETER ERROR';
      when 5 then
         st_lockname   := null;
         return 'ILLEGAL LOCKNAME';
   end case;
   return 'END ERROR';
end request_lock;
----------------------------------------
function release_lock
   return varchar2
is
   retcd INTEGER;
begin
   if st_lockname is null
   then
      return 'SUCCESS';
   end if;
   retcd := dbms_lock.release(st_lockhandle);
   case retcd
      when 0 then
         st_lockname   := null;
         return 'SUCCESS';
      when 4 then
         -- This session doesn't own the lock
         st_lockname   := null;
         return 'SUCCESS';
      when 3 then
         return 'PARAMETER ERROR';
      when 5 then
         return 'ILLEGAL LOCKNAME';
   end case;
   return 'END ERROR';
end release_lock;
----------------------------------------
begin
   st_lockname := null;
end glob;