create or replace
package body util
is

-- Package Body Util
--    Utility settings and functions
--    (A copy is located locally on a each node)
--
--    Generated by DTGen (http://code.google.com/p/dtgen)
--    April     02, 2012  04:02:19 PM

lo_context      BINARY_INTEGER;  -- DBMS_APPLICATION.set_session_longops
lo_op_name      varchar2(64);    -- DBMS_APPLICATION.set_session_longops
lo_rindex       BINARY_INTEGER;  -- DBMS_APPLICATION.set_session_longops
lo_slno         BINARY_INTEGER;  -- DBMS_APPLICATION.set_session_longops
lo_sofar        number;          -- DBMS_APPLICATION.set_session_longops
lo_totalwork    number;          -- DBMS_APPLICATION.set_session_longops
lo_target       BINARY_INTEGER;  -- DBMS_APPLICATION.set_session_longops
lo_target_desc  varchar2(32);    -- DBMS_APPLICATION.set_session_longops
lo_units        varchar2(32);    -- DBMS_APPLICATION.set_session_longops

----------------------------------------
function get_version
   return varchar2
is
begin
   return 'DTGen_0.5';
end get_version;
----------------------------------------
function get_first_dtm
   return timestamp with time zone
is
begin
   return first_dtm;
end get_first_dtm;
----------------------------------------
function get_last_dtm
      return timestamp with time zone
is
begin
   return last_dtm;
end get_last_dtm;
----------------------------------------
procedure set_asof_dtm
      (asof_dtm_in  in  timestamp with time zone)
is
begin
   asof_dtm := asof_dtm_in;
end set_asof_dtm;
----------------------------------------
function get_asof_dtm
   return timestamp with time zone
is
begin
   return asof_dtm;
end get_asof_dtm;
----------------------------------------
function is_equal
      (t1_in  in  varchar2
      ,t2_in  in  varchar2
      )
   return boolean
is
begin
   if t1_in = t2_in or (t1_in is null and t2_in is null)
   then
      return TRUE;
   else
      return FALSE;
   end if;
end is_equal;
----------------------------------------
function is_equal
      (n1_in  in  number
      ,n2_in  in  number
      )
   return boolean
is
begin
   if n1_in = n2_in or (n1_in is null and n2_in is null)
   then
      return TRUE;
   else
      return FALSE;
   end if;
end is_equal;
----------------------------------------
procedure set_usr
      (usr_in  in  varchar2)
is
begin
   current_usr := substr(usr_in,1,30);
end set_usr;
----------------------------------------
function get_usr
   return varchar
is
begin
   if current_usr is null
   then
      raise_application_error(-20002, 'Current User has not been set in the Util Package.');
   end if;
   return current_usr;
end get_usr;
----------------------------------------
procedure init_longops
      (opname_in       in  varchar2
      ,totalwork_in    in  number
      ,target_desc_in  in  varchar2
      ,units_in        in  varchar2)
is
begin
   if lo_rindex = dbms_application_info.set_session_longops_nohint
   then
      lo_slno        := null;
      lo_op_name     := opname_in;
      lo_target      := 0;
      lo_context     := 0;
      lo_sofar       := 0;
      lo_totalwork   := totalwork_in;
      lo_target_desc := target_desc_in;
      lo_units       := units_in;
      dbms_application_info.set_session_longops
         (lo_rindex, lo_slno, lo_op_name, lo_target, lo_context,
          lo_sofar, lo_totalwork, lo_target_desc, lo_units);
   end if;
end init_longops;
----------------------------------------
procedure add_longops
      (add_sofar_in  in  number)
is
begin
   if lo_rindex <> dbms_application_info.set_session_longops_nohint
   then
      lo_sofar := lo_sofar + add_sofar_in;
      dbms_application_info.set_session_longops
         (lo_rindex, lo_slno, lo_op_name, lo_target, lo_context,
          lo_sofar, lo_totalwork, lo_target_desc, lo_units);
   end if;
end add_longops;
----------------------------------------
procedure end_longops
is
begin
   if lo_rindex <> dbms_application_info.set_session_longops_nohint
   then
      lo_sofar := lo_totalwork;
      dbms_application_info.set_session_longops
         (lo_rindex, lo_slno, lo_op_name, lo_target, lo_context,
          lo_sofar, lo_totalwork, lo_target_desc, lo_units);
      lo_rindex := dbms_application_info.set_session_longops_nohint;
   end if;
end end_longops;
----------------------------------------
procedure log
      (txt_in  in  varchar2
      ,loc_in  in  varchar2 default null
      )
is
/*  Sample output from DBMS_UTILITY.FORMAT_CALL_STACK:
----- PL/SQL Call Stack -----
  object      line  object
  handle    number  name
A4A6A840        76  package body GEN2.UTIL
AA345744         6  anonymous block
AA345744        16  anonymous block
*/
   PRAGMA AUTONOMOUS_TRANSACTION;
   usr_txt  varchar2(30);
   fcs_txt  varchar2(2000);
begin
   -- pragma restrict_references(format_call_stack,WNDS);
   -- WNDS Asserts that the subprogram writes no database state
   --      (does not modify database tables).
   -- DBMS_UTILITY.FORMAT_CALL_STACK returns up to 2000 characters
   fcs_txt := nvl(loc_in, DBMS_UTILITY.FORMAT_CALL_STACK);
   begin
      usr_txt := get_usr;
   exception
      when others then
         usr_txt := 'UTIL.LOG (No User)';
   end;
   insert into util_log
         (dtm
         ,usr
         ,txt
         ,loc
         )
      values
         (systimestamp
         ,usr_txt
         ,substr(txt_in,1,4000)
         ,fcs_txt
         );
   dbms_output.put_line(txt_in || fcs_txt);
   commit;
end log;
----------------------------------------
procedure err
      (txt_in  in  varchar2
      )
is
   fcs_txt  varchar2(2000) := DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
   retcd    INTEGER;
begin
   log (txt_in, fcs_txt);
   end_longops;
   retcd := glob.release_lock;
end err;
----------------------------------------
function db_object_exists
      (name_in  in  varchar2
      ,type_in  in  varchar2
      )
   return boolean
is
   cursor c1 is
      select * from all_objects
       where object_type = type_in
        and  object_name = name_in;
   buf1 c1%ROWTYPE;
   retb boolean;
begin
   open c1;
   fetch c1 into buf1;
   retb := c1%FOUND;
   close c1;
   return retb;
end db_object_exists;
----------------------------------------
function col_to_clob
      (col_in  in  col_type
      )
   return clob
is
   rclob  clob;
   rlen   number;
begin
   rclob := '';
   for i in 1 .. col_in.COUNT
   loop
      rclob := rclob ||
               col_in(i).name || ':' ||
               col_in(i).data || CHR(10);
   end loop;
   rlen := length(rclob);
   if rlen > 32768
   then
      rlen := 32768;
   end if;
   return substr(rclob,1,rlen-1);
exception
  when SUBSCRIPT_BEYOND_COUNT
  then
     return null;
  when COLLECTION_IS_NULL
  then
     return null;
  when others
  then
     raise;
end col_to_clob;
----------------------------------------
function col_data
         (col_in   in  col_type
         ,name_in  in  varchar2
         )
     return varchar2
is
   --
   -- col_data was used for the POP_AUDIT log table
   --
begin
   for i in 1 .. col_in.COUNT
   loop
      if lower(name_in) = lower(col_in(i).name)
      then
         return col_in(i).data;
      end if;
   end loop;
   return null;
exception
  when SUBSCRIPT_BEYOND_COUNT
  then
     return null;
  when COLLECTION_IS_NULL
  then
     return null;
  when others
  then
     raise;
end col_data;
----------------------------------------
begin
   dbms_output.enable(1048576);
   lo_rindex := dbms_application_info.set_session_longops_nohint;
end util;